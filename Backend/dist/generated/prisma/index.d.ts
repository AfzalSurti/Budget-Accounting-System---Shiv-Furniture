
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model AnalyticAccount
 * 
 */
export type AnalyticAccount = $Result.DefaultSelection<Prisma.$AnalyticAccountPayload>
/**
 * Model GLAccount
 * 
 */
export type GLAccount = $Result.DefaultSelection<Prisma.$GLAccountPayload>
/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model JournalLine
 * 
 */
export type JournalLine = $Result.DefaultSelection<Prisma.$JournalLinePayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model BudgetRevision
 * 
 */
export type BudgetRevision = $Result.DefaultSelection<Prisma.$BudgetRevisionPayload>
/**
 * Model BudgetLine
 * 
 */
export type BudgetLine = $Result.DefaultSelection<Prisma.$BudgetLinePayload>
/**
 * Model AutoAnalyticModel
 * 
 */
export type AutoAnalyticModel = $Result.DefaultSelection<Prisma.$AutoAnalyticModelPayload>
/**
 * Model AutoAnalyticRule
 * 
 */
export type AutoAnalyticRule = $Result.DefaultSelection<Prisma.$AutoAnalyticRulePayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderLine
 * 
 */
export type PurchaseOrderLine = $Result.DefaultSelection<Prisma.$PurchaseOrderLinePayload>
/**
 * Model SalesOrder
 * 
 */
export type SalesOrder = $Result.DefaultSelection<Prisma.$SalesOrderPayload>
/**
 * Model SalesOrderLine
 * 
 */
export type SalesOrderLine = $Result.DefaultSelection<Prisma.$SalesOrderLinePayload>
/**
 * Model VendorBill
 * 
 */
export type VendorBill = $Result.DefaultSelection<Prisma.$VendorBillPayload>
/**
 * Model VendorBillLine
 * 
 */
export type VendorBillLine = $Result.DefaultSelection<Prisma.$VendorBillLinePayload>
/**
 * Model CustomerInvoice
 * 
 */
export type CustomerInvoice = $Result.DefaultSelection<Prisma.$CustomerInvoicePayload>
/**
 * Model CustomerInvoiceLine
 * 
 */
export type CustomerInvoiceLine = $Result.DefaultSelection<Prisma.$CustomerInvoiceLinePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentAllocation
 * 
 */
export type PaymentAllocation = $Result.DefaultSelection<Prisma.$PaymentAllocationPayload>
/**
 * Model DocumentFile
 * 
 */
export type DocumentFile = $Result.DefaultSelection<Prisma.$DocumentFilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ContactType: {
  customer: 'customer',
  vendor: 'vendor',
  both: 'both',
  internal: 'internal'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]


export const DocStatus: {
  draft: 'draft',
  posted: 'posted',
  cancelled: 'cancelled'
};

export type DocStatus = (typeof DocStatus)[keyof typeof DocStatus]


export const OrderStatus: {
  draft: 'draft',
  confirmed: 'confirmed',
  cancelled: 'cancelled',
  done: 'done'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const BudgetStatus: {
  draft: 'draft',
  approved: 'approved',
  archived: 'archived'
};

export type BudgetStatus = (typeof BudgetStatus)[keyof typeof BudgetStatus]


export const JournalStatus: {
  draft: 'draft',
  posted: 'posted',
  void: 'void'
};

export type JournalStatus = (typeof JournalStatus)[keyof typeof JournalStatus]


export const JournalSourceType: {
  vendor_bill: 'vendor_bill',
  customer_invoice: 'customer_invoice',
  payment: 'payment',
  manual: 'manual'
};

export type JournalSourceType = (typeof JournalSourceType)[keyof typeof JournalSourceType]


export const PaymentDirection: {
  inbound: 'inbound',
  outbound: 'outbound'
};

export type PaymentDirection = (typeof PaymentDirection)[keyof typeof PaymentDirection]


export const PaymentStatus: {
  draft: 'draft',
  posted: 'posted',
  void: 'void'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  cash: 'cash',
  bank: 'bank',
  upi: 'upi',
  card: 'card',
  online: 'online',
  other: 'other'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const AllocationTargetType: {
  customer_invoice: 'customer_invoice',
  vendor_bill: 'vendor_bill'
};

export type AllocationTargetType = (typeof AllocationTargetType)[keyof typeof AllocationTargetType]


export const DocOwnerType: {
  customer_invoice: 'customer_invoice',
  vendor_bill: 'vendor_bill',
  sales_order: 'sales_order',
  purchase_order: 'purchase_order'
};

export type DocOwnerType = (typeof DocOwnerType)[keyof typeof DocOwnerType]


export const AutoDocType: {
  vendor_bill: 'vendor_bill',
  customer_invoice: 'customer_invoice',
  purchase_order: 'purchase_order',
  sales_order: 'sales_order'
};

export type AutoDocType = (typeof AutoDocType)[keyof typeof AutoDocType]


export const AccountType: {
  asset: 'asset',
  liability: 'liability',
  equity: 'equity',
  income: 'income',
  expense: 'expense'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]

}

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

export type DocStatus = $Enums.DocStatus

export const DocStatus: typeof $Enums.DocStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type BudgetStatus = $Enums.BudgetStatus

export const BudgetStatus: typeof $Enums.BudgetStatus

export type JournalStatus = $Enums.JournalStatus

export const JournalStatus: typeof $Enums.JournalStatus

export type JournalSourceType = $Enums.JournalSourceType

export const JournalSourceType: typeof $Enums.JournalSourceType

export type PaymentDirection = $Enums.PaymentDirection

export const PaymentDirection: typeof $Enums.PaymentDirection

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type AllocationTargetType = $Enums.AllocationTargetType

export const AllocationTargetType: typeof $Enums.AllocationTargetType

export type DocOwnerType = $Enums.DocOwnerType

export const DocOwnerType: typeof $Enums.DocOwnerType

export type AutoDocType = $Enums.AutoDocType

export const AutoDocType: typeof $Enums.AutoDocType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticAccount`: Exposes CRUD operations for the **AnalyticAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticAccounts
    * const analyticAccounts = await prisma.analyticAccount.findMany()
    * ```
    */
  get analyticAccount(): Prisma.AnalyticAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gLAccount`: Exposes CRUD operations for the **GLAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GLAccounts
    * const gLAccounts = await prisma.gLAccount.findMany()
    * ```
    */
  get gLAccount(): Prisma.GLAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalLine`: Exposes CRUD operations for the **JournalLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalLines
    * const journalLines = await prisma.journalLine.findMany()
    * ```
    */
  get journalLine(): Prisma.JournalLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgetRevision`: Exposes CRUD operations for the **BudgetRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetRevisions
    * const budgetRevisions = await prisma.budgetRevision.findMany()
    * ```
    */
  get budgetRevision(): Prisma.BudgetRevisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgetLine`: Exposes CRUD operations for the **BudgetLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetLines
    * const budgetLines = await prisma.budgetLine.findMany()
    * ```
    */
  get budgetLine(): Prisma.BudgetLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoAnalyticModel`: Exposes CRUD operations for the **AutoAnalyticModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoAnalyticModels
    * const autoAnalyticModels = await prisma.autoAnalyticModel.findMany()
    * ```
    */
  get autoAnalyticModel(): Prisma.AutoAnalyticModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoAnalyticRule`: Exposes CRUD operations for the **AutoAnalyticRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoAnalyticRules
    * const autoAnalyticRules = await prisma.autoAnalyticRule.findMany()
    * ```
    */
  get autoAnalyticRule(): Prisma.AutoAnalyticRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderLine`: Exposes CRUD operations for the **PurchaseOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderLines
    * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
    * ```
    */
  get purchaseOrderLine(): Prisma.PurchaseOrderLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesOrder`: Exposes CRUD operations for the **SalesOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrders
    * const salesOrders = await prisma.salesOrder.findMany()
    * ```
    */
  get salesOrder(): Prisma.SalesOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesOrderLine`: Exposes CRUD operations for the **SalesOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrderLines
    * const salesOrderLines = await prisma.salesOrderLine.findMany()
    * ```
    */
  get salesOrderLine(): Prisma.SalesOrderLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorBill`: Exposes CRUD operations for the **VendorBill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorBills
    * const vendorBills = await prisma.vendorBill.findMany()
    * ```
    */
  get vendorBill(): Prisma.VendorBillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorBillLine`: Exposes CRUD operations for the **VendorBillLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorBillLines
    * const vendorBillLines = await prisma.vendorBillLine.findMany()
    * ```
    */
  get vendorBillLine(): Prisma.VendorBillLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerInvoice`: Exposes CRUD operations for the **CustomerInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerInvoices
    * const customerInvoices = await prisma.customerInvoice.findMany()
    * ```
    */
  get customerInvoice(): Prisma.CustomerInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerInvoiceLine`: Exposes CRUD operations for the **CustomerInvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerInvoiceLines
    * const customerInvoiceLines = await prisma.customerInvoiceLine.findMany()
    * ```
    */
  get customerInvoiceLine(): Prisma.CustomerInvoiceLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentAllocation`: Exposes CRUD operations for the **PaymentAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAllocations
    * const paymentAllocations = await prisma.paymentAllocation.findMany()
    * ```
    */
  get paymentAllocation(): Prisma.PaymentAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentFile`: Exposes CRUD operations for the **DocumentFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentFiles
    * const documentFiles = await prisma.documentFile.findMany()
    * ```
    */
  get documentFile(): Prisma.DocumentFileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    Contact: 'Contact',
    ProductCategory: 'ProductCategory',
    Product: 'Product',
    AnalyticAccount: 'AnalyticAccount',
    GLAccount: 'GLAccount',
    JournalEntry: 'JournalEntry',
    JournalLine: 'JournalLine',
    Budget: 'Budget',
    BudgetRevision: 'BudgetRevision',
    BudgetLine: 'BudgetLine',
    AutoAnalyticModel: 'AutoAnalyticModel',
    AutoAnalyticRule: 'AutoAnalyticRule',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderLine: 'PurchaseOrderLine',
    SalesOrder: 'SalesOrder',
    SalesOrderLine: 'SalesOrderLine',
    VendorBill: 'VendorBill',
    VendorBillLine: 'VendorBillLine',
    CustomerInvoice: 'CustomerInvoice',
    CustomerInvoiceLine: 'CustomerInvoiceLine',
    Payment: 'Payment',
    PaymentAllocation: 'PaymentAllocation',
    DocumentFile: 'DocumentFile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "contact" | "productCategory" | "product" | "analyticAccount" | "gLAccount" | "journalEntry" | "journalLine" | "budget" | "budgetRevision" | "budgetLine" | "autoAnalyticModel" | "autoAnalyticRule" | "purchaseOrder" | "purchaseOrderLine" | "salesOrder" | "salesOrderLine" | "vendorBill" | "vendorBillLine" | "customerInvoice" | "customerInvoiceLine" | "payment" | "paymentAllocation" | "documentFile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      AnalyticAccount: {
        payload: Prisma.$AnalyticAccountPayload<ExtArgs>
        fields: Prisma.AnalyticAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>
          }
          findFirst: {
            args: Prisma.AnalyticAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>
          }
          findMany: {
            args: Prisma.AnalyticAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>[]
          }
          create: {
            args: Prisma.AnalyticAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>
          }
          createMany: {
            args: Prisma.AnalyticAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>[]
          }
          delete: {
            args: Prisma.AnalyticAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>
          }
          update: {
            args: Prisma.AnalyticAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticAccountPayload>
          }
          aggregate: {
            args: Prisma.AnalyticAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticAccount>
          }
          groupBy: {
            args: Prisma.AnalyticAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticAccountCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticAccountCountAggregateOutputType> | number
          }
        }
      }
      GLAccount: {
        payload: Prisma.$GLAccountPayload<ExtArgs>
        fields: Prisma.GLAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GLAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GLAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>
          }
          findFirst: {
            args: Prisma.GLAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GLAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>
          }
          findMany: {
            args: Prisma.GLAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>[]
          }
          create: {
            args: Prisma.GLAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>
          }
          createMany: {
            args: Prisma.GLAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GLAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>[]
          }
          delete: {
            args: Prisma.GLAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>
          }
          update: {
            args: Prisma.GLAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>
          }
          deleteMany: {
            args: Prisma.GLAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GLAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GLAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>[]
          }
          upsert: {
            args: Prisma.GLAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GLAccountPayload>
          }
          aggregate: {
            args: Prisma.GLAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGLAccount>
          }
          groupBy: {
            args: Prisma.GLAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<GLAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.GLAccountCountArgs<ExtArgs>
            result: $Utils.Optional<GLAccountCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      JournalLine: {
        payload: Prisma.$JournalLinePayload<ExtArgs>
        fields: Prisma.JournalLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findFirst: {
            args: Prisma.JournalLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findMany: {
            args: Prisma.JournalLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          create: {
            args: Prisma.JournalLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          createMany: {
            args: Prisma.JournalLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          delete: {
            args: Prisma.JournalLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          update: {
            args: Prisma.JournalLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          deleteMany: {
            args: Prisma.JournalLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          upsert: {
            args: Prisma.JournalLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          aggregate: {
            args: Prisma.JournalLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalLine>
          }
          groupBy: {
            args: Prisma.JournalLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalLineCountArgs<ExtArgs>
            result: $Utils.Optional<JournalLineCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      BudgetRevision: {
        payload: Prisma.$BudgetRevisionPayload<ExtArgs>
        fields: Prisma.BudgetRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetRevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetRevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>
          }
          findFirst: {
            args: Prisma.BudgetRevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetRevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>
          }
          findMany: {
            args: Prisma.BudgetRevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>[]
          }
          create: {
            args: Prisma.BudgetRevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>
          }
          createMany: {
            args: Prisma.BudgetRevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetRevisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>[]
          }
          delete: {
            args: Prisma.BudgetRevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>
          }
          update: {
            args: Prisma.BudgetRevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>
          }
          deleteMany: {
            args: Prisma.BudgetRevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetRevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetRevisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>[]
          }
          upsert: {
            args: Prisma.BudgetRevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRevisionPayload>
          }
          aggregate: {
            args: Prisma.BudgetRevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetRevision>
          }
          groupBy: {
            args: Prisma.BudgetRevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetRevisionCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetRevisionCountAggregateOutputType> | number
          }
        }
      }
      BudgetLine: {
        payload: Prisma.$BudgetLinePayload<ExtArgs>
        fields: Prisma.BudgetLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          findFirst: {
            args: Prisma.BudgetLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          findMany: {
            args: Prisma.BudgetLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>[]
          }
          create: {
            args: Prisma.BudgetLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          createMany: {
            args: Prisma.BudgetLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>[]
          }
          delete: {
            args: Prisma.BudgetLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          update: {
            args: Prisma.BudgetLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          deleteMany: {
            args: Prisma.BudgetLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>[]
          }
          upsert: {
            args: Prisma.BudgetLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          aggregate: {
            args: Prisma.BudgetLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetLine>
          }
          groupBy: {
            args: Prisma.BudgetLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetLineCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetLineCountAggregateOutputType> | number
          }
        }
      }
      AutoAnalyticModel: {
        payload: Prisma.$AutoAnalyticModelPayload<ExtArgs>
        fields: Prisma.AutoAnalyticModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoAnalyticModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoAnalyticModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>
          }
          findFirst: {
            args: Prisma.AutoAnalyticModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoAnalyticModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>
          }
          findMany: {
            args: Prisma.AutoAnalyticModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>[]
          }
          create: {
            args: Prisma.AutoAnalyticModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>
          }
          createMany: {
            args: Prisma.AutoAnalyticModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutoAnalyticModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>[]
          }
          delete: {
            args: Prisma.AutoAnalyticModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>
          }
          update: {
            args: Prisma.AutoAnalyticModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>
          }
          deleteMany: {
            args: Prisma.AutoAnalyticModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoAnalyticModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutoAnalyticModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>[]
          }
          upsert: {
            args: Prisma.AutoAnalyticModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticModelPayload>
          }
          aggregate: {
            args: Prisma.AutoAnalyticModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoAnalyticModel>
          }
          groupBy: {
            args: Prisma.AutoAnalyticModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoAnalyticModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoAnalyticModelCountArgs<ExtArgs>
            result: $Utils.Optional<AutoAnalyticModelCountAggregateOutputType> | number
          }
        }
      }
      AutoAnalyticRule: {
        payload: Prisma.$AutoAnalyticRulePayload<ExtArgs>
        fields: Prisma.AutoAnalyticRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoAnalyticRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoAnalyticRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>
          }
          findFirst: {
            args: Prisma.AutoAnalyticRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoAnalyticRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>
          }
          findMany: {
            args: Prisma.AutoAnalyticRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>[]
          }
          create: {
            args: Prisma.AutoAnalyticRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>
          }
          createMany: {
            args: Prisma.AutoAnalyticRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutoAnalyticRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>[]
          }
          delete: {
            args: Prisma.AutoAnalyticRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>
          }
          update: {
            args: Prisma.AutoAnalyticRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>
          }
          deleteMany: {
            args: Prisma.AutoAnalyticRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoAnalyticRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutoAnalyticRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>[]
          }
          upsert: {
            args: Prisma.AutoAnalyticRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoAnalyticRulePayload>
          }
          aggregate: {
            args: Prisma.AutoAnalyticRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoAnalyticRule>
          }
          groupBy: {
            args: Prisma.AutoAnalyticRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoAnalyticRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoAnalyticRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AutoAnalyticRuleCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderLine: {
        payload: Prisma.$PurchaseOrderLinePayload<ExtArgs>
        fields: Prisma.PurchaseOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          update: {
            args: Prisma.PurchaseOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderLine>
          }
          groupBy: {
            args: Prisma.PurchaseOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineCountAggregateOutputType> | number
          }
        }
      }
      SalesOrder: {
        payload: Prisma.$SalesOrderPayload<ExtArgs>
        fields: Prisma.SalesOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findFirst: {
            args: Prisma.SalesOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findMany: {
            args: Prisma.SalesOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          create: {
            args: Prisma.SalesOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          createMany: {
            args: Prisma.SalesOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          delete: {
            args: Prisma.SalesOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          update: {
            args: Prisma.SalesOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          deleteMany: {
            args: Prisma.SalesOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          upsert: {
            args: Prisma.SalesOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          aggregate: {
            args: Prisma.SalesOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOrder>
          }
          groupBy: {
            args: Prisma.SalesOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOrderCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderCountAggregateOutputType> | number
          }
        }
      }
      SalesOrderLine: {
        payload: Prisma.$SalesOrderLinePayload<ExtArgs>
        fields: Prisma.SalesOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          findFirst: {
            args: Prisma.SalesOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          findMany: {
            args: Prisma.SalesOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          create: {
            args: Prisma.SalesOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          createMany: {
            args: Prisma.SalesOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          delete: {
            args: Prisma.SalesOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          update: {
            args: Prisma.SalesOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.SalesOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesOrderLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          upsert: {
            args: Prisma.SalesOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          aggregate: {
            args: Prisma.SalesOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOrderLine>
          }
          groupBy: {
            args: Prisma.SalesOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderLineCountAggregateOutputType> | number
          }
        }
      }
      VendorBill: {
        payload: Prisma.$VendorBillPayload<ExtArgs>
        fields: Prisma.VendorBillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorBillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorBillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          findFirst: {
            args: Prisma.VendorBillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorBillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          findMany: {
            args: Prisma.VendorBillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>[]
          }
          create: {
            args: Prisma.VendorBillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          createMany: {
            args: Prisma.VendorBillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorBillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>[]
          }
          delete: {
            args: Prisma.VendorBillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          update: {
            args: Prisma.VendorBillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          deleteMany: {
            args: Prisma.VendorBillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorBillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorBillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>[]
          }
          upsert: {
            args: Prisma.VendorBillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          aggregate: {
            args: Prisma.VendorBillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorBill>
          }
          groupBy: {
            args: Prisma.VendorBillGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorBillGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorBillCountArgs<ExtArgs>
            result: $Utils.Optional<VendorBillCountAggregateOutputType> | number
          }
        }
      }
      VendorBillLine: {
        payload: Prisma.$VendorBillLinePayload<ExtArgs>
        fields: Prisma.VendorBillLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorBillLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorBillLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>
          }
          findFirst: {
            args: Prisma.VendorBillLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorBillLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>
          }
          findMany: {
            args: Prisma.VendorBillLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>[]
          }
          create: {
            args: Prisma.VendorBillLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>
          }
          createMany: {
            args: Prisma.VendorBillLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorBillLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>[]
          }
          delete: {
            args: Prisma.VendorBillLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>
          }
          update: {
            args: Prisma.VendorBillLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>
          }
          deleteMany: {
            args: Prisma.VendorBillLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorBillLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorBillLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>[]
          }
          upsert: {
            args: Prisma.VendorBillLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillLinePayload>
          }
          aggregate: {
            args: Prisma.VendorBillLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorBillLine>
          }
          groupBy: {
            args: Prisma.VendorBillLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorBillLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorBillLineCountArgs<ExtArgs>
            result: $Utils.Optional<VendorBillLineCountAggregateOutputType> | number
          }
        }
      }
      CustomerInvoice: {
        payload: Prisma.$CustomerInvoicePayload<ExtArgs>
        fields: Prisma.CustomerInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          findFirst: {
            args: Prisma.CustomerInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          findMany: {
            args: Prisma.CustomerInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>[]
          }
          create: {
            args: Prisma.CustomerInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          createMany: {
            args: Prisma.CustomerInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>[]
          }
          delete: {
            args: Prisma.CustomerInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          update: {
            args: Prisma.CustomerInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          deleteMany: {
            args: Prisma.CustomerInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>[]
          }
          upsert: {
            args: Prisma.CustomerInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          aggregate: {
            args: Prisma.CustomerInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerInvoice>
          }
          groupBy: {
            args: Prisma.CustomerInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceCountAggregateOutputType> | number
          }
        }
      }
      CustomerInvoiceLine: {
        payload: Prisma.$CustomerInvoiceLinePayload<ExtArgs>
        fields: Prisma.CustomerInvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerInvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerInvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.CustomerInvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerInvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>
          }
          findMany: {
            args: Prisma.CustomerInvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>[]
          }
          create: {
            args: Prisma.CustomerInvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>
          }
          createMany: {
            args: Prisma.CustomerInvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerInvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.CustomerInvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>
          }
          update: {
            args: Prisma.CustomerInvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.CustomerInvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerInvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerInvoiceLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>[]
          }
          upsert: {
            args: Prisma.CustomerInvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.CustomerInvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerInvoiceLine>
          }
          groupBy: {
            args: Prisma.CustomerInvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerInvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentAllocation: {
        payload: Prisma.$PaymentAllocationPayload<ExtArgs>
        fields: Prisma.PaymentAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          findFirst: {
            args: Prisma.PaymentAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          findMany: {
            args: Prisma.PaymentAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>[]
          }
          create: {
            args: Prisma.PaymentAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          createMany: {
            args: Prisma.PaymentAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>[]
          }
          delete: {
            args: Prisma.PaymentAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          update: {
            args: Prisma.PaymentAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>[]
          }
          upsert: {
            args: Prisma.PaymentAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          aggregate: {
            args: Prisma.PaymentAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAllocation>
          }
          groupBy: {
            args: Prisma.PaymentAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAllocationCountAggregateOutputType> | number
          }
        }
      }
      DocumentFile: {
        payload: Prisma.$DocumentFilePayload<ExtArgs>
        fields: Prisma.DocumentFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>
          }
          findFirst: {
            args: Prisma.DocumentFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>
          }
          findMany: {
            args: Prisma.DocumentFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>[]
          }
          create: {
            args: Prisma.DocumentFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>
          }
          createMany: {
            args: Prisma.DocumentFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>[]
          }
          delete: {
            args: Prisma.DocumentFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>
          }
          update: {
            args: Prisma.DocumentFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>
          }
          deleteMany: {
            args: Prisma.DocumentFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>[]
          }
          upsert: {
            args: Prisma.DocumentFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentFilePayload>
          }
          aggregate: {
            args: Prisma.DocumentFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentFile>
          }
          groupBy: {
            args: Prisma.DocumentFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentFileCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentFileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    contact?: ContactOmit
    productCategory?: ProductCategoryOmit
    product?: ProductOmit
    analyticAccount?: AnalyticAccountOmit
    gLAccount?: GLAccountOmit
    journalEntry?: JournalEntryOmit
    journalLine?: JournalLineOmit
    budget?: BudgetOmit
    budgetRevision?: BudgetRevisionOmit
    budgetLine?: BudgetLineOmit
    autoAnalyticModel?: AutoAnalyticModelOmit
    autoAnalyticRule?: AutoAnalyticRuleOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseOrderLine?: PurchaseOrderLineOmit
    salesOrder?: SalesOrderOmit
    salesOrderLine?: SalesOrderLineOmit
    vendorBill?: VendorBillOmit
    vendorBillLine?: VendorBillLineOmit
    customerInvoice?: CustomerInvoiceOmit
    customerInvoiceLine?: CustomerInvoiceLineOmit
    payment?: PaymentOmit
    paymentAllocation?: PaymentAllocationOmit
    documentFile?: DocumentFileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    contacts: number
    productCategories: number
    products: number
    analyticAccounts: number
    glAccounts: number
    journalEntries: number
    budgets: number
    autoAnalyticModels: number
    purchaseOrders: number
    salesOrders: number
    vendorBills: number
    customerInvoices: number
    payments: number
    documentFiles: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | CompanyCountOutputTypeCountContactsArgs
    productCategories?: boolean | CompanyCountOutputTypeCountProductCategoriesArgs
    products?: boolean | CompanyCountOutputTypeCountProductsArgs
    analyticAccounts?: boolean | CompanyCountOutputTypeCountAnalyticAccountsArgs
    glAccounts?: boolean | CompanyCountOutputTypeCountGlAccountsArgs
    journalEntries?: boolean | CompanyCountOutputTypeCountJournalEntriesArgs
    budgets?: boolean | CompanyCountOutputTypeCountBudgetsArgs
    autoAnalyticModels?: boolean | CompanyCountOutputTypeCountAutoAnalyticModelsArgs
    purchaseOrders?: boolean | CompanyCountOutputTypeCountPurchaseOrdersArgs
    salesOrders?: boolean | CompanyCountOutputTypeCountSalesOrdersArgs
    vendorBills?: boolean | CompanyCountOutputTypeCountVendorBillsArgs
    customerInvoices?: boolean | CompanyCountOutputTypeCountCustomerInvoicesArgs
    payments?: boolean | CompanyCountOutputTypeCountPaymentsArgs
    documentFiles?: boolean | CompanyCountOutputTypeCountDocumentFilesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAnalyticAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticAccountWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountGlAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GLAccountWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAutoAnalyticModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticModelWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSalesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVendorBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCustomerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDocumentFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentFileWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    vendorPurchaseOrders: number
    customerSalesOrders: number
    vendorBills: number
    customerInvoices: number
    payments: number
    journalLines: number
    autoAnalyticRules: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorPurchaseOrders?: boolean | ContactCountOutputTypeCountVendorPurchaseOrdersArgs
    customerSalesOrders?: boolean | ContactCountOutputTypeCountCustomerSalesOrdersArgs
    vendorBills?: boolean | ContactCountOutputTypeCountVendorBillsArgs
    customerInvoices?: boolean | ContactCountOutputTypeCountCustomerInvoicesArgs
    payments?: boolean | ContactCountOutputTypeCountPaymentsArgs
    journalLines?: boolean | ContactCountOutputTypeCountJournalLinesArgs
    autoAnalyticRules?: boolean | ContactCountOutputTypeCountAutoAnalyticRulesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountVendorPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCustomerSalesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountVendorBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCustomerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountAutoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticRuleWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    children: number
    products: number
    autoAnalyticRules: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ProductCategoryCountOutputTypeCountChildrenArgs
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
    autoAnalyticRules?: boolean | ProductCategoryCountOutputTypeCountAutoAnalyticRulesArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountAutoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticRuleWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    poLines: number
    soLines: number
    billLines: number
    invLines: number
    journalLines: number
    autoAnalyticRules: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poLines?: boolean | ProductCountOutputTypeCountPoLinesArgs
    soLines?: boolean | ProductCountOutputTypeCountSoLinesArgs
    billLines?: boolean | ProductCountOutputTypeCountBillLinesArgs
    invLines?: boolean | ProductCountOutputTypeCountInvLinesArgs
    journalLines?: boolean | ProductCountOutputTypeCountJournalLinesArgs
    autoAnalyticRules?: boolean | ProductCountOutputTypeCountAutoAnalyticRulesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPoLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSoLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBillLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInvLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAutoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticRuleWhereInput
  }


  /**
   * Count Type AnalyticAccountCountOutputType
   */

  export type AnalyticAccountCountOutputType = {
    children: number
    budgetLines: number
    journalLines: number
    poLines: number
    soLines: number
    billLines: number
    invLines: number
    autoAnalyticRules: number
  }

  export type AnalyticAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | AnalyticAccountCountOutputTypeCountChildrenArgs
    budgetLines?: boolean | AnalyticAccountCountOutputTypeCountBudgetLinesArgs
    journalLines?: boolean | AnalyticAccountCountOutputTypeCountJournalLinesArgs
    poLines?: boolean | AnalyticAccountCountOutputTypeCountPoLinesArgs
    soLines?: boolean | AnalyticAccountCountOutputTypeCountSoLinesArgs
    billLines?: boolean | AnalyticAccountCountOutputTypeCountBillLinesArgs
    invLines?: boolean | AnalyticAccountCountOutputTypeCountInvLinesArgs
    autoAnalyticRules?: boolean | AnalyticAccountCountOutputTypeCountAutoAnalyticRulesArgs
  }

  // Custom InputTypes
  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccountCountOutputType
     */
    select?: AnalyticAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticAccountWhereInput
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountBudgetLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineWhereInput
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountPoLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountSoLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountBillLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillLineWhereInput
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountInvLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceLineWhereInput
  }

  /**
   * AnalyticAccountCountOutputType without action
   */
  export type AnalyticAccountCountOutputTypeCountAutoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticRuleWhereInput
  }


  /**
   * Count Type GLAccountCountOutputType
   */

  export type GLAccountCountOutputType = {
    journalLines: number
    budgetLines: number
    billLines: number
    invLines: number
  }

  export type GLAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalLines?: boolean | GLAccountCountOutputTypeCountJournalLinesArgs
    budgetLines?: boolean | GLAccountCountOutputTypeCountBudgetLinesArgs
    billLines?: boolean | GLAccountCountOutputTypeCountBillLinesArgs
    invLines?: boolean | GLAccountCountOutputTypeCountInvLinesArgs
  }

  // Custom InputTypes
  /**
   * GLAccountCountOutputType without action
   */
  export type GLAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccountCountOutputType
     */
    select?: GLAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GLAccountCountOutputType without action
   */
  export type GLAccountCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }

  /**
   * GLAccountCountOutputType without action
   */
  export type GLAccountCountOutputTypeCountBudgetLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineWhereInput
  }

  /**
   * GLAccountCountOutputType without action
   */
  export type GLAccountCountOutputTypeCountBillLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillLineWhereInput
  }

  /**
   * GLAccountCountOutputType without action
   */
  export type GLAccountCountOutputTypeCountInvLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceLineWhereInput
  }


  /**
   * Count Type JournalEntryCountOutputType
   */

  export type JournalEntryCountOutputType = {
    lines: number
  }

  export type JournalEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | JournalEntryCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntryCountOutputType
     */
    select?: JournalEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    revisions: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revisions?: boolean | BudgetCountOutputTypeCountRevisionsArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetRevisionWhereInput
  }


  /**
   * Count Type BudgetRevisionCountOutputType
   */

  export type BudgetRevisionCountOutputType = {
    lines: number
  }

  export type BudgetRevisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | BudgetRevisionCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * BudgetRevisionCountOutputType without action
   */
  export type BudgetRevisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevisionCountOutputType
     */
    select?: BudgetRevisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetRevisionCountOutputType without action
   */
  export type BudgetRevisionCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineWhereInput
  }


  /**
   * Count Type AutoAnalyticModelCountOutputType
   */

  export type AutoAnalyticModelCountOutputType = {
    rules: number
  }

  export type AutoAnalyticModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | AutoAnalyticModelCountOutputTypeCountRulesArgs
  }

  // Custom InputTypes
  /**
   * AutoAnalyticModelCountOutputType without action
   */
  export type AutoAnalyticModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModelCountOutputType
     */
    select?: AutoAnalyticModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutoAnalyticModelCountOutputType without action
   */
  export type AutoAnalyticModelCountOutputTypeCountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticRuleWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    lines: number
    bills: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | PurchaseOrderCountOutputTypeCountLinesArgs
    bills?: boolean | PurchaseOrderCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillWhereInput
  }


  /**
   * Count Type SalesOrderCountOutputType
   */

  export type SalesOrderCountOutputType = {
    lines: number
    invoices: number
  }

  export type SalesOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | SalesOrderCountOutputTypeCountLinesArgs
    invoices?: boolean | SalesOrderCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderCountOutputType
     */
    select?: SalesOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceWhereInput
  }


  /**
   * Count Type VendorBillCountOutputType
   */

  export type VendorBillCountOutputType = {
    lines: number
  }

  export type VendorBillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | VendorBillCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * VendorBillCountOutputType without action
   */
  export type VendorBillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillCountOutputType
     */
    select?: VendorBillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorBillCountOutputType without action
   */
  export type VendorBillCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillLineWhereInput
  }


  /**
   * Count Type CustomerInvoiceCountOutputType
   */

  export type CustomerInvoiceCountOutputType = {
    lines: number
  }

  export type CustomerInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | CustomerInvoiceCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * CustomerInvoiceCountOutputType without action
   */
  export type CustomerInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceCountOutputType
     */
    select?: CustomerInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerInvoiceCountOutputType without action
   */
  export type CustomerInvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceLineWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    allocations: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | PaymentCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAllocationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    productCategories?: boolean | Company$productCategoriesArgs<ExtArgs>
    products?: boolean | Company$productsArgs<ExtArgs>
    analyticAccounts?: boolean | Company$analyticAccountsArgs<ExtArgs>
    glAccounts?: boolean | Company$glAccountsArgs<ExtArgs>
    journalEntries?: boolean | Company$journalEntriesArgs<ExtArgs>
    budgets?: boolean | Company$budgetsArgs<ExtArgs>
    autoAnalyticModels?: boolean | Company$autoAnalyticModelsArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    salesOrders?: boolean | Company$salesOrdersArgs<ExtArgs>
    vendorBills?: boolean | Company$vendorBillsArgs<ExtArgs>
    customerInvoices?: boolean | Company$customerInvoicesArgs<ExtArgs>
    payments?: boolean | Company$paymentsArgs<ExtArgs>
    documentFiles?: boolean | Company$documentFilesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    productCategories?: boolean | Company$productCategoriesArgs<ExtArgs>
    products?: boolean | Company$productsArgs<ExtArgs>
    analyticAccounts?: boolean | Company$analyticAccountsArgs<ExtArgs>
    glAccounts?: boolean | Company$glAccountsArgs<ExtArgs>
    journalEntries?: boolean | Company$journalEntriesArgs<ExtArgs>
    budgets?: boolean | Company$budgetsArgs<ExtArgs>
    autoAnalyticModels?: boolean | Company$autoAnalyticModelsArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    salesOrders?: boolean | Company$salesOrdersArgs<ExtArgs>
    vendorBills?: boolean | Company$vendorBillsArgs<ExtArgs>
    customerInvoices?: boolean | Company$customerInvoicesArgs<ExtArgs>
    payments?: boolean | Company$paymentsArgs<ExtArgs>
    documentFiles?: boolean | Company$documentFilesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      analyticAccounts: Prisma.$AnalyticAccountPayload<ExtArgs>[]
      glAccounts: Prisma.$GLAccountPayload<ExtArgs>[]
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      autoAnalyticModels: Prisma.$AutoAnalyticModelPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      salesOrders: Prisma.$SalesOrderPayload<ExtArgs>[]
      vendorBills: Prisma.$VendorBillPayload<ExtArgs>[]
      customerInvoices: Prisma.$CustomerInvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      documentFiles: Prisma.$DocumentFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends Company$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Company$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCategories<T extends Company$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Company$productsArgs<ExtArgs> = {}>(args?: Subset<T, Company$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analyticAccounts<T extends Company$analyticAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Company$analyticAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    glAccounts<T extends Company$glAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Company$glAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalEntries<T extends Company$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgets<T extends Company$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Company$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    autoAnalyticModels<T extends Company$autoAnalyticModelsArgs<ExtArgs> = {}>(args?: Subset<T, Company$autoAnalyticModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Company$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Company$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesOrders<T extends Company$salesOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Company$salesOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorBills<T extends Company$vendorBillsArgs<ExtArgs> = {}>(args?: Subset<T, Company$vendorBillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerInvoices<T extends Company$customerInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$customerInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Company$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentFiles<T extends Company$documentFilesArgs<ExtArgs> = {}>(args?: Subset<T, Company$documentFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.contacts
   */
  export type Company$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Company.productCategories
   */
  export type Company$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Company.products
   */
  export type Company$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Company.analyticAccounts
   */
  export type Company$analyticAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
    orderBy?: AnalyticAccountOrderByWithRelationInput | AnalyticAccountOrderByWithRelationInput[]
    cursor?: AnalyticAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticAccountScalarFieldEnum | AnalyticAccountScalarFieldEnum[]
  }

  /**
   * Company.glAccounts
   */
  export type Company$glAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    where?: GLAccountWhereInput
    orderBy?: GLAccountOrderByWithRelationInput | GLAccountOrderByWithRelationInput[]
    cursor?: GLAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GLAccountScalarFieldEnum | GLAccountScalarFieldEnum[]
  }

  /**
   * Company.journalEntries
   */
  export type Company$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * Company.budgets
   */
  export type Company$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Company.autoAnalyticModels
   */
  export type Company$autoAnalyticModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    where?: AutoAnalyticModelWhereInput
    orderBy?: AutoAnalyticModelOrderByWithRelationInput | AutoAnalyticModelOrderByWithRelationInput[]
    cursor?: AutoAnalyticModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoAnalyticModelScalarFieldEnum | AutoAnalyticModelScalarFieldEnum[]
  }

  /**
   * Company.purchaseOrders
   */
  export type Company$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Company.salesOrders
   */
  export type Company$salesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * Company.vendorBills
   */
  export type Company$vendorBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    where?: VendorBillWhereInput
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    cursor?: VendorBillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * Company.customerInvoices
   */
  export type Company$customerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    where?: CustomerInvoiceWhereInput
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    cursor?: CustomerInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * Company.payments
   */
  export type Company$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Company.documentFiles
   */
  export type Company$documentFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    where?: DocumentFileWhereInput
    orderBy?: DocumentFileOrderByWithRelationInput | DocumentFileOrderByWithRelationInput[]
    cursor?: DocumentFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentFileScalarFieldEnum | DocumentFileScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    contactType: $Enums.ContactType | null
    displayName: string | null
    email: string | null
    phone: string | null
    gstin: string | null
    isPortalUser: boolean | null
    portalUserExternalId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    contactType: $Enums.ContactType | null
    displayName: string | null
    email: string | null
    phone: string | null
    gstin: string | null
    isPortalUser: boolean | null
    portalUserExternalId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    companyId: number
    contactType: number
    displayName: number
    email: number
    phone: number
    gstin: number
    billingAddress: number
    shippingAddress: number
    isPortalUser: number
    portalUserExternalId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    companyId?: true
    contactType?: true
    displayName?: true
    email?: true
    phone?: true
    gstin?: true
    isPortalUser?: true
    portalUserExternalId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    companyId?: true
    contactType?: true
    displayName?: true
    email?: true
    phone?: true
    gstin?: true
    isPortalUser?: true
    portalUserExternalId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    companyId?: true
    contactType?: true
    displayName?: true
    email?: true
    phone?: true
    gstin?: true
    billingAddress?: true
    shippingAddress?: true
    isPortalUser?: true
    portalUserExternalId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email: string | null
    phone: string | null
    gstin: string | null
    billingAddress: JsonValue | null
    shippingAddress: JsonValue | null
    isPortalUser: boolean
    portalUserExternalId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    contactType?: boolean
    displayName?: boolean
    email?: boolean
    phone?: boolean
    gstin?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    isPortalUser?: boolean
    portalUserExternalId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendorPurchaseOrders?: boolean | Contact$vendorPurchaseOrdersArgs<ExtArgs>
    customerSalesOrders?: boolean | Contact$customerSalesOrdersArgs<ExtArgs>
    vendorBills?: boolean | Contact$vendorBillsArgs<ExtArgs>
    customerInvoices?: boolean | Contact$customerInvoicesArgs<ExtArgs>
    payments?: boolean | Contact$paymentsArgs<ExtArgs>
    journalLines?: boolean | Contact$journalLinesArgs<ExtArgs>
    autoAnalyticRules?: boolean | Contact$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    contactType?: boolean
    displayName?: boolean
    email?: boolean
    phone?: boolean
    gstin?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    isPortalUser?: boolean
    portalUserExternalId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    contactType?: boolean
    displayName?: boolean
    email?: boolean
    phone?: boolean
    gstin?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    isPortalUser?: boolean
    portalUserExternalId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    companyId?: boolean
    contactType?: boolean
    displayName?: boolean
    email?: boolean
    phone?: boolean
    gstin?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    isPortalUser?: boolean
    portalUserExternalId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "contactType" | "displayName" | "email" | "phone" | "gstin" | "billingAddress" | "shippingAddress" | "isPortalUser" | "portalUserExternalId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendorPurchaseOrders?: boolean | Contact$vendorPurchaseOrdersArgs<ExtArgs>
    customerSalesOrders?: boolean | Contact$customerSalesOrdersArgs<ExtArgs>
    vendorBills?: boolean | Contact$vendorBillsArgs<ExtArgs>
    customerInvoices?: boolean | Contact$customerInvoicesArgs<ExtArgs>
    payments?: boolean | Contact$paymentsArgs<ExtArgs>
    journalLines?: boolean | Contact$journalLinesArgs<ExtArgs>
    autoAnalyticRules?: boolean | Contact$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      vendorPurchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      customerSalesOrders: Prisma.$SalesOrderPayload<ExtArgs>[]
      vendorBills: Prisma.$VendorBillPayload<ExtArgs>[]
      customerInvoices: Prisma.$CustomerInvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
      autoAnalyticRules: Prisma.$AutoAnalyticRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      contactType: $Enums.ContactType
      displayName: string
      email: string | null
      phone: string | null
      gstin: string | null
      billingAddress: Prisma.JsonValue | null
      shippingAddress: Prisma.JsonValue | null
      isPortalUser: boolean
      portalUserExternalId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendorPurchaseOrders<T extends Contact$vendorPurchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Contact$vendorPurchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerSalesOrders<T extends Contact$customerSalesOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Contact$customerSalesOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorBills<T extends Contact$vendorBillsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$vendorBillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerInvoices<T extends Contact$customerInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$customerInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Contact$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalLines<T extends Contact$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    autoAnalyticRules<T extends Contact$autoAnalyticRulesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$autoAnalyticRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly companyId: FieldRef<"Contact", 'String'>
    readonly contactType: FieldRef<"Contact", 'ContactType'>
    readonly displayName: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly gstin: FieldRef<"Contact", 'String'>
    readonly billingAddress: FieldRef<"Contact", 'Json'>
    readonly shippingAddress: FieldRef<"Contact", 'Json'>
    readonly isPortalUser: FieldRef<"Contact", 'Boolean'>
    readonly portalUserExternalId: FieldRef<"Contact", 'String'>
    readonly isActive: FieldRef<"Contact", 'Boolean'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.vendorPurchaseOrders
   */
  export type Contact$vendorPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Contact.customerSalesOrders
   */
  export type Contact$customerSalesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * Contact.vendorBills
   */
  export type Contact$vendorBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    where?: VendorBillWhereInput
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    cursor?: VendorBillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * Contact.customerInvoices
   */
  export type Contact$customerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    where?: CustomerInvoiceWhereInput
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    cursor?: CustomerInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * Contact.payments
   */
  export type Contact$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Contact.journalLines
   */
  export type Contact$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * Contact.autoAnalyticRules
   */
  export type Contact$autoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    where?: AutoAnalyticRuleWhereInput
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    cursor?: AutoAnalyticRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    parentId: string | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    parentId: string | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    parentId: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    parentId?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    parentId?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    parentId?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    companyId: string
    name: string
    parentId: string | null
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    parentId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    autoAnalyticRules?: boolean | ProductCategory$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    parentId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    parentId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    parentId?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "parentId", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    autoAnalyticRules?: boolean | ProductCategory$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      parent: Prisma.$ProductCategoryPayload<ExtArgs> | null
      children: Prisma.$ProductCategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      autoAnalyticRules: Prisma.$AutoAnalyticRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      parentId: string | null
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ProductCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$parentArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends ProductCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    autoAnalyticRules<T extends ProductCategory$autoAnalyticRulesArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$autoAnalyticRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly companyId: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly parentId: FieldRef<"ProductCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.parent
   */
  export type ProductCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.children
   */
  export type ProductCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory.autoAnalyticRules
   */
  export type ProductCategory$autoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    where?: AutoAnalyticRuleWhereInput
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    cursor?: AutoAnalyticRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    salePrice: Decimal | null
    costPrice: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    salePrice: Decimal | null
    costPrice: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    sku: string | null
    name: string | null
    categoryId: string | null
    uom: string | null
    salePrice: Decimal | null
    costPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    sku: string | null
    name: string | null
    categoryId: string | null
    uom: string | null
    salePrice: Decimal | null
    costPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    companyId: number
    sku: number
    name: number
    categoryId: number
    uom: number
    salePrice: number
    costPrice: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    salePrice?: true
    costPrice?: true
  }

  export type ProductSumAggregateInputType = {
    salePrice?: true
    costPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    companyId?: true
    sku?: true
    name?: true
    categoryId?: true
    uom?: true
    salePrice?: true
    costPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    companyId?: true
    sku?: true
    name?: true
    categoryId?: true
    uom?: true
    salePrice?: true
    costPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    companyId?: true
    sku?: true
    name?: true
    categoryId?: true
    uom?: true
    salePrice?: true
    costPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    companyId: string
    sku: string | null
    name: string
    categoryId: string | null
    uom: string
    salePrice: Decimal
    costPrice: Decimal
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    sku?: boolean
    name?: boolean
    categoryId?: boolean
    uom?: boolean
    salePrice?: boolean
    costPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    poLines?: boolean | Product$poLinesArgs<ExtArgs>
    soLines?: boolean | Product$soLinesArgs<ExtArgs>
    billLines?: boolean | Product$billLinesArgs<ExtArgs>
    invLines?: boolean | Product$invLinesArgs<ExtArgs>
    journalLines?: boolean | Product$journalLinesArgs<ExtArgs>
    autoAnalyticRules?: boolean | Product$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    sku?: boolean
    name?: boolean
    categoryId?: boolean
    uom?: boolean
    salePrice?: boolean
    costPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    sku?: boolean
    name?: boolean
    categoryId?: boolean
    uom?: boolean
    salePrice?: boolean
    costPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    companyId?: boolean
    sku?: boolean
    name?: boolean
    categoryId?: boolean
    uom?: boolean
    salePrice?: boolean
    costPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "sku" | "name" | "categoryId" | "uom" | "salePrice" | "costPrice" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    poLines?: boolean | Product$poLinesArgs<ExtArgs>
    soLines?: boolean | Product$soLinesArgs<ExtArgs>
    billLines?: boolean | Product$billLinesArgs<ExtArgs>
    invLines?: boolean | Product$invLinesArgs<ExtArgs>
    journalLines?: boolean | Product$journalLinesArgs<ExtArgs>
    autoAnalyticRules?: boolean | Product$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
      poLines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      soLines: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      billLines: Prisma.$VendorBillLinePayload<ExtArgs>[]
      invLines: Prisma.$CustomerInvoiceLinePayload<ExtArgs>[]
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
      autoAnalyticRules: Prisma.$AutoAnalyticRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      sku: string | null
      name: string
      categoryId: string | null
      uom: string
      salePrice: Prisma.Decimal
      costPrice: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    poLines<T extends Product$poLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$poLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soLines<T extends Product$soLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$soLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billLines<T extends Product$billLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$billLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invLines<T extends Product$invLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$invLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalLines<T extends Product$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    autoAnalyticRules<T extends Product$autoAnalyticRulesArgs<ExtArgs> = {}>(args?: Subset<T, Product$autoAnalyticRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly companyId: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly uom: FieldRef<"Product", 'String'>
    readonly salePrice: FieldRef<"Product", 'Decimal'>
    readonly costPrice: FieldRef<"Product", 'Decimal'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * Product.poLines
   */
  export type Product$poLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * Product.soLines
   */
  export type Product$soLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * Product.billLines
   */
  export type Product$billLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    where?: VendorBillLineWhereInput
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    cursor?: VendorBillLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillLineScalarFieldEnum | VendorBillLineScalarFieldEnum[]
  }

  /**
   * Product.invLines
   */
  export type Product$invLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    where?: CustomerInvoiceLineWhereInput
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    cursor?: CustomerInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceLineScalarFieldEnum | CustomerInvoiceLineScalarFieldEnum[]
  }

  /**
   * Product.journalLines
   */
  export type Product$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * Product.autoAnalyticRules
   */
  export type Product$autoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    where?: AutoAnalyticRuleWhereInput
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    cursor?: AutoAnalyticRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticAccount
   */

  export type AggregateAnalyticAccount = {
    _count: AnalyticAccountCountAggregateOutputType | null
    _min: AnalyticAccountMinAggregateOutputType | null
    _max: AnalyticAccountMaxAggregateOutputType | null
  }

  export type AnalyticAccountMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AnalyticAccountMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AnalyticAccountCountAggregateOutputType = {
    id: number
    companyId: number
    code: number
    name: number
    parentId: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AnalyticAccountMinAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    parentId?: true
    isActive?: true
    createdAt?: true
  }

  export type AnalyticAccountMaxAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    parentId?: true
    isActive?: true
    createdAt?: true
  }

  export type AnalyticAccountCountAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticAccount to aggregate.
     */
    where?: AnalyticAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticAccounts to fetch.
     */
    orderBy?: AnalyticAccountOrderByWithRelationInput | AnalyticAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticAccounts
    **/
    _count?: true | AnalyticAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticAccountMaxAggregateInputType
  }

  export type GetAnalyticAccountAggregateType<T extends AnalyticAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticAccount[P]>
      : GetScalarType<T[P], AggregateAnalyticAccount[P]>
  }




  export type AnalyticAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticAccountWhereInput
    orderBy?: AnalyticAccountOrderByWithAggregationInput | AnalyticAccountOrderByWithAggregationInput[]
    by: AnalyticAccountScalarFieldEnum[] | AnalyticAccountScalarFieldEnum
    having?: AnalyticAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticAccountCountAggregateInputType | true
    _min?: AnalyticAccountMinAggregateInputType
    _max?: AnalyticAccountMaxAggregateInputType
  }

  export type AnalyticAccountGroupByOutputType = {
    id: string
    companyId: string
    code: string | null
    name: string
    parentId: string | null
    isActive: boolean
    createdAt: Date
    _count: AnalyticAccountCountAggregateOutputType | null
    _min: AnalyticAccountMinAggregateOutputType | null
    _max: AnalyticAccountMaxAggregateOutputType | null
  }

  type GetAnalyticAccountGroupByPayload<T extends AnalyticAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticAccountGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticAccountGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | AnalyticAccount$parentArgs<ExtArgs>
    children?: boolean | AnalyticAccount$childrenArgs<ExtArgs>
    budgetLines?: boolean | AnalyticAccount$budgetLinesArgs<ExtArgs>
    journalLines?: boolean | AnalyticAccount$journalLinesArgs<ExtArgs>
    poLines?: boolean | AnalyticAccount$poLinesArgs<ExtArgs>
    soLines?: boolean | AnalyticAccount$soLinesArgs<ExtArgs>
    billLines?: boolean | AnalyticAccount$billLinesArgs<ExtArgs>
    invLines?: boolean | AnalyticAccount$invLinesArgs<ExtArgs>
    autoAnalyticRules?: boolean | AnalyticAccount$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | AnalyticAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticAccount"]>

  export type AnalyticAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | AnalyticAccount$parentArgs<ExtArgs>
  }, ExtArgs["result"]["analyticAccount"]>

  export type AnalyticAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | AnalyticAccount$parentArgs<ExtArgs>
  }, ExtArgs["result"]["analyticAccount"]>

  export type AnalyticAccountSelectScalar = {
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AnalyticAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "code" | "name" | "parentId" | "isActive" | "createdAt", ExtArgs["result"]["analyticAccount"]>
  export type AnalyticAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | AnalyticAccount$parentArgs<ExtArgs>
    children?: boolean | AnalyticAccount$childrenArgs<ExtArgs>
    budgetLines?: boolean | AnalyticAccount$budgetLinesArgs<ExtArgs>
    journalLines?: boolean | AnalyticAccount$journalLinesArgs<ExtArgs>
    poLines?: boolean | AnalyticAccount$poLinesArgs<ExtArgs>
    soLines?: boolean | AnalyticAccount$soLinesArgs<ExtArgs>
    billLines?: boolean | AnalyticAccount$billLinesArgs<ExtArgs>
    invLines?: boolean | AnalyticAccount$invLinesArgs<ExtArgs>
    autoAnalyticRules?: boolean | AnalyticAccount$autoAnalyticRulesArgs<ExtArgs>
    _count?: boolean | AnalyticAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnalyticAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | AnalyticAccount$parentArgs<ExtArgs>
  }
  export type AnalyticAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parent?: boolean | AnalyticAccount$parentArgs<ExtArgs>
  }

  export type $AnalyticAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticAccount"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      parent: Prisma.$AnalyticAccountPayload<ExtArgs> | null
      children: Prisma.$AnalyticAccountPayload<ExtArgs>[]
      budgetLines: Prisma.$BudgetLinePayload<ExtArgs>[]
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
      poLines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      soLines: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      billLines: Prisma.$VendorBillLinePayload<ExtArgs>[]
      invLines: Prisma.$CustomerInvoiceLinePayload<ExtArgs>[]
      autoAnalyticRules: Prisma.$AutoAnalyticRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      code: string | null
      name: string
      parentId: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["analyticAccount"]>
    composites: {}
  }

  type AnalyticAccountGetPayload<S extends boolean | null | undefined | AnalyticAccountDefaultArgs> = $Result.GetResult<Prisma.$AnalyticAccountPayload, S>

  type AnalyticAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticAccountCountAggregateInputType | true
    }

  export interface AnalyticAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticAccount'], meta: { name: 'AnalyticAccount' } }
    /**
     * Find zero or one AnalyticAccount that matches the filter.
     * @param {AnalyticAccountFindUniqueArgs} args - Arguments to find a AnalyticAccount
     * @example
     * // Get one AnalyticAccount
     * const analyticAccount = await prisma.analyticAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticAccountFindUniqueArgs>(args: SelectSubset<T, AnalyticAccountFindUniqueArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticAccountFindUniqueOrThrowArgs} args - Arguments to find a AnalyticAccount
     * @example
     * // Get one AnalyticAccount
     * const analyticAccount = await prisma.analyticAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticAccountFindFirstArgs} args - Arguments to find a AnalyticAccount
     * @example
     * // Get one AnalyticAccount
     * const analyticAccount = await prisma.analyticAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticAccountFindFirstArgs>(args?: SelectSubset<T, AnalyticAccountFindFirstArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticAccountFindFirstOrThrowArgs} args - Arguments to find a AnalyticAccount
     * @example
     * // Get one AnalyticAccount
     * const analyticAccount = await prisma.analyticAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticAccounts
     * const analyticAccounts = await prisma.analyticAccount.findMany()
     * 
     * // Get first 10 AnalyticAccounts
     * const analyticAccounts = await prisma.analyticAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticAccountWithIdOnly = await prisma.analyticAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticAccountFindManyArgs>(args?: SelectSubset<T, AnalyticAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticAccount.
     * @param {AnalyticAccountCreateArgs} args - Arguments to create a AnalyticAccount.
     * @example
     * // Create one AnalyticAccount
     * const AnalyticAccount = await prisma.analyticAccount.create({
     *   data: {
     *     // ... data to create a AnalyticAccount
     *   }
     * })
     * 
     */
    create<T extends AnalyticAccountCreateArgs>(args: SelectSubset<T, AnalyticAccountCreateArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticAccounts.
     * @param {AnalyticAccountCreateManyArgs} args - Arguments to create many AnalyticAccounts.
     * @example
     * // Create many AnalyticAccounts
     * const analyticAccount = await prisma.analyticAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticAccountCreateManyArgs>(args?: SelectSubset<T, AnalyticAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticAccounts and returns the data saved in the database.
     * @param {AnalyticAccountCreateManyAndReturnArgs} args - Arguments to create many AnalyticAccounts.
     * @example
     * // Create many AnalyticAccounts
     * const analyticAccount = await prisma.analyticAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticAccounts and only return the `id`
     * const analyticAccountWithIdOnly = await prisma.analyticAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticAccount.
     * @param {AnalyticAccountDeleteArgs} args - Arguments to delete one AnalyticAccount.
     * @example
     * // Delete one AnalyticAccount
     * const AnalyticAccount = await prisma.analyticAccount.delete({
     *   where: {
     *     // ... filter to delete one AnalyticAccount
     *   }
     * })
     * 
     */
    delete<T extends AnalyticAccountDeleteArgs>(args: SelectSubset<T, AnalyticAccountDeleteArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticAccount.
     * @param {AnalyticAccountUpdateArgs} args - Arguments to update one AnalyticAccount.
     * @example
     * // Update one AnalyticAccount
     * const analyticAccount = await prisma.analyticAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticAccountUpdateArgs>(args: SelectSubset<T, AnalyticAccountUpdateArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticAccounts.
     * @param {AnalyticAccountDeleteManyArgs} args - Arguments to filter AnalyticAccounts to delete.
     * @example
     * // Delete a few AnalyticAccounts
     * const { count } = await prisma.analyticAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticAccountDeleteManyArgs>(args?: SelectSubset<T, AnalyticAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticAccounts
     * const analyticAccount = await prisma.analyticAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticAccountUpdateManyArgs>(args: SelectSubset<T, AnalyticAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticAccounts and returns the data updated in the database.
     * @param {AnalyticAccountUpdateManyAndReturnArgs} args - Arguments to update many AnalyticAccounts.
     * @example
     * // Update many AnalyticAccounts
     * const analyticAccount = await prisma.analyticAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticAccounts and only return the `id`
     * const analyticAccountWithIdOnly = await prisma.analyticAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticAccount.
     * @param {AnalyticAccountUpsertArgs} args - Arguments to update or create a AnalyticAccount.
     * @example
     * // Update or create a AnalyticAccount
     * const analyticAccount = await prisma.analyticAccount.upsert({
     *   create: {
     *     // ... data to create a AnalyticAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticAccount we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticAccountUpsertArgs>(args: SelectSubset<T, AnalyticAccountUpsertArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticAccountCountArgs} args - Arguments to filter AnalyticAccounts to count.
     * @example
     * // Count the number of AnalyticAccounts
     * const count = await prisma.analyticAccount.count({
     *   where: {
     *     // ... the filter for the AnalyticAccounts we want to count
     *   }
     * })
    **/
    count<T extends AnalyticAccountCountArgs>(
      args?: Subset<T, AnalyticAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticAccountAggregateArgs>(args: Subset<T, AnalyticAccountAggregateArgs>): Prisma.PrismaPromise<GetAnalyticAccountAggregateType<T>>

    /**
     * Group by AnalyticAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticAccountGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticAccount model
   */
  readonly fields: AnalyticAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends AnalyticAccount$parentArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$parentArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends AnalyticAccount$childrenArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgetLines<T extends AnalyticAccount$budgetLinesArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$budgetLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalLines<T extends AnalyticAccount$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    poLines<T extends AnalyticAccount$poLinesArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$poLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soLines<T extends AnalyticAccount$soLinesArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$soLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billLines<T extends AnalyticAccount$billLinesArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$billLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invLines<T extends AnalyticAccount$invLinesArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$invLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    autoAnalyticRules<T extends AnalyticAccount$autoAnalyticRulesArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccount$autoAnalyticRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticAccount model
   */
  interface AnalyticAccountFieldRefs {
    readonly id: FieldRef<"AnalyticAccount", 'String'>
    readonly companyId: FieldRef<"AnalyticAccount", 'String'>
    readonly code: FieldRef<"AnalyticAccount", 'String'>
    readonly name: FieldRef<"AnalyticAccount", 'String'>
    readonly parentId: FieldRef<"AnalyticAccount", 'String'>
    readonly isActive: FieldRef<"AnalyticAccount", 'Boolean'>
    readonly createdAt: FieldRef<"AnalyticAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticAccount findUnique
   */
  export type AnalyticAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticAccount to fetch.
     */
    where: AnalyticAccountWhereUniqueInput
  }

  /**
   * AnalyticAccount findUniqueOrThrow
   */
  export type AnalyticAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticAccount to fetch.
     */
    where: AnalyticAccountWhereUniqueInput
  }

  /**
   * AnalyticAccount findFirst
   */
  export type AnalyticAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticAccount to fetch.
     */
    where?: AnalyticAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticAccounts to fetch.
     */
    orderBy?: AnalyticAccountOrderByWithRelationInput | AnalyticAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticAccounts.
     */
    cursor?: AnalyticAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticAccounts.
     */
    distinct?: AnalyticAccountScalarFieldEnum | AnalyticAccountScalarFieldEnum[]
  }

  /**
   * AnalyticAccount findFirstOrThrow
   */
  export type AnalyticAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticAccount to fetch.
     */
    where?: AnalyticAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticAccounts to fetch.
     */
    orderBy?: AnalyticAccountOrderByWithRelationInput | AnalyticAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticAccounts.
     */
    cursor?: AnalyticAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticAccounts.
     */
    distinct?: AnalyticAccountScalarFieldEnum | AnalyticAccountScalarFieldEnum[]
  }

  /**
   * AnalyticAccount findMany
   */
  export type AnalyticAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticAccounts to fetch.
     */
    where?: AnalyticAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticAccounts to fetch.
     */
    orderBy?: AnalyticAccountOrderByWithRelationInput | AnalyticAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticAccounts.
     */
    cursor?: AnalyticAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticAccounts.
     */
    skip?: number
    distinct?: AnalyticAccountScalarFieldEnum | AnalyticAccountScalarFieldEnum[]
  }

  /**
   * AnalyticAccount create
   */
  export type AnalyticAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticAccount.
     */
    data: XOR<AnalyticAccountCreateInput, AnalyticAccountUncheckedCreateInput>
  }

  /**
   * AnalyticAccount createMany
   */
  export type AnalyticAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticAccounts.
     */
    data: AnalyticAccountCreateManyInput | AnalyticAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticAccount createManyAndReturn
   */
  export type AnalyticAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticAccounts.
     */
    data: AnalyticAccountCreateManyInput | AnalyticAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticAccount update
   */
  export type AnalyticAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticAccount.
     */
    data: XOR<AnalyticAccountUpdateInput, AnalyticAccountUncheckedUpdateInput>
    /**
     * Choose, which AnalyticAccount to update.
     */
    where: AnalyticAccountWhereUniqueInput
  }

  /**
   * AnalyticAccount updateMany
   */
  export type AnalyticAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticAccounts.
     */
    data: XOR<AnalyticAccountUpdateManyMutationInput, AnalyticAccountUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticAccounts to update
     */
    where?: AnalyticAccountWhereInput
    /**
     * Limit how many AnalyticAccounts to update.
     */
    limit?: number
  }

  /**
   * AnalyticAccount updateManyAndReturn
   */
  export type AnalyticAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticAccounts.
     */
    data: XOR<AnalyticAccountUpdateManyMutationInput, AnalyticAccountUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticAccounts to update
     */
    where?: AnalyticAccountWhereInput
    /**
     * Limit how many AnalyticAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticAccount upsert
   */
  export type AnalyticAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticAccount to update in case it exists.
     */
    where: AnalyticAccountWhereUniqueInput
    /**
     * In case the AnalyticAccount found by the `where` argument doesn't exist, create a new AnalyticAccount with this data.
     */
    create: XOR<AnalyticAccountCreateInput, AnalyticAccountUncheckedCreateInput>
    /**
     * In case the AnalyticAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticAccountUpdateInput, AnalyticAccountUncheckedUpdateInput>
  }

  /**
   * AnalyticAccount delete
   */
  export type AnalyticAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    /**
     * Filter which AnalyticAccount to delete.
     */
    where: AnalyticAccountWhereUniqueInput
  }

  /**
   * AnalyticAccount deleteMany
   */
  export type AnalyticAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticAccounts to delete
     */
    where?: AnalyticAccountWhereInput
    /**
     * Limit how many AnalyticAccounts to delete.
     */
    limit?: number
  }

  /**
   * AnalyticAccount.parent
   */
  export type AnalyticAccount$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
  }

  /**
   * AnalyticAccount.children
   */
  export type AnalyticAccount$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
    orderBy?: AnalyticAccountOrderByWithRelationInput | AnalyticAccountOrderByWithRelationInput[]
    cursor?: AnalyticAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticAccountScalarFieldEnum | AnalyticAccountScalarFieldEnum[]
  }

  /**
   * AnalyticAccount.budgetLines
   */
  export type AnalyticAccount$budgetLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    where?: BudgetLineWhereInput
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    cursor?: BudgetLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * AnalyticAccount.journalLines
   */
  export type AnalyticAccount$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * AnalyticAccount.poLines
   */
  export type AnalyticAccount$poLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * AnalyticAccount.soLines
   */
  export type AnalyticAccount$soLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * AnalyticAccount.billLines
   */
  export type AnalyticAccount$billLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    where?: VendorBillLineWhereInput
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    cursor?: VendorBillLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillLineScalarFieldEnum | VendorBillLineScalarFieldEnum[]
  }

  /**
   * AnalyticAccount.invLines
   */
  export type AnalyticAccount$invLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    where?: CustomerInvoiceLineWhereInput
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    cursor?: CustomerInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceLineScalarFieldEnum | CustomerInvoiceLineScalarFieldEnum[]
  }

  /**
   * AnalyticAccount.autoAnalyticRules
   */
  export type AnalyticAccount$autoAnalyticRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    where?: AutoAnalyticRuleWhereInput
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    cursor?: AutoAnalyticRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * AnalyticAccount without action
   */
  export type AnalyticAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
  }


  /**
   * Model GLAccount
   */

  export type AggregateGLAccount = {
    _count: GLAccountCountAggregateOutputType | null
    _min: GLAccountMinAggregateOutputType | null
    _max: GLAccountMaxAggregateOutputType | null
  }

  export type GLAccountMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    accountType: $Enums.AccountType | null
    isActive: boolean | null
  }

  export type GLAccountMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    accountType: $Enums.AccountType | null
    isActive: boolean | null
  }

  export type GLAccountCountAggregateOutputType = {
    id: number
    companyId: number
    code: number
    name: number
    accountType: number
    isActive: number
    _all: number
  }


  export type GLAccountMinAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    accountType?: true
    isActive?: true
  }

  export type GLAccountMaxAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    accountType?: true
    isActive?: true
  }

  export type GLAccountCountAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    accountType?: true
    isActive?: true
    _all?: true
  }

  export type GLAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GLAccount to aggregate.
     */
    where?: GLAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GLAccounts to fetch.
     */
    orderBy?: GLAccountOrderByWithRelationInput | GLAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GLAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GLAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GLAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GLAccounts
    **/
    _count?: true | GLAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GLAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GLAccountMaxAggregateInputType
  }

  export type GetGLAccountAggregateType<T extends GLAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateGLAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGLAccount[P]>
      : GetScalarType<T[P], AggregateGLAccount[P]>
  }




  export type GLAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GLAccountWhereInput
    orderBy?: GLAccountOrderByWithAggregationInput | GLAccountOrderByWithAggregationInput[]
    by: GLAccountScalarFieldEnum[] | GLAccountScalarFieldEnum
    having?: GLAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GLAccountCountAggregateInputType | true
    _min?: GLAccountMinAggregateInputType
    _max?: GLAccountMaxAggregateInputType
  }

  export type GLAccountGroupByOutputType = {
    id: string
    companyId: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive: boolean
    _count: GLAccountCountAggregateOutputType | null
    _min: GLAccountMinAggregateOutputType | null
    _max: GLAccountMaxAggregateOutputType | null
  }

  type GetGLAccountGroupByPayload<T extends GLAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GLAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GLAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GLAccountGroupByOutputType[P]>
            : GetScalarType<T[P], GLAccountGroupByOutputType[P]>
        }
      >
    >


  export type GLAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    accountType?: boolean
    isActive?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    journalLines?: boolean | GLAccount$journalLinesArgs<ExtArgs>
    budgetLines?: boolean | GLAccount$budgetLinesArgs<ExtArgs>
    billLines?: boolean | GLAccount$billLinesArgs<ExtArgs>
    invLines?: boolean | GLAccount$invLinesArgs<ExtArgs>
    _count?: boolean | GLAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gLAccount"]>

  export type GLAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    accountType?: boolean
    isActive?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gLAccount"]>

  export type GLAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    accountType?: boolean
    isActive?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gLAccount"]>

  export type GLAccountSelectScalar = {
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    accountType?: boolean
    isActive?: boolean
  }

  export type GLAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "code" | "name" | "accountType" | "isActive", ExtArgs["result"]["gLAccount"]>
  export type GLAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    journalLines?: boolean | GLAccount$journalLinesArgs<ExtArgs>
    budgetLines?: boolean | GLAccount$budgetLinesArgs<ExtArgs>
    billLines?: boolean | GLAccount$billLinesArgs<ExtArgs>
    invLines?: boolean | GLAccount$invLinesArgs<ExtArgs>
    _count?: boolean | GLAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GLAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type GLAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $GLAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GLAccount"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
      budgetLines: Prisma.$BudgetLinePayload<ExtArgs>[]
      billLines: Prisma.$VendorBillLinePayload<ExtArgs>[]
      invLines: Prisma.$CustomerInvoiceLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      code: string
      name: string
      accountType: $Enums.AccountType
      isActive: boolean
    }, ExtArgs["result"]["gLAccount"]>
    composites: {}
  }

  type GLAccountGetPayload<S extends boolean | null | undefined | GLAccountDefaultArgs> = $Result.GetResult<Prisma.$GLAccountPayload, S>

  type GLAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GLAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GLAccountCountAggregateInputType | true
    }

  export interface GLAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GLAccount'], meta: { name: 'GLAccount' } }
    /**
     * Find zero or one GLAccount that matches the filter.
     * @param {GLAccountFindUniqueArgs} args - Arguments to find a GLAccount
     * @example
     * // Get one GLAccount
     * const gLAccount = await prisma.gLAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GLAccountFindUniqueArgs>(args: SelectSubset<T, GLAccountFindUniqueArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GLAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GLAccountFindUniqueOrThrowArgs} args - Arguments to find a GLAccount
     * @example
     * // Get one GLAccount
     * const gLAccount = await prisma.gLAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GLAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, GLAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GLAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GLAccountFindFirstArgs} args - Arguments to find a GLAccount
     * @example
     * // Get one GLAccount
     * const gLAccount = await prisma.gLAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GLAccountFindFirstArgs>(args?: SelectSubset<T, GLAccountFindFirstArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GLAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GLAccountFindFirstOrThrowArgs} args - Arguments to find a GLAccount
     * @example
     * // Get one GLAccount
     * const gLAccount = await prisma.gLAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GLAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, GLAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GLAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GLAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GLAccounts
     * const gLAccounts = await prisma.gLAccount.findMany()
     * 
     * // Get first 10 GLAccounts
     * const gLAccounts = await prisma.gLAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gLAccountWithIdOnly = await prisma.gLAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GLAccountFindManyArgs>(args?: SelectSubset<T, GLAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GLAccount.
     * @param {GLAccountCreateArgs} args - Arguments to create a GLAccount.
     * @example
     * // Create one GLAccount
     * const GLAccount = await prisma.gLAccount.create({
     *   data: {
     *     // ... data to create a GLAccount
     *   }
     * })
     * 
     */
    create<T extends GLAccountCreateArgs>(args: SelectSubset<T, GLAccountCreateArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GLAccounts.
     * @param {GLAccountCreateManyArgs} args - Arguments to create many GLAccounts.
     * @example
     * // Create many GLAccounts
     * const gLAccount = await prisma.gLAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GLAccountCreateManyArgs>(args?: SelectSubset<T, GLAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GLAccounts and returns the data saved in the database.
     * @param {GLAccountCreateManyAndReturnArgs} args - Arguments to create many GLAccounts.
     * @example
     * // Create many GLAccounts
     * const gLAccount = await prisma.gLAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GLAccounts and only return the `id`
     * const gLAccountWithIdOnly = await prisma.gLAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GLAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, GLAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GLAccount.
     * @param {GLAccountDeleteArgs} args - Arguments to delete one GLAccount.
     * @example
     * // Delete one GLAccount
     * const GLAccount = await prisma.gLAccount.delete({
     *   where: {
     *     // ... filter to delete one GLAccount
     *   }
     * })
     * 
     */
    delete<T extends GLAccountDeleteArgs>(args: SelectSubset<T, GLAccountDeleteArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GLAccount.
     * @param {GLAccountUpdateArgs} args - Arguments to update one GLAccount.
     * @example
     * // Update one GLAccount
     * const gLAccount = await prisma.gLAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GLAccountUpdateArgs>(args: SelectSubset<T, GLAccountUpdateArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GLAccounts.
     * @param {GLAccountDeleteManyArgs} args - Arguments to filter GLAccounts to delete.
     * @example
     * // Delete a few GLAccounts
     * const { count } = await prisma.gLAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GLAccountDeleteManyArgs>(args?: SelectSubset<T, GLAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GLAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GLAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GLAccounts
     * const gLAccount = await prisma.gLAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GLAccountUpdateManyArgs>(args: SelectSubset<T, GLAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GLAccounts and returns the data updated in the database.
     * @param {GLAccountUpdateManyAndReturnArgs} args - Arguments to update many GLAccounts.
     * @example
     * // Update many GLAccounts
     * const gLAccount = await prisma.gLAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GLAccounts and only return the `id`
     * const gLAccountWithIdOnly = await prisma.gLAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GLAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, GLAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GLAccount.
     * @param {GLAccountUpsertArgs} args - Arguments to update or create a GLAccount.
     * @example
     * // Update or create a GLAccount
     * const gLAccount = await prisma.gLAccount.upsert({
     *   create: {
     *     // ... data to create a GLAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GLAccount we want to update
     *   }
     * })
     */
    upsert<T extends GLAccountUpsertArgs>(args: SelectSubset<T, GLAccountUpsertArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GLAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GLAccountCountArgs} args - Arguments to filter GLAccounts to count.
     * @example
     * // Count the number of GLAccounts
     * const count = await prisma.gLAccount.count({
     *   where: {
     *     // ... the filter for the GLAccounts we want to count
     *   }
     * })
    **/
    count<T extends GLAccountCountArgs>(
      args?: Subset<T, GLAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GLAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GLAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GLAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GLAccountAggregateArgs>(args: Subset<T, GLAccountAggregateArgs>): Prisma.PrismaPromise<GetGLAccountAggregateType<T>>

    /**
     * Group by GLAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GLAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GLAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GLAccountGroupByArgs['orderBy'] }
        : { orderBy?: GLAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GLAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGLAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GLAccount model
   */
  readonly fields: GLAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GLAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GLAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    journalLines<T extends GLAccount$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, GLAccount$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgetLines<T extends GLAccount$budgetLinesArgs<ExtArgs> = {}>(args?: Subset<T, GLAccount$budgetLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billLines<T extends GLAccount$billLinesArgs<ExtArgs> = {}>(args?: Subset<T, GLAccount$billLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invLines<T extends GLAccount$invLinesArgs<ExtArgs> = {}>(args?: Subset<T, GLAccount$invLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GLAccount model
   */
  interface GLAccountFieldRefs {
    readonly id: FieldRef<"GLAccount", 'String'>
    readonly companyId: FieldRef<"GLAccount", 'String'>
    readonly code: FieldRef<"GLAccount", 'String'>
    readonly name: FieldRef<"GLAccount", 'String'>
    readonly accountType: FieldRef<"GLAccount", 'AccountType'>
    readonly isActive: FieldRef<"GLAccount", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * GLAccount findUnique
   */
  export type GLAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * Filter, which GLAccount to fetch.
     */
    where: GLAccountWhereUniqueInput
  }

  /**
   * GLAccount findUniqueOrThrow
   */
  export type GLAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * Filter, which GLAccount to fetch.
     */
    where: GLAccountWhereUniqueInput
  }

  /**
   * GLAccount findFirst
   */
  export type GLAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * Filter, which GLAccount to fetch.
     */
    where?: GLAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GLAccounts to fetch.
     */
    orderBy?: GLAccountOrderByWithRelationInput | GLAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GLAccounts.
     */
    cursor?: GLAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GLAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GLAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GLAccounts.
     */
    distinct?: GLAccountScalarFieldEnum | GLAccountScalarFieldEnum[]
  }

  /**
   * GLAccount findFirstOrThrow
   */
  export type GLAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * Filter, which GLAccount to fetch.
     */
    where?: GLAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GLAccounts to fetch.
     */
    orderBy?: GLAccountOrderByWithRelationInput | GLAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GLAccounts.
     */
    cursor?: GLAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GLAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GLAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GLAccounts.
     */
    distinct?: GLAccountScalarFieldEnum | GLAccountScalarFieldEnum[]
  }

  /**
   * GLAccount findMany
   */
  export type GLAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * Filter, which GLAccounts to fetch.
     */
    where?: GLAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GLAccounts to fetch.
     */
    orderBy?: GLAccountOrderByWithRelationInput | GLAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GLAccounts.
     */
    cursor?: GLAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GLAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GLAccounts.
     */
    skip?: number
    distinct?: GLAccountScalarFieldEnum | GLAccountScalarFieldEnum[]
  }

  /**
   * GLAccount create
   */
  export type GLAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a GLAccount.
     */
    data: XOR<GLAccountCreateInput, GLAccountUncheckedCreateInput>
  }

  /**
   * GLAccount createMany
   */
  export type GLAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GLAccounts.
     */
    data: GLAccountCreateManyInput | GLAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GLAccount createManyAndReturn
   */
  export type GLAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * The data used to create many GLAccounts.
     */
    data: GLAccountCreateManyInput | GLAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GLAccount update
   */
  export type GLAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a GLAccount.
     */
    data: XOR<GLAccountUpdateInput, GLAccountUncheckedUpdateInput>
    /**
     * Choose, which GLAccount to update.
     */
    where: GLAccountWhereUniqueInput
  }

  /**
   * GLAccount updateMany
   */
  export type GLAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GLAccounts.
     */
    data: XOR<GLAccountUpdateManyMutationInput, GLAccountUncheckedUpdateManyInput>
    /**
     * Filter which GLAccounts to update
     */
    where?: GLAccountWhereInput
    /**
     * Limit how many GLAccounts to update.
     */
    limit?: number
  }

  /**
   * GLAccount updateManyAndReturn
   */
  export type GLAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * The data used to update GLAccounts.
     */
    data: XOR<GLAccountUpdateManyMutationInput, GLAccountUncheckedUpdateManyInput>
    /**
     * Filter which GLAccounts to update
     */
    where?: GLAccountWhereInput
    /**
     * Limit how many GLAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GLAccount upsert
   */
  export type GLAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the GLAccount to update in case it exists.
     */
    where: GLAccountWhereUniqueInput
    /**
     * In case the GLAccount found by the `where` argument doesn't exist, create a new GLAccount with this data.
     */
    create: XOR<GLAccountCreateInput, GLAccountUncheckedCreateInput>
    /**
     * In case the GLAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GLAccountUpdateInput, GLAccountUncheckedUpdateInput>
  }

  /**
   * GLAccount delete
   */
  export type GLAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    /**
     * Filter which GLAccount to delete.
     */
    where: GLAccountWhereUniqueInput
  }

  /**
   * GLAccount deleteMany
   */
  export type GLAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GLAccounts to delete
     */
    where?: GLAccountWhereInput
    /**
     * Limit how many GLAccounts to delete.
     */
    limit?: number
  }

  /**
   * GLAccount.journalLines
   */
  export type GLAccount$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * GLAccount.budgetLines
   */
  export type GLAccount$budgetLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    where?: BudgetLineWhereInput
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    cursor?: BudgetLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * GLAccount.billLines
   */
  export type GLAccount$billLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    where?: VendorBillLineWhereInput
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    cursor?: VendorBillLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillLineScalarFieldEnum | VendorBillLineScalarFieldEnum[]
  }

  /**
   * GLAccount.invLines
   */
  export type GLAccount$invLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    where?: CustomerInvoiceLineWhereInput
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    cursor?: CustomerInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceLineScalarFieldEnum | CustomerInvoiceLineScalarFieldEnum[]
  }

  /**
   * GLAccount without action
   */
  export type GLAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    entryDate: Date | null
    status: $Enums.JournalStatus | null
    sourceType: $Enums.JournalSourceType | null
    sourceId: string | null
    memo: string | null
    createdAt: Date | null
    postedAt: Date | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    entryDate: Date | null
    status: $Enums.JournalStatus | null
    sourceType: $Enums.JournalSourceType | null
    sourceId: string | null
    memo: string | null
    createdAt: Date | null
    postedAt: Date | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    companyId: number
    entryDate: number
    status: number
    sourceType: number
    sourceId: number
    memo: number
    createdAt: number
    postedAt: number
    _all: number
  }


  export type JournalEntryMinAggregateInputType = {
    id?: true
    companyId?: true
    entryDate?: true
    status?: true
    sourceType?: true
    sourceId?: true
    memo?: true
    createdAt?: true
    postedAt?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    companyId?: true
    entryDate?: true
    status?: true
    sourceType?: true
    sourceId?: true
    memo?: true
    createdAt?: true
    postedAt?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    companyId?: true
    entryDate?: true
    status?: true
    sourceType?: true
    sourceId?: true
    memo?: true
    createdAt?: true
    postedAt?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: string
    companyId: string
    entryDate: Date
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId: string | null
    memo: string | null
    createdAt: Date
    postedAt: Date | null
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    entryDate?: boolean
    status?: boolean
    sourceType?: boolean
    sourceId?: boolean
    memo?: boolean
    createdAt?: boolean
    postedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    entryDate?: boolean
    status?: boolean
    sourceType?: boolean
    sourceId?: boolean
    memo?: boolean
    createdAt?: boolean
    postedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    entryDate?: boolean
    status?: boolean
    sourceType?: boolean
    sourceId?: boolean
    memo?: boolean
    createdAt?: boolean
    postedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    companyId?: boolean
    entryDate?: boolean
    status?: boolean
    sourceType?: boolean
    sourceId?: boolean
    memo?: boolean
    createdAt?: boolean
    postedAt?: boolean
  }

  export type JournalEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "entryDate" | "status" | "sourceType" | "sourceId" | "memo" | "createdAt" | "postedAt", ExtArgs["result"]["journalEntry"]>
  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      lines: Prisma.$JournalLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      entryDate: Date
      status: $Enums.JournalStatus
      sourceType: $Enums.JournalSourceType
      sourceId: string | null
      memo: string | null
      createdAt: Date
      postedAt: Date | null
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries and returns the data updated in the database.
     * @param {JournalEntryUpdateManyAndReturnArgs} args - Arguments to update many JournalEntries.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends JournalEntry$linesArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'String'>
    readonly companyId: FieldRef<"JournalEntry", 'String'>
    readonly entryDate: FieldRef<"JournalEntry", 'DateTime'>
    readonly status: FieldRef<"JournalEntry", 'JournalStatus'>
    readonly sourceType: FieldRef<"JournalEntry", 'JournalSourceType'>
    readonly sourceId: FieldRef<"JournalEntry", 'String'>
    readonly memo: FieldRef<"JournalEntry", 'String'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly postedAt: FieldRef<"JournalEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
  }

  /**
   * JournalEntry updateManyAndReturn
   */
  export type JournalEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to delete.
     */
    limit?: number
  }

  /**
   * JournalEntry.lines
   */
  export type JournalEntry$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model JournalLine
   */

  export type AggregateJournalLine = {
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  export type JournalLineAvgAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type JournalLineSumAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type JournalLineMinAggregateOutputType = {
    id: string | null
    journalEntryId: string | null
    glAccountId: string | null
    analyticAccountId: string | null
    contactId: string | null
    productId: string | null
    description: string | null
    debit: Decimal | null
    credit: Decimal | null
  }

  export type JournalLineMaxAggregateOutputType = {
    id: string | null
    journalEntryId: string | null
    glAccountId: string | null
    analyticAccountId: string | null
    contactId: string | null
    productId: string | null
    description: string | null
    debit: Decimal | null
    credit: Decimal | null
  }

  export type JournalLineCountAggregateOutputType = {
    id: number
    journalEntryId: number
    glAccountId: number
    analyticAccountId: number
    contactId: number
    productId: number
    description: number
    debit: number
    credit: number
    _all: number
  }


  export type JournalLineAvgAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type JournalLineSumAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type JournalLineMinAggregateInputType = {
    id?: true
    journalEntryId?: true
    glAccountId?: true
    analyticAccountId?: true
    contactId?: true
    productId?: true
    description?: true
    debit?: true
    credit?: true
  }

  export type JournalLineMaxAggregateInputType = {
    id?: true
    journalEntryId?: true
    glAccountId?: true
    analyticAccountId?: true
    contactId?: true
    productId?: true
    description?: true
    debit?: true
    credit?: true
  }

  export type JournalLineCountAggregateInputType = {
    id?: true
    journalEntryId?: true
    glAccountId?: true
    analyticAccountId?: true
    contactId?: true
    productId?: true
    description?: true
    debit?: true
    credit?: true
    _all?: true
  }

  export type JournalLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLine to aggregate.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalLines
    **/
    _count?: true | JournalLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalLineMaxAggregateInputType
  }

  export type GetJournalLineAggregateType<T extends JournalLineAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalLine[P]>
      : GetScalarType<T[P], AggregateJournalLine[P]>
  }




  export type JournalLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithAggregationInput | JournalLineOrderByWithAggregationInput[]
    by: JournalLineScalarFieldEnum[] | JournalLineScalarFieldEnum
    having?: JournalLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalLineCountAggregateInputType | true
    _avg?: JournalLineAvgAggregateInputType
    _sum?: JournalLineSumAggregateInputType
    _min?: JournalLineMinAggregateInputType
    _max?: JournalLineMaxAggregateInputType
  }

  export type JournalLineGroupByOutputType = {
    id: string
    journalEntryId: string
    glAccountId: string
    analyticAccountId: string | null
    contactId: string | null
    productId: string | null
    description: string | null
    debit: Decimal
    credit: Decimal
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  type GetJournalLineGroupByPayload<T extends JournalLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
            : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
        }
      >
    >


  export type JournalLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalEntryId?: boolean
    glAccountId?: boolean
    analyticAccountId?: boolean
    contactId?: boolean
    productId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    gl?: boolean | GLAccountDefaultArgs<ExtArgs>
    analytic?: boolean | JournalLine$analyticArgs<ExtArgs>
    contact?: boolean | JournalLine$contactArgs<ExtArgs>
    product?: boolean | JournalLine$productArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalEntryId?: boolean
    glAccountId?: boolean
    analyticAccountId?: boolean
    contactId?: boolean
    productId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    gl?: boolean | GLAccountDefaultArgs<ExtArgs>
    analytic?: boolean | JournalLine$analyticArgs<ExtArgs>
    contact?: boolean | JournalLine$contactArgs<ExtArgs>
    product?: boolean | JournalLine$productArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalEntryId?: boolean
    glAccountId?: boolean
    analyticAccountId?: boolean
    contactId?: boolean
    productId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    gl?: boolean | GLAccountDefaultArgs<ExtArgs>
    analytic?: boolean | JournalLine$analyticArgs<ExtArgs>
    contact?: boolean | JournalLine$contactArgs<ExtArgs>
    product?: boolean | JournalLine$productArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectScalar = {
    id?: boolean
    journalEntryId?: boolean
    glAccountId?: boolean
    analyticAccountId?: boolean
    contactId?: boolean
    productId?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
  }

  export type JournalLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalEntryId" | "glAccountId" | "analyticAccountId" | "contactId" | "productId" | "description" | "debit" | "credit", ExtArgs["result"]["journalLine"]>
  export type JournalLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    gl?: boolean | GLAccountDefaultArgs<ExtArgs>
    analytic?: boolean | JournalLine$analyticArgs<ExtArgs>
    contact?: boolean | JournalLine$contactArgs<ExtArgs>
    product?: boolean | JournalLine$productArgs<ExtArgs>
  }
  export type JournalLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    gl?: boolean | GLAccountDefaultArgs<ExtArgs>
    analytic?: boolean | JournalLine$analyticArgs<ExtArgs>
    contact?: boolean | JournalLine$contactArgs<ExtArgs>
    product?: boolean | JournalLine$productArgs<ExtArgs>
  }
  export type JournalLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    gl?: boolean | GLAccountDefaultArgs<ExtArgs>
    analytic?: boolean | JournalLine$analyticArgs<ExtArgs>
    contact?: boolean | JournalLine$contactArgs<ExtArgs>
    product?: boolean | JournalLine$productArgs<ExtArgs>
  }

  export type $JournalLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalLine"
    objects: {
      entry: Prisma.$JournalEntryPayload<ExtArgs>
      gl: Prisma.$GLAccountPayload<ExtArgs>
      analytic: Prisma.$AnalyticAccountPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalEntryId: string
      glAccountId: string
      analyticAccountId: string | null
      contactId: string | null
      productId: string | null
      description: string | null
      debit: Prisma.Decimal
      credit: Prisma.Decimal
    }, ExtArgs["result"]["journalLine"]>
    composites: {}
  }

  type JournalLineGetPayload<S extends boolean | null | undefined | JournalLineDefaultArgs> = $Result.GetResult<Prisma.$JournalLinePayload, S>

  type JournalLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalLineCountAggregateInputType | true
    }

  export interface JournalLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalLine'], meta: { name: 'JournalLine' } }
    /**
     * Find zero or one JournalLine that matches the filter.
     * @param {JournalLineFindUniqueArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalLineFindUniqueArgs>(args: SelectSubset<T, JournalLineFindUniqueArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalLineFindUniqueOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalLineFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalLineFindFirstArgs>(args?: SelectSubset<T, JournalLineFindFirstArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalLineFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalLines
     * const journalLines = await prisma.journalLine.findMany()
     * 
     * // Get first 10 JournalLines
     * const journalLines = await prisma.journalLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalLineFindManyArgs>(args?: SelectSubset<T, JournalLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalLine.
     * @param {JournalLineCreateArgs} args - Arguments to create a JournalLine.
     * @example
     * // Create one JournalLine
     * const JournalLine = await prisma.journalLine.create({
     *   data: {
     *     // ... data to create a JournalLine
     *   }
     * })
     * 
     */
    create<T extends JournalLineCreateArgs>(args: SelectSubset<T, JournalLineCreateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalLines.
     * @param {JournalLineCreateManyArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalLineCreateManyArgs>(args?: SelectSubset<T, JournalLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalLines and returns the data saved in the database.
     * @param {JournalLineCreateManyAndReturnArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalLines and only return the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalLineCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalLine.
     * @param {JournalLineDeleteArgs} args - Arguments to delete one JournalLine.
     * @example
     * // Delete one JournalLine
     * const JournalLine = await prisma.journalLine.delete({
     *   where: {
     *     // ... filter to delete one JournalLine
     *   }
     * })
     * 
     */
    delete<T extends JournalLineDeleteArgs>(args: SelectSubset<T, JournalLineDeleteArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalLine.
     * @param {JournalLineUpdateArgs} args - Arguments to update one JournalLine.
     * @example
     * // Update one JournalLine
     * const journalLine = await prisma.journalLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalLineUpdateArgs>(args: SelectSubset<T, JournalLineUpdateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalLines.
     * @param {JournalLineDeleteManyArgs} args - Arguments to filter JournalLines to delete.
     * @example
     * // Delete a few JournalLines
     * const { count } = await prisma.journalLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalLineDeleteManyArgs>(args?: SelectSubset<T, JournalLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalLines
     * const journalLine = await prisma.journalLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalLineUpdateManyArgs>(args: SelectSubset<T, JournalLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLines and returns the data updated in the database.
     * @param {JournalLineUpdateManyAndReturnArgs} args - Arguments to update many JournalLines.
     * @example
     * // Update many JournalLines
     * const journalLine = await prisma.journalLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalLines and only return the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalLineUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalLine.
     * @param {JournalLineUpsertArgs} args - Arguments to update or create a JournalLine.
     * @example
     * // Update or create a JournalLine
     * const journalLine = await prisma.journalLine.upsert({
     *   create: {
     *     // ... data to create a JournalLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalLine we want to update
     *   }
     * })
     */
    upsert<T extends JournalLineUpsertArgs>(args: SelectSubset<T, JournalLineUpsertArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineCountArgs} args - Arguments to filter JournalLines to count.
     * @example
     * // Count the number of JournalLines
     * const count = await prisma.journalLine.count({
     *   where: {
     *     // ... the filter for the JournalLines we want to count
     *   }
     * })
    **/
    count<T extends JournalLineCountArgs>(
      args?: Subset<T, JournalLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalLineAggregateArgs>(args: Subset<T, JournalLineAggregateArgs>): Prisma.PrismaPromise<GetJournalLineAggregateType<T>>

    /**
     * Group by JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalLineGroupByArgs['orderBy'] }
        : { orderBy?: JournalLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalLine model
   */
  readonly fields: JournalLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entry<T extends JournalEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntryDefaultArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gl<T extends GLAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GLAccountDefaultArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analytic<T extends JournalLine$analyticArgs<ExtArgs> = {}>(args?: Subset<T, JournalLine$analyticArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends JournalLine$contactArgs<ExtArgs> = {}>(args?: Subset<T, JournalLine$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends JournalLine$productArgs<ExtArgs> = {}>(args?: Subset<T, JournalLine$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalLine model
   */
  interface JournalLineFieldRefs {
    readonly id: FieldRef<"JournalLine", 'String'>
    readonly journalEntryId: FieldRef<"JournalLine", 'String'>
    readonly glAccountId: FieldRef<"JournalLine", 'String'>
    readonly analyticAccountId: FieldRef<"JournalLine", 'String'>
    readonly contactId: FieldRef<"JournalLine", 'String'>
    readonly productId: FieldRef<"JournalLine", 'String'>
    readonly description: FieldRef<"JournalLine", 'String'>
    readonly debit: FieldRef<"JournalLine", 'Decimal'>
    readonly credit: FieldRef<"JournalLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * JournalLine findUnique
   */
  export type JournalLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findUniqueOrThrow
   */
  export type JournalLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findFirst
   */
  export type JournalLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findFirstOrThrow
   */
  export type JournalLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findMany
   */
  export type JournalLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLines to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine create
   */
  export type JournalLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalLine.
     */
    data: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
  }

  /**
   * JournalLine createMany
   */
  export type JournalLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalLine createManyAndReturn
   */
  export type JournalLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLine update
   */
  export type JournalLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalLine.
     */
    data: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
    /**
     * Choose, which JournalLine to update.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine updateMany
   */
  export type JournalLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalLines.
     */
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyInput>
    /**
     * Filter which JournalLines to update
     */
    where?: JournalLineWhereInput
    /**
     * Limit how many JournalLines to update.
     */
    limit?: number
  }

  /**
   * JournalLine updateManyAndReturn
   */
  export type JournalLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * The data used to update JournalLines.
     */
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyInput>
    /**
     * Filter which JournalLines to update
     */
    where?: JournalLineWhereInput
    /**
     * Limit how many JournalLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLine upsert
   */
  export type JournalLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalLine to update in case it exists.
     */
    where: JournalLineWhereUniqueInput
    /**
     * In case the JournalLine found by the `where` argument doesn't exist, create a new JournalLine with this data.
     */
    create: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
    /**
     * In case the JournalLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
  }

  /**
   * JournalLine delete
   */
  export type JournalLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter which JournalLine to delete.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine deleteMany
   */
  export type JournalLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLines to delete
     */
    where?: JournalLineWhereInput
    /**
     * Limit how many JournalLines to delete.
     */
    limit?: number
  }

  /**
   * JournalLine.analytic
   */
  export type JournalLine$analyticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
  }

  /**
   * JournalLine.contact
   */
  export type JournalLine$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * JournalLine.product
   */
  export type JournalLine$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * JournalLine without action
   */
  export type JournalLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    periodStart: Date | null
    periodEnd: Date | null
    status: $Enums.BudgetStatus | null
    createdBy: string | null
    createdAt: Date | null
    approvedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    periodStart: Date | null
    periodEnd: Date | null
    status: $Enums.BudgetStatus | null
    createdBy: string | null
    createdAt: Date | null
    approvedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    periodStart: number
    periodEnd: number
    status: number
    createdBy: number
    createdAt: number
    approvedAt: number
    _all: number
  }


  export type BudgetMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    companyId: string
    name: string
    periodStart: Date
    periodEnd: Date
    status: $Enums.BudgetStatus
    createdBy: string | null
    createdAt: Date
    approvedAt: Date | null
    _count: BudgetCountAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    revisions?: boolean | Budget$revisionsArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "periodStart" | "periodEnd" | "status" | "createdBy" | "createdAt" | "approvedAt", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    revisions?: boolean | Budget$revisionsArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      revisions: Prisma.$BudgetRevisionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      periodStart: Date
      periodEnd: Date
      status: $Enums.BudgetStatus
      createdBy: string | null
      createdAt: Date
      approvedAt: Date | null
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    revisions<T extends Budget$revisionsArgs<ExtArgs> = {}>(args?: Subset<T, Budget$revisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly companyId: FieldRef<"Budget", 'String'>
    readonly name: FieldRef<"Budget", 'String'>
    readonly periodStart: FieldRef<"Budget", 'DateTime'>
    readonly periodEnd: FieldRef<"Budget", 'DateTime'>
    readonly status: FieldRef<"Budget", 'BudgetStatus'>
    readonly createdBy: FieldRef<"Budget", 'String'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly approvedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget.revisions
   */
  export type Budget$revisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    where?: BudgetRevisionWhereInput
    orderBy?: BudgetRevisionOrderByWithRelationInput | BudgetRevisionOrderByWithRelationInput[]
    cursor?: BudgetRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetRevisionScalarFieldEnum | BudgetRevisionScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model BudgetRevision
   */

  export type AggregateBudgetRevision = {
    _count: BudgetRevisionCountAggregateOutputType | null
    _avg: BudgetRevisionAvgAggregateOutputType | null
    _sum: BudgetRevisionSumAggregateOutputType | null
    _min: BudgetRevisionMinAggregateOutputType | null
    _max: BudgetRevisionMaxAggregateOutputType | null
  }

  export type BudgetRevisionAvgAggregateOutputType = {
    revisionNo: number | null
  }

  export type BudgetRevisionSumAggregateOutputType = {
    revisionNo: number | null
  }

  export type BudgetRevisionMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    revisionNo: number | null
    revisionReason: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type BudgetRevisionMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    revisionNo: number | null
    revisionReason: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type BudgetRevisionCountAggregateOutputType = {
    id: number
    budgetId: number
    revisionNo: number
    revisionReason: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type BudgetRevisionAvgAggregateInputType = {
    revisionNo?: true
  }

  export type BudgetRevisionSumAggregateInputType = {
    revisionNo?: true
  }

  export type BudgetRevisionMinAggregateInputType = {
    id?: true
    budgetId?: true
    revisionNo?: true
    revisionReason?: true
    createdAt?: true
    createdBy?: true
  }

  export type BudgetRevisionMaxAggregateInputType = {
    id?: true
    budgetId?: true
    revisionNo?: true
    revisionReason?: true
    createdAt?: true
    createdBy?: true
  }

  export type BudgetRevisionCountAggregateInputType = {
    id?: true
    budgetId?: true
    revisionNo?: true
    revisionReason?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type BudgetRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetRevision to aggregate.
     */
    where?: BudgetRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRevisions to fetch.
     */
    orderBy?: BudgetRevisionOrderByWithRelationInput | BudgetRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetRevisions
    **/
    _count?: true | BudgetRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetRevisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetRevisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetRevisionMaxAggregateInputType
  }

  export type GetBudgetRevisionAggregateType<T extends BudgetRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetRevision[P]>
      : GetScalarType<T[P], AggregateBudgetRevision[P]>
  }




  export type BudgetRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetRevisionWhereInput
    orderBy?: BudgetRevisionOrderByWithAggregationInput | BudgetRevisionOrderByWithAggregationInput[]
    by: BudgetRevisionScalarFieldEnum[] | BudgetRevisionScalarFieldEnum
    having?: BudgetRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetRevisionCountAggregateInputType | true
    _avg?: BudgetRevisionAvgAggregateInputType
    _sum?: BudgetRevisionSumAggregateInputType
    _min?: BudgetRevisionMinAggregateInputType
    _max?: BudgetRevisionMaxAggregateInputType
  }

  export type BudgetRevisionGroupByOutputType = {
    id: string
    budgetId: string
    revisionNo: number
    revisionReason: string | null
    createdAt: Date
    createdBy: string | null
    _count: BudgetRevisionCountAggregateOutputType | null
    _avg: BudgetRevisionAvgAggregateOutputType | null
    _sum: BudgetRevisionSumAggregateOutputType | null
    _min: BudgetRevisionMinAggregateOutputType | null
    _max: BudgetRevisionMaxAggregateOutputType | null
  }

  type GetBudgetRevisionGroupByPayload<T extends BudgetRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetRevisionGroupByOutputType[P]>
        }
      >
    >


  export type BudgetRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    revisionNo?: boolean
    revisionReason?: boolean
    createdAt?: boolean
    createdBy?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    lines?: boolean | BudgetRevision$linesArgs<ExtArgs>
    _count?: boolean | BudgetRevisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetRevision"]>

  export type BudgetRevisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    revisionNo?: boolean
    revisionReason?: boolean
    createdAt?: boolean
    createdBy?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetRevision"]>

  export type BudgetRevisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    revisionNo?: boolean
    revisionReason?: boolean
    createdAt?: boolean
    createdBy?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetRevision"]>

  export type BudgetRevisionSelectScalar = {
    id?: boolean
    budgetId?: boolean
    revisionNo?: boolean
    revisionReason?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type BudgetRevisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budgetId" | "revisionNo" | "revisionReason" | "createdAt" | "createdBy", ExtArgs["result"]["budgetRevision"]>
  export type BudgetRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    lines?: boolean | BudgetRevision$linesArgs<ExtArgs>
    _count?: boolean | BudgetRevisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetRevisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }
  export type BudgetRevisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }

  export type $BudgetRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetRevision"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
      lines: Prisma.$BudgetLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      revisionNo: number
      revisionReason: string | null
      createdAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["budgetRevision"]>
    composites: {}
  }

  type BudgetRevisionGetPayload<S extends boolean | null | undefined | BudgetRevisionDefaultArgs> = $Result.GetResult<Prisma.$BudgetRevisionPayload, S>

  type BudgetRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetRevisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetRevisionCountAggregateInputType | true
    }

  export interface BudgetRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetRevision'], meta: { name: 'BudgetRevision' } }
    /**
     * Find zero or one BudgetRevision that matches the filter.
     * @param {BudgetRevisionFindUniqueArgs} args - Arguments to find a BudgetRevision
     * @example
     * // Get one BudgetRevision
     * const budgetRevision = await prisma.budgetRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetRevisionFindUniqueArgs>(args: SelectSubset<T, BudgetRevisionFindUniqueArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BudgetRevision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetRevisionFindUniqueOrThrowArgs} args - Arguments to find a BudgetRevision
     * @example
     * // Get one BudgetRevision
     * const budgetRevision = await prisma.budgetRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetRevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetRevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRevisionFindFirstArgs} args - Arguments to find a BudgetRevision
     * @example
     * // Get one BudgetRevision
     * const budgetRevision = await prisma.budgetRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetRevisionFindFirstArgs>(args?: SelectSubset<T, BudgetRevisionFindFirstArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRevisionFindFirstOrThrowArgs} args - Arguments to find a BudgetRevision
     * @example
     * // Get one BudgetRevision
     * const budgetRevision = await prisma.budgetRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetRevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetRevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BudgetRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetRevisions
     * const budgetRevisions = await prisma.budgetRevision.findMany()
     * 
     * // Get first 10 BudgetRevisions
     * const budgetRevisions = await prisma.budgetRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetRevisionWithIdOnly = await prisma.budgetRevision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetRevisionFindManyArgs>(args?: SelectSubset<T, BudgetRevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BudgetRevision.
     * @param {BudgetRevisionCreateArgs} args - Arguments to create a BudgetRevision.
     * @example
     * // Create one BudgetRevision
     * const BudgetRevision = await prisma.budgetRevision.create({
     *   data: {
     *     // ... data to create a BudgetRevision
     *   }
     * })
     * 
     */
    create<T extends BudgetRevisionCreateArgs>(args: SelectSubset<T, BudgetRevisionCreateArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BudgetRevisions.
     * @param {BudgetRevisionCreateManyArgs} args - Arguments to create many BudgetRevisions.
     * @example
     * // Create many BudgetRevisions
     * const budgetRevision = await prisma.budgetRevision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetRevisionCreateManyArgs>(args?: SelectSubset<T, BudgetRevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetRevisions and returns the data saved in the database.
     * @param {BudgetRevisionCreateManyAndReturnArgs} args - Arguments to create many BudgetRevisions.
     * @example
     * // Create many BudgetRevisions
     * const budgetRevision = await prisma.budgetRevision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetRevisions and only return the `id`
     * const budgetRevisionWithIdOnly = await prisma.budgetRevision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetRevisionCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetRevisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BudgetRevision.
     * @param {BudgetRevisionDeleteArgs} args - Arguments to delete one BudgetRevision.
     * @example
     * // Delete one BudgetRevision
     * const BudgetRevision = await prisma.budgetRevision.delete({
     *   where: {
     *     // ... filter to delete one BudgetRevision
     *   }
     * })
     * 
     */
    delete<T extends BudgetRevisionDeleteArgs>(args: SelectSubset<T, BudgetRevisionDeleteArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BudgetRevision.
     * @param {BudgetRevisionUpdateArgs} args - Arguments to update one BudgetRevision.
     * @example
     * // Update one BudgetRevision
     * const budgetRevision = await prisma.budgetRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetRevisionUpdateArgs>(args: SelectSubset<T, BudgetRevisionUpdateArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BudgetRevisions.
     * @param {BudgetRevisionDeleteManyArgs} args - Arguments to filter BudgetRevisions to delete.
     * @example
     * // Delete a few BudgetRevisions
     * const { count } = await prisma.budgetRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetRevisionDeleteManyArgs>(args?: SelectSubset<T, BudgetRevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetRevisions
     * const budgetRevision = await prisma.budgetRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetRevisionUpdateManyArgs>(args: SelectSubset<T, BudgetRevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetRevisions and returns the data updated in the database.
     * @param {BudgetRevisionUpdateManyAndReturnArgs} args - Arguments to update many BudgetRevisions.
     * @example
     * // Update many BudgetRevisions
     * const budgetRevision = await prisma.budgetRevision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BudgetRevisions and only return the `id`
     * const budgetRevisionWithIdOnly = await prisma.budgetRevision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetRevisionUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetRevisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BudgetRevision.
     * @param {BudgetRevisionUpsertArgs} args - Arguments to update or create a BudgetRevision.
     * @example
     * // Update or create a BudgetRevision
     * const budgetRevision = await prisma.budgetRevision.upsert({
     *   create: {
     *     // ... data to create a BudgetRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetRevision we want to update
     *   }
     * })
     */
    upsert<T extends BudgetRevisionUpsertArgs>(args: SelectSubset<T, BudgetRevisionUpsertArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BudgetRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRevisionCountArgs} args - Arguments to filter BudgetRevisions to count.
     * @example
     * // Count the number of BudgetRevisions
     * const count = await prisma.budgetRevision.count({
     *   where: {
     *     // ... the filter for the BudgetRevisions we want to count
     *   }
     * })
    **/
    count<T extends BudgetRevisionCountArgs>(
      args?: Subset<T, BudgetRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetRevisionAggregateArgs>(args: Subset<T, BudgetRevisionAggregateArgs>): Prisma.PrismaPromise<GetBudgetRevisionAggregateType<T>>

    /**
     * Group by BudgetRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetRevisionGroupByArgs['orderBy'] }
        : { orderBy?: BudgetRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetRevision model
   */
  readonly fields: BudgetRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends BudgetRevision$linesArgs<ExtArgs> = {}>(args?: Subset<T, BudgetRevision$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetRevision model
   */
  interface BudgetRevisionFieldRefs {
    readonly id: FieldRef<"BudgetRevision", 'String'>
    readonly budgetId: FieldRef<"BudgetRevision", 'String'>
    readonly revisionNo: FieldRef<"BudgetRevision", 'Int'>
    readonly revisionReason: FieldRef<"BudgetRevision", 'String'>
    readonly createdAt: FieldRef<"BudgetRevision", 'DateTime'>
    readonly createdBy: FieldRef<"BudgetRevision", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BudgetRevision findUnique
   */
  export type BudgetRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * Filter, which BudgetRevision to fetch.
     */
    where: BudgetRevisionWhereUniqueInput
  }

  /**
   * BudgetRevision findUniqueOrThrow
   */
  export type BudgetRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * Filter, which BudgetRevision to fetch.
     */
    where: BudgetRevisionWhereUniqueInput
  }

  /**
   * BudgetRevision findFirst
   */
  export type BudgetRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * Filter, which BudgetRevision to fetch.
     */
    where?: BudgetRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRevisions to fetch.
     */
    orderBy?: BudgetRevisionOrderByWithRelationInput | BudgetRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetRevisions.
     */
    cursor?: BudgetRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetRevisions.
     */
    distinct?: BudgetRevisionScalarFieldEnum | BudgetRevisionScalarFieldEnum[]
  }

  /**
   * BudgetRevision findFirstOrThrow
   */
  export type BudgetRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * Filter, which BudgetRevision to fetch.
     */
    where?: BudgetRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRevisions to fetch.
     */
    orderBy?: BudgetRevisionOrderByWithRelationInput | BudgetRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetRevisions.
     */
    cursor?: BudgetRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetRevisions.
     */
    distinct?: BudgetRevisionScalarFieldEnum | BudgetRevisionScalarFieldEnum[]
  }

  /**
   * BudgetRevision findMany
   */
  export type BudgetRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * Filter, which BudgetRevisions to fetch.
     */
    where?: BudgetRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRevisions to fetch.
     */
    orderBy?: BudgetRevisionOrderByWithRelationInput | BudgetRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetRevisions.
     */
    cursor?: BudgetRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRevisions.
     */
    skip?: number
    distinct?: BudgetRevisionScalarFieldEnum | BudgetRevisionScalarFieldEnum[]
  }

  /**
   * BudgetRevision create
   */
  export type BudgetRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetRevision.
     */
    data: XOR<BudgetRevisionCreateInput, BudgetRevisionUncheckedCreateInput>
  }

  /**
   * BudgetRevision createMany
   */
  export type BudgetRevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetRevisions.
     */
    data: BudgetRevisionCreateManyInput | BudgetRevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetRevision createManyAndReturn
   */
  export type BudgetRevisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * The data used to create many BudgetRevisions.
     */
    data: BudgetRevisionCreateManyInput | BudgetRevisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetRevision update
   */
  export type BudgetRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetRevision.
     */
    data: XOR<BudgetRevisionUpdateInput, BudgetRevisionUncheckedUpdateInput>
    /**
     * Choose, which BudgetRevision to update.
     */
    where: BudgetRevisionWhereUniqueInput
  }

  /**
   * BudgetRevision updateMany
   */
  export type BudgetRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetRevisions.
     */
    data: XOR<BudgetRevisionUpdateManyMutationInput, BudgetRevisionUncheckedUpdateManyInput>
    /**
     * Filter which BudgetRevisions to update
     */
    where?: BudgetRevisionWhereInput
    /**
     * Limit how many BudgetRevisions to update.
     */
    limit?: number
  }

  /**
   * BudgetRevision updateManyAndReturn
   */
  export type BudgetRevisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * The data used to update BudgetRevisions.
     */
    data: XOR<BudgetRevisionUpdateManyMutationInput, BudgetRevisionUncheckedUpdateManyInput>
    /**
     * Filter which BudgetRevisions to update
     */
    where?: BudgetRevisionWhereInput
    /**
     * Limit how many BudgetRevisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetRevision upsert
   */
  export type BudgetRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetRevision to update in case it exists.
     */
    where: BudgetRevisionWhereUniqueInput
    /**
     * In case the BudgetRevision found by the `where` argument doesn't exist, create a new BudgetRevision with this data.
     */
    create: XOR<BudgetRevisionCreateInput, BudgetRevisionUncheckedCreateInput>
    /**
     * In case the BudgetRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetRevisionUpdateInput, BudgetRevisionUncheckedUpdateInput>
  }

  /**
   * BudgetRevision delete
   */
  export type BudgetRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
    /**
     * Filter which BudgetRevision to delete.
     */
    where: BudgetRevisionWhereUniqueInput
  }

  /**
   * BudgetRevision deleteMany
   */
  export type BudgetRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetRevisions to delete
     */
    where?: BudgetRevisionWhereInput
    /**
     * Limit how many BudgetRevisions to delete.
     */
    limit?: number
  }

  /**
   * BudgetRevision.lines
   */
  export type BudgetRevision$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    where?: BudgetLineWhereInput
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    cursor?: BudgetLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * BudgetRevision without action
   */
  export type BudgetRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRevision
     */
    select?: BudgetRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRevision
     */
    omit?: BudgetRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetRevisionInclude<ExtArgs> | null
  }


  /**
   * Model BudgetLine
   */

  export type AggregateBudgetLine = {
    _count: BudgetLineCountAggregateOutputType | null
    _avg: BudgetLineAvgAggregateOutputType | null
    _sum: BudgetLineSumAggregateOutputType | null
    _min: BudgetLineMinAggregateOutputType | null
    _max: BudgetLineMaxAggregateOutputType | null
  }

  export type BudgetLineAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type BudgetLineSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type BudgetLineMinAggregateOutputType = {
    id: string | null
    budgetRevisionId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    amount: Decimal | null
  }

  export type BudgetLineMaxAggregateOutputType = {
    id: string | null
    budgetRevisionId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    amount: Decimal | null
  }

  export type BudgetLineCountAggregateOutputType = {
    id: number
    budgetRevisionId: number
    analyticAccountId: number
    glAccountId: number
    amount: number
    _all: number
  }


  export type BudgetLineAvgAggregateInputType = {
    amount?: true
  }

  export type BudgetLineSumAggregateInputType = {
    amount?: true
  }

  export type BudgetLineMinAggregateInputType = {
    id?: true
    budgetRevisionId?: true
    analyticAccountId?: true
    glAccountId?: true
    amount?: true
  }

  export type BudgetLineMaxAggregateInputType = {
    id?: true
    budgetRevisionId?: true
    analyticAccountId?: true
    glAccountId?: true
    amount?: true
  }

  export type BudgetLineCountAggregateInputType = {
    id?: true
    budgetRevisionId?: true
    analyticAccountId?: true
    glAccountId?: true
    amount?: true
    _all?: true
  }

  export type BudgetLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetLine to aggregate.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetLines
    **/
    _count?: true | BudgetLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetLineMaxAggregateInputType
  }

  export type GetBudgetLineAggregateType<T extends BudgetLineAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetLine[P]>
      : GetScalarType<T[P], AggregateBudgetLine[P]>
  }




  export type BudgetLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineWhereInput
    orderBy?: BudgetLineOrderByWithAggregationInput | BudgetLineOrderByWithAggregationInput[]
    by: BudgetLineScalarFieldEnum[] | BudgetLineScalarFieldEnum
    having?: BudgetLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetLineCountAggregateInputType | true
    _avg?: BudgetLineAvgAggregateInputType
    _sum?: BudgetLineSumAggregateInputType
    _min?: BudgetLineMinAggregateInputType
    _max?: BudgetLineMaxAggregateInputType
  }

  export type BudgetLineGroupByOutputType = {
    id: string
    budgetRevisionId: string
    analyticAccountId: string
    glAccountId: string | null
    amount: Decimal
    _count: BudgetLineCountAggregateOutputType | null
    _avg: BudgetLineAvgAggregateOutputType | null
    _sum: BudgetLineSumAggregateOutputType | null
    _min: BudgetLineMinAggregateOutputType | null
    _max: BudgetLineMaxAggregateOutputType | null
  }

  type GetBudgetLineGroupByPayload<T extends BudgetLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetLineGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetLineGroupByOutputType[P]>
        }
      >
    >


  export type BudgetLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetRevisionId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    amount?: boolean
    revision?: boolean | BudgetRevisionDefaultArgs<ExtArgs>
    analytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
    gl?: boolean | BudgetLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLine"]>

  export type BudgetLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetRevisionId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    amount?: boolean
    revision?: boolean | BudgetRevisionDefaultArgs<ExtArgs>
    analytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
    gl?: boolean | BudgetLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLine"]>

  export type BudgetLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetRevisionId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    amount?: boolean
    revision?: boolean | BudgetRevisionDefaultArgs<ExtArgs>
    analytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
    gl?: boolean | BudgetLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLine"]>

  export type BudgetLineSelectScalar = {
    id?: boolean
    budgetRevisionId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    amount?: boolean
  }

  export type BudgetLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budgetRevisionId" | "analyticAccountId" | "glAccountId" | "amount", ExtArgs["result"]["budgetLine"]>
  export type BudgetLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revision?: boolean | BudgetRevisionDefaultArgs<ExtArgs>
    analytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
    gl?: boolean | BudgetLine$glArgs<ExtArgs>
  }
  export type BudgetLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revision?: boolean | BudgetRevisionDefaultArgs<ExtArgs>
    analytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
    gl?: boolean | BudgetLine$glArgs<ExtArgs>
  }
  export type BudgetLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revision?: boolean | BudgetRevisionDefaultArgs<ExtArgs>
    analytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
    gl?: boolean | BudgetLine$glArgs<ExtArgs>
  }

  export type $BudgetLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetLine"
    objects: {
      revision: Prisma.$BudgetRevisionPayload<ExtArgs>
      analytic: Prisma.$AnalyticAccountPayload<ExtArgs>
      gl: Prisma.$GLAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetRevisionId: string
      analyticAccountId: string
      glAccountId: string | null
      amount: Prisma.Decimal
    }, ExtArgs["result"]["budgetLine"]>
    composites: {}
  }

  type BudgetLineGetPayload<S extends boolean | null | undefined | BudgetLineDefaultArgs> = $Result.GetResult<Prisma.$BudgetLinePayload, S>

  type BudgetLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetLineCountAggregateInputType | true
    }

  export interface BudgetLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetLine'], meta: { name: 'BudgetLine' } }
    /**
     * Find zero or one BudgetLine that matches the filter.
     * @param {BudgetLineFindUniqueArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetLineFindUniqueArgs>(args: SelectSubset<T, BudgetLineFindUniqueArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BudgetLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetLineFindUniqueOrThrowArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetLineFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineFindFirstArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetLineFindFirstArgs>(args?: SelectSubset<T, BudgetLineFindFirstArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineFindFirstOrThrowArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetLineFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BudgetLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetLines
     * const budgetLines = await prisma.budgetLine.findMany()
     * 
     * // Get first 10 BudgetLines
     * const budgetLines = await prisma.budgetLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetLineWithIdOnly = await prisma.budgetLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetLineFindManyArgs>(args?: SelectSubset<T, BudgetLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BudgetLine.
     * @param {BudgetLineCreateArgs} args - Arguments to create a BudgetLine.
     * @example
     * // Create one BudgetLine
     * const BudgetLine = await prisma.budgetLine.create({
     *   data: {
     *     // ... data to create a BudgetLine
     *   }
     * })
     * 
     */
    create<T extends BudgetLineCreateArgs>(args: SelectSubset<T, BudgetLineCreateArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BudgetLines.
     * @param {BudgetLineCreateManyArgs} args - Arguments to create many BudgetLines.
     * @example
     * // Create many BudgetLines
     * const budgetLine = await prisma.budgetLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetLineCreateManyArgs>(args?: SelectSubset<T, BudgetLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetLines and returns the data saved in the database.
     * @param {BudgetLineCreateManyAndReturnArgs} args - Arguments to create many BudgetLines.
     * @example
     * // Create many BudgetLines
     * const budgetLine = await prisma.budgetLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetLines and only return the `id`
     * const budgetLineWithIdOnly = await prisma.budgetLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetLineCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BudgetLine.
     * @param {BudgetLineDeleteArgs} args - Arguments to delete one BudgetLine.
     * @example
     * // Delete one BudgetLine
     * const BudgetLine = await prisma.budgetLine.delete({
     *   where: {
     *     // ... filter to delete one BudgetLine
     *   }
     * })
     * 
     */
    delete<T extends BudgetLineDeleteArgs>(args: SelectSubset<T, BudgetLineDeleteArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BudgetLine.
     * @param {BudgetLineUpdateArgs} args - Arguments to update one BudgetLine.
     * @example
     * // Update one BudgetLine
     * const budgetLine = await prisma.budgetLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetLineUpdateArgs>(args: SelectSubset<T, BudgetLineUpdateArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BudgetLines.
     * @param {BudgetLineDeleteManyArgs} args - Arguments to filter BudgetLines to delete.
     * @example
     * // Delete a few BudgetLines
     * const { count } = await prisma.budgetLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetLineDeleteManyArgs>(args?: SelectSubset<T, BudgetLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetLines
     * const budgetLine = await prisma.budgetLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetLineUpdateManyArgs>(args: SelectSubset<T, BudgetLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetLines and returns the data updated in the database.
     * @param {BudgetLineUpdateManyAndReturnArgs} args - Arguments to update many BudgetLines.
     * @example
     * // Update many BudgetLines
     * const budgetLine = await prisma.budgetLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BudgetLines and only return the `id`
     * const budgetLineWithIdOnly = await prisma.budgetLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetLineUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BudgetLine.
     * @param {BudgetLineUpsertArgs} args - Arguments to update or create a BudgetLine.
     * @example
     * // Update or create a BudgetLine
     * const budgetLine = await prisma.budgetLine.upsert({
     *   create: {
     *     // ... data to create a BudgetLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetLine we want to update
     *   }
     * })
     */
    upsert<T extends BudgetLineUpsertArgs>(args: SelectSubset<T, BudgetLineUpsertArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BudgetLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineCountArgs} args - Arguments to filter BudgetLines to count.
     * @example
     * // Count the number of BudgetLines
     * const count = await prisma.budgetLine.count({
     *   where: {
     *     // ... the filter for the BudgetLines we want to count
     *   }
     * })
    **/
    count<T extends BudgetLineCountArgs>(
      args?: Subset<T, BudgetLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetLineAggregateArgs>(args: Subset<T, BudgetLineAggregateArgs>): Prisma.PrismaPromise<GetBudgetLineAggregateType<T>>

    /**
     * Group by BudgetLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetLineGroupByArgs['orderBy'] }
        : { orderBy?: BudgetLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetLine model
   */
  readonly fields: BudgetLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    revision<T extends BudgetRevisionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetRevisionDefaultArgs<ExtArgs>>): Prisma__BudgetRevisionClient<$Result.GetResult<Prisma.$BudgetRevisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analytic<T extends AnalyticAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccountDefaultArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gl<T extends BudgetLine$glArgs<ExtArgs> = {}>(args?: Subset<T, BudgetLine$glArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetLine model
   */
  interface BudgetLineFieldRefs {
    readonly id: FieldRef<"BudgetLine", 'String'>
    readonly budgetRevisionId: FieldRef<"BudgetLine", 'String'>
    readonly analyticAccountId: FieldRef<"BudgetLine", 'String'>
    readonly glAccountId: FieldRef<"BudgetLine", 'String'>
    readonly amount: FieldRef<"BudgetLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BudgetLine findUnique
   */
  export type BudgetLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine findUniqueOrThrow
   */
  export type BudgetLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine findFirst
   */
  export type BudgetLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetLines.
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetLines.
     */
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * BudgetLine findFirstOrThrow
   */
  export type BudgetLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetLines.
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetLines.
     */
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * BudgetLine findMany
   */
  export type BudgetLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLines to fetch.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetLines.
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * BudgetLine create
   */
  export type BudgetLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetLine.
     */
    data: XOR<BudgetLineCreateInput, BudgetLineUncheckedCreateInput>
  }

  /**
   * BudgetLine createMany
   */
  export type BudgetLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetLines.
     */
    data: BudgetLineCreateManyInput | BudgetLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetLine createManyAndReturn
   */
  export type BudgetLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * The data used to create many BudgetLines.
     */
    data: BudgetLineCreateManyInput | BudgetLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetLine update
   */
  export type BudgetLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetLine.
     */
    data: XOR<BudgetLineUpdateInput, BudgetLineUncheckedUpdateInput>
    /**
     * Choose, which BudgetLine to update.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine updateMany
   */
  export type BudgetLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetLines.
     */
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyInput>
    /**
     * Filter which BudgetLines to update
     */
    where?: BudgetLineWhereInput
    /**
     * Limit how many BudgetLines to update.
     */
    limit?: number
  }

  /**
   * BudgetLine updateManyAndReturn
   */
  export type BudgetLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * The data used to update BudgetLines.
     */
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyInput>
    /**
     * Filter which BudgetLines to update
     */
    where?: BudgetLineWhereInput
    /**
     * Limit how many BudgetLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetLine upsert
   */
  export type BudgetLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetLine to update in case it exists.
     */
    where: BudgetLineWhereUniqueInput
    /**
     * In case the BudgetLine found by the `where` argument doesn't exist, create a new BudgetLine with this data.
     */
    create: XOR<BudgetLineCreateInput, BudgetLineUncheckedCreateInput>
    /**
     * In case the BudgetLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetLineUpdateInput, BudgetLineUncheckedUpdateInput>
  }

  /**
   * BudgetLine delete
   */
  export type BudgetLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter which BudgetLine to delete.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine deleteMany
   */
  export type BudgetLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetLines to delete
     */
    where?: BudgetLineWhereInput
    /**
     * Limit how many BudgetLines to delete.
     */
    limit?: number
  }

  /**
   * BudgetLine.gl
   */
  export type BudgetLine$glArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    where?: GLAccountWhereInput
  }

  /**
   * BudgetLine without action
   */
  export type BudgetLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
  }


  /**
   * Model AutoAnalyticModel
   */

  export type AggregateAutoAnalyticModel = {
    _count: AutoAnalyticModelCountAggregateOutputType | null
    _avg: AutoAnalyticModelAvgAggregateOutputType | null
    _sum: AutoAnalyticModelSumAggregateOutputType | null
    _min: AutoAnalyticModelMinAggregateOutputType | null
    _max: AutoAnalyticModelMaxAggregateOutputType | null
  }

  export type AutoAnalyticModelAvgAggregateOutputType = {
    priority: number | null
  }

  export type AutoAnalyticModelSumAggregateOutputType = {
    priority: number | null
  }

  export type AutoAnalyticModelMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AutoAnalyticModelMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AutoAnalyticModelCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    priority: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AutoAnalyticModelAvgAggregateInputType = {
    priority?: true
  }

  export type AutoAnalyticModelSumAggregateInputType = {
    priority?: true
  }

  export type AutoAnalyticModelMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    priority?: true
    isActive?: true
    createdAt?: true
  }

  export type AutoAnalyticModelMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    priority?: true
    isActive?: true
    createdAt?: true
  }

  export type AutoAnalyticModelCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    priority?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AutoAnalyticModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoAnalyticModel to aggregate.
     */
    where?: AutoAnalyticModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticModels to fetch.
     */
    orderBy?: AutoAnalyticModelOrderByWithRelationInput | AutoAnalyticModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoAnalyticModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoAnalyticModels
    **/
    _count?: true | AutoAnalyticModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoAnalyticModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoAnalyticModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoAnalyticModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoAnalyticModelMaxAggregateInputType
  }

  export type GetAutoAnalyticModelAggregateType<T extends AutoAnalyticModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoAnalyticModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoAnalyticModel[P]>
      : GetScalarType<T[P], AggregateAutoAnalyticModel[P]>
  }




  export type AutoAnalyticModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticModelWhereInput
    orderBy?: AutoAnalyticModelOrderByWithAggregationInput | AutoAnalyticModelOrderByWithAggregationInput[]
    by: AutoAnalyticModelScalarFieldEnum[] | AutoAnalyticModelScalarFieldEnum
    having?: AutoAnalyticModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoAnalyticModelCountAggregateInputType | true
    _avg?: AutoAnalyticModelAvgAggregateInputType
    _sum?: AutoAnalyticModelSumAggregateInputType
    _min?: AutoAnalyticModelMinAggregateInputType
    _max?: AutoAnalyticModelMaxAggregateInputType
  }

  export type AutoAnalyticModelGroupByOutputType = {
    id: string
    companyId: string
    name: string
    priority: number
    isActive: boolean
    createdAt: Date
    _count: AutoAnalyticModelCountAggregateOutputType | null
    _avg: AutoAnalyticModelAvgAggregateOutputType | null
    _sum: AutoAnalyticModelSumAggregateOutputType | null
    _min: AutoAnalyticModelMinAggregateOutputType | null
    _max: AutoAnalyticModelMaxAggregateOutputType | null
  }

  type GetAutoAnalyticModelGroupByPayload<T extends AutoAnalyticModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoAnalyticModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoAnalyticModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoAnalyticModelGroupByOutputType[P]>
            : GetScalarType<T[P], AutoAnalyticModelGroupByOutputType[P]>
        }
      >
    >


  export type AutoAnalyticModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    rules?: boolean | AutoAnalyticModel$rulesArgs<ExtArgs>
    _count?: boolean | AutoAnalyticModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoAnalyticModel"]>

  export type AutoAnalyticModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoAnalyticModel"]>

  export type AutoAnalyticModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoAnalyticModel"]>

  export type AutoAnalyticModelSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AutoAnalyticModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "priority" | "isActive" | "createdAt", ExtArgs["result"]["autoAnalyticModel"]>
  export type AutoAnalyticModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    rules?: boolean | AutoAnalyticModel$rulesArgs<ExtArgs>
    _count?: boolean | AutoAnalyticModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutoAnalyticModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type AutoAnalyticModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $AutoAnalyticModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoAnalyticModel"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      rules: Prisma.$AutoAnalyticRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      priority: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["autoAnalyticModel"]>
    composites: {}
  }

  type AutoAnalyticModelGetPayload<S extends boolean | null | undefined | AutoAnalyticModelDefaultArgs> = $Result.GetResult<Prisma.$AutoAnalyticModelPayload, S>

  type AutoAnalyticModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoAnalyticModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoAnalyticModelCountAggregateInputType | true
    }

  export interface AutoAnalyticModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoAnalyticModel'], meta: { name: 'AutoAnalyticModel' } }
    /**
     * Find zero or one AutoAnalyticModel that matches the filter.
     * @param {AutoAnalyticModelFindUniqueArgs} args - Arguments to find a AutoAnalyticModel
     * @example
     * // Get one AutoAnalyticModel
     * const autoAnalyticModel = await prisma.autoAnalyticModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoAnalyticModelFindUniqueArgs>(args: SelectSubset<T, AutoAnalyticModelFindUniqueArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoAnalyticModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoAnalyticModelFindUniqueOrThrowArgs} args - Arguments to find a AutoAnalyticModel
     * @example
     * // Get one AutoAnalyticModel
     * const autoAnalyticModel = await prisma.autoAnalyticModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoAnalyticModelFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoAnalyticModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoAnalyticModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticModelFindFirstArgs} args - Arguments to find a AutoAnalyticModel
     * @example
     * // Get one AutoAnalyticModel
     * const autoAnalyticModel = await prisma.autoAnalyticModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoAnalyticModelFindFirstArgs>(args?: SelectSubset<T, AutoAnalyticModelFindFirstArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoAnalyticModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticModelFindFirstOrThrowArgs} args - Arguments to find a AutoAnalyticModel
     * @example
     * // Get one AutoAnalyticModel
     * const autoAnalyticModel = await prisma.autoAnalyticModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoAnalyticModelFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoAnalyticModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoAnalyticModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoAnalyticModels
     * const autoAnalyticModels = await prisma.autoAnalyticModel.findMany()
     * 
     * // Get first 10 AutoAnalyticModels
     * const autoAnalyticModels = await prisma.autoAnalyticModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoAnalyticModelWithIdOnly = await prisma.autoAnalyticModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoAnalyticModelFindManyArgs>(args?: SelectSubset<T, AutoAnalyticModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoAnalyticModel.
     * @param {AutoAnalyticModelCreateArgs} args - Arguments to create a AutoAnalyticModel.
     * @example
     * // Create one AutoAnalyticModel
     * const AutoAnalyticModel = await prisma.autoAnalyticModel.create({
     *   data: {
     *     // ... data to create a AutoAnalyticModel
     *   }
     * })
     * 
     */
    create<T extends AutoAnalyticModelCreateArgs>(args: SelectSubset<T, AutoAnalyticModelCreateArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoAnalyticModels.
     * @param {AutoAnalyticModelCreateManyArgs} args - Arguments to create many AutoAnalyticModels.
     * @example
     * // Create many AutoAnalyticModels
     * const autoAnalyticModel = await prisma.autoAnalyticModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoAnalyticModelCreateManyArgs>(args?: SelectSubset<T, AutoAnalyticModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutoAnalyticModels and returns the data saved in the database.
     * @param {AutoAnalyticModelCreateManyAndReturnArgs} args - Arguments to create many AutoAnalyticModels.
     * @example
     * // Create many AutoAnalyticModels
     * const autoAnalyticModel = await prisma.autoAnalyticModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutoAnalyticModels and only return the `id`
     * const autoAnalyticModelWithIdOnly = await prisma.autoAnalyticModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutoAnalyticModelCreateManyAndReturnArgs>(args?: SelectSubset<T, AutoAnalyticModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutoAnalyticModel.
     * @param {AutoAnalyticModelDeleteArgs} args - Arguments to delete one AutoAnalyticModel.
     * @example
     * // Delete one AutoAnalyticModel
     * const AutoAnalyticModel = await prisma.autoAnalyticModel.delete({
     *   where: {
     *     // ... filter to delete one AutoAnalyticModel
     *   }
     * })
     * 
     */
    delete<T extends AutoAnalyticModelDeleteArgs>(args: SelectSubset<T, AutoAnalyticModelDeleteArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoAnalyticModel.
     * @param {AutoAnalyticModelUpdateArgs} args - Arguments to update one AutoAnalyticModel.
     * @example
     * // Update one AutoAnalyticModel
     * const autoAnalyticModel = await prisma.autoAnalyticModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoAnalyticModelUpdateArgs>(args: SelectSubset<T, AutoAnalyticModelUpdateArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoAnalyticModels.
     * @param {AutoAnalyticModelDeleteManyArgs} args - Arguments to filter AutoAnalyticModels to delete.
     * @example
     * // Delete a few AutoAnalyticModels
     * const { count } = await prisma.autoAnalyticModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoAnalyticModelDeleteManyArgs>(args?: SelectSubset<T, AutoAnalyticModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoAnalyticModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoAnalyticModels
     * const autoAnalyticModel = await prisma.autoAnalyticModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoAnalyticModelUpdateManyArgs>(args: SelectSubset<T, AutoAnalyticModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoAnalyticModels and returns the data updated in the database.
     * @param {AutoAnalyticModelUpdateManyAndReturnArgs} args - Arguments to update many AutoAnalyticModels.
     * @example
     * // Update many AutoAnalyticModels
     * const autoAnalyticModel = await prisma.autoAnalyticModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutoAnalyticModels and only return the `id`
     * const autoAnalyticModelWithIdOnly = await prisma.autoAnalyticModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutoAnalyticModelUpdateManyAndReturnArgs>(args: SelectSubset<T, AutoAnalyticModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutoAnalyticModel.
     * @param {AutoAnalyticModelUpsertArgs} args - Arguments to update or create a AutoAnalyticModel.
     * @example
     * // Update or create a AutoAnalyticModel
     * const autoAnalyticModel = await prisma.autoAnalyticModel.upsert({
     *   create: {
     *     // ... data to create a AutoAnalyticModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoAnalyticModel we want to update
     *   }
     * })
     */
    upsert<T extends AutoAnalyticModelUpsertArgs>(args: SelectSubset<T, AutoAnalyticModelUpsertArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutoAnalyticModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticModelCountArgs} args - Arguments to filter AutoAnalyticModels to count.
     * @example
     * // Count the number of AutoAnalyticModels
     * const count = await prisma.autoAnalyticModel.count({
     *   where: {
     *     // ... the filter for the AutoAnalyticModels we want to count
     *   }
     * })
    **/
    count<T extends AutoAnalyticModelCountArgs>(
      args?: Subset<T, AutoAnalyticModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoAnalyticModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoAnalyticModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoAnalyticModelAggregateArgs>(args: Subset<T, AutoAnalyticModelAggregateArgs>): Prisma.PrismaPromise<GetAutoAnalyticModelAggregateType<T>>

    /**
     * Group by AutoAnalyticModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoAnalyticModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoAnalyticModelGroupByArgs['orderBy'] }
        : { orderBy?: AutoAnalyticModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoAnalyticModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoAnalyticModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoAnalyticModel model
   */
  readonly fields: AutoAnalyticModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoAnalyticModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoAnalyticModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rules<T extends AutoAnalyticModel$rulesArgs<ExtArgs> = {}>(args?: Subset<T, AutoAnalyticModel$rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoAnalyticModel model
   */
  interface AutoAnalyticModelFieldRefs {
    readonly id: FieldRef<"AutoAnalyticModel", 'String'>
    readonly companyId: FieldRef<"AutoAnalyticModel", 'String'>
    readonly name: FieldRef<"AutoAnalyticModel", 'String'>
    readonly priority: FieldRef<"AutoAnalyticModel", 'Int'>
    readonly isActive: FieldRef<"AutoAnalyticModel", 'Boolean'>
    readonly createdAt: FieldRef<"AutoAnalyticModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutoAnalyticModel findUnique
   */
  export type AutoAnalyticModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticModel to fetch.
     */
    where: AutoAnalyticModelWhereUniqueInput
  }

  /**
   * AutoAnalyticModel findUniqueOrThrow
   */
  export type AutoAnalyticModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticModel to fetch.
     */
    where: AutoAnalyticModelWhereUniqueInput
  }

  /**
   * AutoAnalyticModel findFirst
   */
  export type AutoAnalyticModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticModel to fetch.
     */
    where?: AutoAnalyticModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticModels to fetch.
     */
    orderBy?: AutoAnalyticModelOrderByWithRelationInput | AutoAnalyticModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoAnalyticModels.
     */
    cursor?: AutoAnalyticModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoAnalyticModels.
     */
    distinct?: AutoAnalyticModelScalarFieldEnum | AutoAnalyticModelScalarFieldEnum[]
  }

  /**
   * AutoAnalyticModel findFirstOrThrow
   */
  export type AutoAnalyticModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticModel to fetch.
     */
    where?: AutoAnalyticModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticModels to fetch.
     */
    orderBy?: AutoAnalyticModelOrderByWithRelationInput | AutoAnalyticModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoAnalyticModels.
     */
    cursor?: AutoAnalyticModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoAnalyticModels.
     */
    distinct?: AutoAnalyticModelScalarFieldEnum | AutoAnalyticModelScalarFieldEnum[]
  }

  /**
   * AutoAnalyticModel findMany
   */
  export type AutoAnalyticModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticModels to fetch.
     */
    where?: AutoAnalyticModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticModels to fetch.
     */
    orderBy?: AutoAnalyticModelOrderByWithRelationInput | AutoAnalyticModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoAnalyticModels.
     */
    cursor?: AutoAnalyticModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticModels.
     */
    skip?: number
    distinct?: AutoAnalyticModelScalarFieldEnum | AutoAnalyticModelScalarFieldEnum[]
  }

  /**
   * AutoAnalyticModel create
   */
  export type AutoAnalyticModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoAnalyticModel.
     */
    data: XOR<AutoAnalyticModelCreateInput, AutoAnalyticModelUncheckedCreateInput>
  }

  /**
   * AutoAnalyticModel createMany
   */
  export type AutoAnalyticModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoAnalyticModels.
     */
    data: AutoAnalyticModelCreateManyInput | AutoAnalyticModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoAnalyticModel createManyAndReturn
   */
  export type AutoAnalyticModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * The data used to create many AutoAnalyticModels.
     */
    data: AutoAnalyticModelCreateManyInput | AutoAnalyticModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoAnalyticModel update
   */
  export type AutoAnalyticModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoAnalyticModel.
     */
    data: XOR<AutoAnalyticModelUpdateInput, AutoAnalyticModelUncheckedUpdateInput>
    /**
     * Choose, which AutoAnalyticModel to update.
     */
    where: AutoAnalyticModelWhereUniqueInput
  }

  /**
   * AutoAnalyticModel updateMany
   */
  export type AutoAnalyticModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoAnalyticModels.
     */
    data: XOR<AutoAnalyticModelUpdateManyMutationInput, AutoAnalyticModelUncheckedUpdateManyInput>
    /**
     * Filter which AutoAnalyticModels to update
     */
    where?: AutoAnalyticModelWhereInput
    /**
     * Limit how many AutoAnalyticModels to update.
     */
    limit?: number
  }

  /**
   * AutoAnalyticModel updateManyAndReturn
   */
  export type AutoAnalyticModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * The data used to update AutoAnalyticModels.
     */
    data: XOR<AutoAnalyticModelUpdateManyMutationInput, AutoAnalyticModelUncheckedUpdateManyInput>
    /**
     * Filter which AutoAnalyticModels to update
     */
    where?: AutoAnalyticModelWhereInput
    /**
     * Limit how many AutoAnalyticModels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoAnalyticModel upsert
   */
  export type AutoAnalyticModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoAnalyticModel to update in case it exists.
     */
    where: AutoAnalyticModelWhereUniqueInput
    /**
     * In case the AutoAnalyticModel found by the `where` argument doesn't exist, create a new AutoAnalyticModel with this data.
     */
    create: XOR<AutoAnalyticModelCreateInput, AutoAnalyticModelUncheckedCreateInput>
    /**
     * In case the AutoAnalyticModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoAnalyticModelUpdateInput, AutoAnalyticModelUncheckedUpdateInput>
  }

  /**
   * AutoAnalyticModel delete
   */
  export type AutoAnalyticModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
    /**
     * Filter which AutoAnalyticModel to delete.
     */
    where: AutoAnalyticModelWhereUniqueInput
  }

  /**
   * AutoAnalyticModel deleteMany
   */
  export type AutoAnalyticModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoAnalyticModels to delete
     */
    where?: AutoAnalyticModelWhereInput
    /**
     * Limit how many AutoAnalyticModels to delete.
     */
    limit?: number
  }

  /**
   * AutoAnalyticModel.rules
   */
  export type AutoAnalyticModel$rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    where?: AutoAnalyticRuleWhereInput
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    cursor?: AutoAnalyticRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * AutoAnalyticModel without action
   */
  export type AutoAnalyticModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticModel
     */
    select?: AutoAnalyticModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticModel
     */
    omit?: AutoAnalyticModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticModelInclude<ExtArgs> | null
  }


  /**
   * Model AutoAnalyticRule
   */

  export type AggregateAutoAnalyticRule = {
    _count: AutoAnalyticRuleCountAggregateOutputType | null
    _avg: AutoAnalyticRuleAvgAggregateOutputType | null
    _sum: AutoAnalyticRuleSumAggregateOutputType | null
    _min: AutoAnalyticRuleMinAggregateOutputType | null
    _max: AutoAnalyticRuleMaxAggregateOutputType | null
  }

  export type AutoAnalyticRuleAvgAggregateOutputType = {
    rulePriority: number | null
  }

  export type AutoAnalyticRuleSumAggregateOutputType = {
    rulePriority: number | null
  }

  export type AutoAnalyticRuleMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    docType: $Enums.AutoDocType | null
    matchProductId: string | null
    matchCategoryId: string | null
    matchContactId: string | null
    assignAnalyticAccountId: string | null
    rulePriority: number | null
    isActive: boolean | null
  }

  export type AutoAnalyticRuleMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    docType: $Enums.AutoDocType | null
    matchProductId: string | null
    matchCategoryId: string | null
    matchContactId: string | null
    assignAnalyticAccountId: string | null
    rulePriority: number | null
    isActive: boolean | null
  }

  export type AutoAnalyticRuleCountAggregateOutputType = {
    id: number
    modelId: number
    docType: number
    matchProductId: number
    matchCategoryId: number
    matchContactId: number
    assignAnalyticAccountId: number
    rulePriority: number
    isActive: number
    _all: number
  }


  export type AutoAnalyticRuleAvgAggregateInputType = {
    rulePriority?: true
  }

  export type AutoAnalyticRuleSumAggregateInputType = {
    rulePriority?: true
  }

  export type AutoAnalyticRuleMinAggregateInputType = {
    id?: true
    modelId?: true
    docType?: true
    matchProductId?: true
    matchCategoryId?: true
    matchContactId?: true
    assignAnalyticAccountId?: true
    rulePriority?: true
    isActive?: true
  }

  export type AutoAnalyticRuleMaxAggregateInputType = {
    id?: true
    modelId?: true
    docType?: true
    matchProductId?: true
    matchCategoryId?: true
    matchContactId?: true
    assignAnalyticAccountId?: true
    rulePriority?: true
    isActive?: true
  }

  export type AutoAnalyticRuleCountAggregateInputType = {
    id?: true
    modelId?: true
    docType?: true
    matchProductId?: true
    matchCategoryId?: true
    matchContactId?: true
    assignAnalyticAccountId?: true
    rulePriority?: true
    isActive?: true
    _all?: true
  }

  export type AutoAnalyticRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoAnalyticRule to aggregate.
     */
    where?: AutoAnalyticRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticRules to fetch.
     */
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoAnalyticRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoAnalyticRules
    **/
    _count?: true | AutoAnalyticRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoAnalyticRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoAnalyticRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoAnalyticRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoAnalyticRuleMaxAggregateInputType
  }

  export type GetAutoAnalyticRuleAggregateType<T extends AutoAnalyticRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoAnalyticRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoAnalyticRule[P]>
      : GetScalarType<T[P], AggregateAutoAnalyticRule[P]>
  }




  export type AutoAnalyticRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoAnalyticRuleWhereInput
    orderBy?: AutoAnalyticRuleOrderByWithAggregationInput | AutoAnalyticRuleOrderByWithAggregationInput[]
    by: AutoAnalyticRuleScalarFieldEnum[] | AutoAnalyticRuleScalarFieldEnum
    having?: AutoAnalyticRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoAnalyticRuleCountAggregateInputType | true
    _avg?: AutoAnalyticRuleAvgAggregateInputType
    _sum?: AutoAnalyticRuleSumAggregateInputType
    _min?: AutoAnalyticRuleMinAggregateInputType
    _max?: AutoAnalyticRuleMaxAggregateInputType
  }

  export type AutoAnalyticRuleGroupByOutputType = {
    id: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId: string | null
    matchCategoryId: string | null
    matchContactId: string | null
    assignAnalyticAccountId: string
    rulePriority: number
    isActive: boolean
    _count: AutoAnalyticRuleCountAggregateOutputType | null
    _avg: AutoAnalyticRuleAvgAggregateOutputType | null
    _sum: AutoAnalyticRuleSumAggregateOutputType | null
    _min: AutoAnalyticRuleMinAggregateOutputType | null
    _max: AutoAnalyticRuleMaxAggregateOutputType | null
  }

  type GetAutoAnalyticRuleGroupByPayload<T extends AutoAnalyticRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoAnalyticRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoAnalyticRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoAnalyticRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AutoAnalyticRuleGroupByOutputType[P]>
        }
      >
    >


  export type AutoAnalyticRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    docType?: boolean
    matchProductId?: boolean
    matchCategoryId?: boolean
    matchContactId?: boolean
    assignAnalyticAccountId?: boolean
    rulePriority?: boolean
    isActive?: boolean
    model?: boolean | AutoAnalyticModelDefaultArgs<ExtArgs>
    product?: boolean | AutoAnalyticRule$productArgs<ExtArgs>
    category?: boolean | AutoAnalyticRule$categoryArgs<ExtArgs>
    contact?: boolean | AutoAnalyticRule$contactArgs<ExtArgs>
    assignAnalytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoAnalyticRule"]>

  export type AutoAnalyticRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    docType?: boolean
    matchProductId?: boolean
    matchCategoryId?: boolean
    matchContactId?: boolean
    assignAnalyticAccountId?: boolean
    rulePriority?: boolean
    isActive?: boolean
    model?: boolean | AutoAnalyticModelDefaultArgs<ExtArgs>
    product?: boolean | AutoAnalyticRule$productArgs<ExtArgs>
    category?: boolean | AutoAnalyticRule$categoryArgs<ExtArgs>
    contact?: boolean | AutoAnalyticRule$contactArgs<ExtArgs>
    assignAnalytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoAnalyticRule"]>

  export type AutoAnalyticRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    docType?: boolean
    matchProductId?: boolean
    matchCategoryId?: boolean
    matchContactId?: boolean
    assignAnalyticAccountId?: boolean
    rulePriority?: boolean
    isActive?: boolean
    model?: boolean | AutoAnalyticModelDefaultArgs<ExtArgs>
    product?: boolean | AutoAnalyticRule$productArgs<ExtArgs>
    category?: boolean | AutoAnalyticRule$categoryArgs<ExtArgs>
    contact?: boolean | AutoAnalyticRule$contactArgs<ExtArgs>
    assignAnalytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoAnalyticRule"]>

  export type AutoAnalyticRuleSelectScalar = {
    id?: boolean
    modelId?: boolean
    docType?: boolean
    matchProductId?: boolean
    matchCategoryId?: boolean
    matchContactId?: boolean
    assignAnalyticAccountId?: boolean
    rulePriority?: boolean
    isActive?: boolean
  }

  export type AutoAnalyticRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelId" | "docType" | "matchProductId" | "matchCategoryId" | "matchContactId" | "assignAnalyticAccountId" | "rulePriority" | "isActive", ExtArgs["result"]["autoAnalyticRule"]>
  export type AutoAnalyticRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | AutoAnalyticModelDefaultArgs<ExtArgs>
    product?: boolean | AutoAnalyticRule$productArgs<ExtArgs>
    category?: boolean | AutoAnalyticRule$categoryArgs<ExtArgs>
    contact?: boolean | AutoAnalyticRule$contactArgs<ExtArgs>
    assignAnalytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
  }
  export type AutoAnalyticRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | AutoAnalyticModelDefaultArgs<ExtArgs>
    product?: boolean | AutoAnalyticRule$productArgs<ExtArgs>
    category?: boolean | AutoAnalyticRule$categoryArgs<ExtArgs>
    contact?: boolean | AutoAnalyticRule$contactArgs<ExtArgs>
    assignAnalytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
  }
  export type AutoAnalyticRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | AutoAnalyticModelDefaultArgs<ExtArgs>
    product?: boolean | AutoAnalyticRule$productArgs<ExtArgs>
    category?: boolean | AutoAnalyticRule$categoryArgs<ExtArgs>
    contact?: boolean | AutoAnalyticRule$contactArgs<ExtArgs>
    assignAnalytic?: boolean | AnalyticAccountDefaultArgs<ExtArgs>
  }

  export type $AutoAnalyticRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoAnalyticRule"
    objects: {
      model: Prisma.$AutoAnalyticModelPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      assignAnalytic: Prisma.$AnalyticAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      docType: $Enums.AutoDocType
      matchProductId: string | null
      matchCategoryId: string | null
      matchContactId: string | null
      assignAnalyticAccountId: string
      rulePriority: number
      isActive: boolean
    }, ExtArgs["result"]["autoAnalyticRule"]>
    composites: {}
  }

  type AutoAnalyticRuleGetPayload<S extends boolean | null | undefined | AutoAnalyticRuleDefaultArgs> = $Result.GetResult<Prisma.$AutoAnalyticRulePayload, S>

  type AutoAnalyticRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoAnalyticRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoAnalyticRuleCountAggregateInputType | true
    }

  export interface AutoAnalyticRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoAnalyticRule'], meta: { name: 'AutoAnalyticRule' } }
    /**
     * Find zero or one AutoAnalyticRule that matches the filter.
     * @param {AutoAnalyticRuleFindUniqueArgs} args - Arguments to find a AutoAnalyticRule
     * @example
     * // Get one AutoAnalyticRule
     * const autoAnalyticRule = await prisma.autoAnalyticRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoAnalyticRuleFindUniqueArgs>(args: SelectSubset<T, AutoAnalyticRuleFindUniqueArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoAnalyticRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoAnalyticRuleFindUniqueOrThrowArgs} args - Arguments to find a AutoAnalyticRule
     * @example
     * // Get one AutoAnalyticRule
     * const autoAnalyticRule = await prisma.autoAnalyticRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoAnalyticRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoAnalyticRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoAnalyticRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticRuleFindFirstArgs} args - Arguments to find a AutoAnalyticRule
     * @example
     * // Get one AutoAnalyticRule
     * const autoAnalyticRule = await prisma.autoAnalyticRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoAnalyticRuleFindFirstArgs>(args?: SelectSubset<T, AutoAnalyticRuleFindFirstArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoAnalyticRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticRuleFindFirstOrThrowArgs} args - Arguments to find a AutoAnalyticRule
     * @example
     * // Get one AutoAnalyticRule
     * const autoAnalyticRule = await prisma.autoAnalyticRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoAnalyticRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoAnalyticRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoAnalyticRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoAnalyticRules
     * const autoAnalyticRules = await prisma.autoAnalyticRule.findMany()
     * 
     * // Get first 10 AutoAnalyticRules
     * const autoAnalyticRules = await prisma.autoAnalyticRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoAnalyticRuleWithIdOnly = await prisma.autoAnalyticRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoAnalyticRuleFindManyArgs>(args?: SelectSubset<T, AutoAnalyticRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoAnalyticRule.
     * @param {AutoAnalyticRuleCreateArgs} args - Arguments to create a AutoAnalyticRule.
     * @example
     * // Create one AutoAnalyticRule
     * const AutoAnalyticRule = await prisma.autoAnalyticRule.create({
     *   data: {
     *     // ... data to create a AutoAnalyticRule
     *   }
     * })
     * 
     */
    create<T extends AutoAnalyticRuleCreateArgs>(args: SelectSubset<T, AutoAnalyticRuleCreateArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoAnalyticRules.
     * @param {AutoAnalyticRuleCreateManyArgs} args - Arguments to create many AutoAnalyticRules.
     * @example
     * // Create many AutoAnalyticRules
     * const autoAnalyticRule = await prisma.autoAnalyticRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoAnalyticRuleCreateManyArgs>(args?: SelectSubset<T, AutoAnalyticRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutoAnalyticRules and returns the data saved in the database.
     * @param {AutoAnalyticRuleCreateManyAndReturnArgs} args - Arguments to create many AutoAnalyticRules.
     * @example
     * // Create many AutoAnalyticRules
     * const autoAnalyticRule = await prisma.autoAnalyticRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutoAnalyticRules and only return the `id`
     * const autoAnalyticRuleWithIdOnly = await prisma.autoAnalyticRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutoAnalyticRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AutoAnalyticRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutoAnalyticRule.
     * @param {AutoAnalyticRuleDeleteArgs} args - Arguments to delete one AutoAnalyticRule.
     * @example
     * // Delete one AutoAnalyticRule
     * const AutoAnalyticRule = await prisma.autoAnalyticRule.delete({
     *   where: {
     *     // ... filter to delete one AutoAnalyticRule
     *   }
     * })
     * 
     */
    delete<T extends AutoAnalyticRuleDeleteArgs>(args: SelectSubset<T, AutoAnalyticRuleDeleteArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoAnalyticRule.
     * @param {AutoAnalyticRuleUpdateArgs} args - Arguments to update one AutoAnalyticRule.
     * @example
     * // Update one AutoAnalyticRule
     * const autoAnalyticRule = await prisma.autoAnalyticRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoAnalyticRuleUpdateArgs>(args: SelectSubset<T, AutoAnalyticRuleUpdateArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoAnalyticRules.
     * @param {AutoAnalyticRuleDeleteManyArgs} args - Arguments to filter AutoAnalyticRules to delete.
     * @example
     * // Delete a few AutoAnalyticRules
     * const { count } = await prisma.autoAnalyticRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoAnalyticRuleDeleteManyArgs>(args?: SelectSubset<T, AutoAnalyticRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoAnalyticRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoAnalyticRules
     * const autoAnalyticRule = await prisma.autoAnalyticRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoAnalyticRuleUpdateManyArgs>(args: SelectSubset<T, AutoAnalyticRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoAnalyticRules and returns the data updated in the database.
     * @param {AutoAnalyticRuleUpdateManyAndReturnArgs} args - Arguments to update many AutoAnalyticRules.
     * @example
     * // Update many AutoAnalyticRules
     * const autoAnalyticRule = await prisma.autoAnalyticRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutoAnalyticRules and only return the `id`
     * const autoAnalyticRuleWithIdOnly = await prisma.autoAnalyticRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutoAnalyticRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, AutoAnalyticRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutoAnalyticRule.
     * @param {AutoAnalyticRuleUpsertArgs} args - Arguments to update or create a AutoAnalyticRule.
     * @example
     * // Update or create a AutoAnalyticRule
     * const autoAnalyticRule = await prisma.autoAnalyticRule.upsert({
     *   create: {
     *     // ... data to create a AutoAnalyticRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoAnalyticRule we want to update
     *   }
     * })
     */
    upsert<T extends AutoAnalyticRuleUpsertArgs>(args: SelectSubset<T, AutoAnalyticRuleUpsertArgs<ExtArgs>>): Prisma__AutoAnalyticRuleClient<$Result.GetResult<Prisma.$AutoAnalyticRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutoAnalyticRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticRuleCountArgs} args - Arguments to filter AutoAnalyticRules to count.
     * @example
     * // Count the number of AutoAnalyticRules
     * const count = await prisma.autoAnalyticRule.count({
     *   where: {
     *     // ... the filter for the AutoAnalyticRules we want to count
     *   }
     * })
    **/
    count<T extends AutoAnalyticRuleCountArgs>(
      args?: Subset<T, AutoAnalyticRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoAnalyticRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoAnalyticRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoAnalyticRuleAggregateArgs>(args: Subset<T, AutoAnalyticRuleAggregateArgs>): Prisma.PrismaPromise<GetAutoAnalyticRuleAggregateType<T>>

    /**
     * Group by AutoAnalyticRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoAnalyticRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoAnalyticRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoAnalyticRuleGroupByArgs['orderBy'] }
        : { orderBy?: AutoAnalyticRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoAnalyticRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoAnalyticRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoAnalyticRule model
   */
  readonly fields: AutoAnalyticRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoAnalyticRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoAnalyticRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends AutoAnalyticModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutoAnalyticModelDefaultArgs<ExtArgs>>): Prisma__AutoAnalyticModelClient<$Result.GetResult<Prisma.$AutoAnalyticModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends AutoAnalyticRule$productArgs<ExtArgs> = {}>(args?: Subset<T, AutoAnalyticRule$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends AutoAnalyticRule$categoryArgs<ExtArgs> = {}>(args?: Subset<T, AutoAnalyticRule$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends AutoAnalyticRule$contactArgs<ExtArgs> = {}>(args?: Subset<T, AutoAnalyticRule$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignAnalytic<T extends AnalyticAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticAccountDefaultArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoAnalyticRule model
   */
  interface AutoAnalyticRuleFieldRefs {
    readonly id: FieldRef<"AutoAnalyticRule", 'String'>
    readonly modelId: FieldRef<"AutoAnalyticRule", 'String'>
    readonly docType: FieldRef<"AutoAnalyticRule", 'AutoDocType'>
    readonly matchProductId: FieldRef<"AutoAnalyticRule", 'String'>
    readonly matchCategoryId: FieldRef<"AutoAnalyticRule", 'String'>
    readonly matchContactId: FieldRef<"AutoAnalyticRule", 'String'>
    readonly assignAnalyticAccountId: FieldRef<"AutoAnalyticRule", 'String'>
    readonly rulePriority: FieldRef<"AutoAnalyticRule", 'Int'>
    readonly isActive: FieldRef<"AutoAnalyticRule", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AutoAnalyticRule findUnique
   */
  export type AutoAnalyticRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticRule to fetch.
     */
    where: AutoAnalyticRuleWhereUniqueInput
  }

  /**
   * AutoAnalyticRule findUniqueOrThrow
   */
  export type AutoAnalyticRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticRule to fetch.
     */
    where: AutoAnalyticRuleWhereUniqueInput
  }

  /**
   * AutoAnalyticRule findFirst
   */
  export type AutoAnalyticRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticRule to fetch.
     */
    where?: AutoAnalyticRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticRules to fetch.
     */
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoAnalyticRules.
     */
    cursor?: AutoAnalyticRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoAnalyticRules.
     */
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * AutoAnalyticRule findFirstOrThrow
   */
  export type AutoAnalyticRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticRule to fetch.
     */
    where?: AutoAnalyticRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticRules to fetch.
     */
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoAnalyticRules.
     */
    cursor?: AutoAnalyticRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoAnalyticRules.
     */
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * AutoAnalyticRule findMany
   */
  export type AutoAnalyticRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoAnalyticRules to fetch.
     */
    where?: AutoAnalyticRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoAnalyticRules to fetch.
     */
    orderBy?: AutoAnalyticRuleOrderByWithRelationInput | AutoAnalyticRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoAnalyticRules.
     */
    cursor?: AutoAnalyticRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoAnalyticRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoAnalyticRules.
     */
    skip?: number
    distinct?: AutoAnalyticRuleScalarFieldEnum | AutoAnalyticRuleScalarFieldEnum[]
  }

  /**
   * AutoAnalyticRule create
   */
  export type AutoAnalyticRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoAnalyticRule.
     */
    data: XOR<AutoAnalyticRuleCreateInput, AutoAnalyticRuleUncheckedCreateInput>
  }

  /**
   * AutoAnalyticRule createMany
   */
  export type AutoAnalyticRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoAnalyticRules.
     */
    data: AutoAnalyticRuleCreateManyInput | AutoAnalyticRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoAnalyticRule createManyAndReturn
   */
  export type AutoAnalyticRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * The data used to create many AutoAnalyticRules.
     */
    data: AutoAnalyticRuleCreateManyInput | AutoAnalyticRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoAnalyticRule update
   */
  export type AutoAnalyticRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoAnalyticRule.
     */
    data: XOR<AutoAnalyticRuleUpdateInput, AutoAnalyticRuleUncheckedUpdateInput>
    /**
     * Choose, which AutoAnalyticRule to update.
     */
    where: AutoAnalyticRuleWhereUniqueInput
  }

  /**
   * AutoAnalyticRule updateMany
   */
  export type AutoAnalyticRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoAnalyticRules.
     */
    data: XOR<AutoAnalyticRuleUpdateManyMutationInput, AutoAnalyticRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutoAnalyticRules to update
     */
    where?: AutoAnalyticRuleWhereInput
    /**
     * Limit how many AutoAnalyticRules to update.
     */
    limit?: number
  }

  /**
   * AutoAnalyticRule updateManyAndReturn
   */
  export type AutoAnalyticRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * The data used to update AutoAnalyticRules.
     */
    data: XOR<AutoAnalyticRuleUpdateManyMutationInput, AutoAnalyticRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutoAnalyticRules to update
     */
    where?: AutoAnalyticRuleWhereInput
    /**
     * Limit how many AutoAnalyticRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoAnalyticRule upsert
   */
  export type AutoAnalyticRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoAnalyticRule to update in case it exists.
     */
    where: AutoAnalyticRuleWhereUniqueInput
    /**
     * In case the AutoAnalyticRule found by the `where` argument doesn't exist, create a new AutoAnalyticRule with this data.
     */
    create: XOR<AutoAnalyticRuleCreateInput, AutoAnalyticRuleUncheckedCreateInput>
    /**
     * In case the AutoAnalyticRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoAnalyticRuleUpdateInput, AutoAnalyticRuleUncheckedUpdateInput>
  }

  /**
   * AutoAnalyticRule delete
   */
  export type AutoAnalyticRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
    /**
     * Filter which AutoAnalyticRule to delete.
     */
    where: AutoAnalyticRuleWhereUniqueInput
  }

  /**
   * AutoAnalyticRule deleteMany
   */
  export type AutoAnalyticRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoAnalyticRules to delete
     */
    where?: AutoAnalyticRuleWhereInput
    /**
     * Limit how many AutoAnalyticRules to delete.
     */
    limit?: number
  }

  /**
   * AutoAnalyticRule.product
   */
  export type AutoAnalyticRule$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * AutoAnalyticRule.category
   */
  export type AutoAnalyticRule$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * AutoAnalyticRule.contact
   */
  export type AutoAnalyticRule$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * AutoAnalyticRule without action
   */
  export type AutoAnalyticRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoAnalyticRule
     */
    select?: AutoAnalyticRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoAnalyticRule
     */
    omit?: AutoAnalyticRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoAnalyticRuleInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    poNo: string | null
    vendorId: string | null
    orderDate: Date | null
    status: $Enums.OrderStatus | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    poNo: string | null
    vendorId: string | null
    orderDate: Date | null
    status: $Enums.OrderStatus | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    companyId: number
    poNo: number
    vendorId: number
    orderDate: number
    status: number
    currency: number
    notes: number
    createdAt: number
    _all: number
  }


  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    companyId?: true
    poNo?: true
    vendorId?: true
    orderDate?: true
    status?: true
    currency?: true
    notes?: true
    createdAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    companyId?: true
    poNo?: true
    vendorId?: true
    orderDate?: true
    status?: true
    currency?: true
    notes?: true
    createdAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    companyId?: true
    poNo?: true
    vendorId?: true
    orderDate?: true
    status?: true
    currency?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    companyId: string
    poNo: string
    vendorId: string
    orderDate: Date
    status: $Enums.OrderStatus
    currency: string
    notes: string | null
    createdAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    poNo?: boolean
    vendorId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    bills?: boolean | PurchaseOrder$billsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    poNo?: boolean
    vendorId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    poNo?: boolean
    vendorId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    companyId?: boolean
    poNo?: boolean
    vendorId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "poNo" | "vendorId" | "orderDate" | "status" | "currency" | "notes" | "createdAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    bills?: boolean | PurchaseOrder$billsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      vendor: Prisma.$ContactPayload<ExtArgs>
      lines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      bills: Prisma.$VendorBillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      poNo: string
      vendorId: string
      orderDate: Date
      status: $Enums.OrderStatus
      currency: string
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends PurchaseOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bills<T extends PurchaseOrder$billsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly companyId: FieldRef<"PurchaseOrder", 'String'>
    readonly poNo: FieldRef<"PurchaseOrder", 'String'>
    readonly vendorId: FieldRef<"PurchaseOrder", 'String'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly status: FieldRef<"PurchaseOrder", 'OrderStatus'>
    readonly currency: FieldRef<"PurchaseOrder", 'String'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.lines
   */
  export type PurchaseOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.bills
   */
  export type PurchaseOrder$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    where?: VendorBillWhereInput
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    cursor?: VendorBillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderLine
   */

  export type AggregatePurchaseOrderLine = {
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  export type PurchaseOrderLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseOrderLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseOrderLineMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    analyticAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseOrderLineMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    analyticAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseOrderLineCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    analyticAccountId: number
    description: number
    qty: number
    unitPrice: number
    taxRate: number
    lineTotal: number
    _all: number
  }


  export type PurchaseOrderLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type PurchaseOrderLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type PurchaseOrderLineMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    analyticAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type PurchaseOrderLineMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    analyticAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type PurchaseOrderLineCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    analyticAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
    _all?: true
  }

  export type PurchaseOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLine to aggregate.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderLines
    **/
    _count?: true | PurchaseOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type GetPurchaseOrderLineAggregateType<T extends PurchaseOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
  }




  export type PurchaseOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithAggregationInput | PurchaseOrderLineOrderByWithAggregationInput[]
    by: PurchaseOrderLineScalarFieldEnum[] | PurchaseOrderLineScalarFieldEnum
    having?: PurchaseOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderLineCountAggregateInputType | true
    _avg?: PurchaseOrderLineAvgAggregateInputType
    _sum?: PurchaseOrderLineSumAggregateInputType
    _min?: PurchaseOrderLineMinAggregateInputType
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type PurchaseOrderLineGroupByOutputType = {
    id: string
    purchaseOrderId: string
    productId: string
    analyticAccountId: string | null
    description: string | null
    qty: Decimal
    unitPrice: Decimal
    taxRate: Decimal
    lineTotal: Decimal
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  type GetPurchaseOrderLineGroupByPayload<T extends PurchaseOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | PurchaseOrderLine$analyticArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | PurchaseOrderLine$analyticArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | PurchaseOrderLine$analyticArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
  }

  export type PurchaseOrderLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseOrderId" | "productId" | "analyticAccountId" | "description" | "qty" | "unitPrice" | "taxRate" | "lineTotal", ExtArgs["result"]["purchaseOrderLine"]>
  export type PurchaseOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | PurchaseOrderLine$analyticArgs<ExtArgs>
  }
  export type PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | PurchaseOrderLine$analyticArgs<ExtArgs>
  }
  export type PurchaseOrderLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | PurchaseOrderLine$analyticArgs<ExtArgs>
  }

  export type $PurchaseOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderLine"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      analytic: Prisma.$AnalyticAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      productId: string
      analyticAccountId: string | null
      description: string | null
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      taxRate: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["purchaseOrderLine"]>
    composites: {}
  }

  type PurchaseOrderLineGetPayload<S extends boolean | null | undefined | PurchaseOrderLineDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderLinePayload, S>

  type PurchaseOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderLineCountAggregateInputType | true
    }

  export interface PurchaseOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderLine'], meta: { name: 'PurchaseOrderLine' } }
    /**
     * Find zero or one PurchaseOrderLine that matches the filter.
     * @param {PurchaseOrderLineFindUniqueArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderLineFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderLineFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderLineFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
     * 
     * // Get first 10 PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderLineFindManyArgs>(args?: SelectSubset<T, PurchaseOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderLine.
     * @param {PurchaseOrderLineCreateArgs} args - Arguments to create a PurchaseOrderLine.
     * @example
     * // Create one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.create({
     *   data: {
     *     // ... data to create a PurchaseOrderLine
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderLineCreateArgs>(args: SelectSubset<T, PurchaseOrderLineCreateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderLines.
     * @param {PurchaseOrderLineCreateManyArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderLineCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderLines and returns the data saved in the database.
     * @param {PurchaseOrderLineCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderLines and only return the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderLine.
     * @param {PurchaseOrderLineDeleteArgs} args - Arguments to delete one PurchaseOrderLine.
     * @example
     * // Delete one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderLine
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderLineDeleteArgs>(args: SelectSubset<T, PurchaseOrderLineDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpdateArgs} args - Arguments to update one PurchaseOrderLine.
     * @example
     * // Update one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderLineUpdateArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderLines.
     * @param {PurchaseOrderLineDeleteManyArgs} args - Arguments to filter PurchaseOrderLines to delete.
     * @example
     * // Delete a few PurchaseOrderLines
     * const { count } = await prisma.purchaseOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderLineDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderLineUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLines and returns the data updated in the database.
     * @param {PurchaseOrderLineUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderLines.
     * @example
     * // Update many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderLines and only return the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderLineUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpsertArgs} args - Arguments to update or create a PurchaseOrderLine.
     * @example
     * // Update or create a PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderLineUpsertArgs>(args: SelectSubset<T, PurchaseOrderLineUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineCountArgs} args - Arguments to filter PurchaseOrderLines to count.
     * @example
     * // Count the number of PurchaseOrderLines
     * const count = await prisma.purchaseOrderLine.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderLines we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderLineCountArgs>(
      args?: Subset<T, PurchaseOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderLineAggregateArgs>(args: Subset<T, PurchaseOrderLineAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderLineAggregateType<T>>

    /**
     * Group by PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderLine model
   */
  readonly fields: PurchaseOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analytic<T extends PurchaseOrderLine$analyticArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLine$analyticArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderLine model
   */
  interface PurchaseOrderLineFieldRefs {
    readonly id: FieldRef<"PurchaseOrderLine", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderLine", 'String'>
    readonly productId: FieldRef<"PurchaseOrderLine", 'String'>
    readonly analyticAccountId: FieldRef<"PurchaseOrderLine", 'String'>
    readonly description: FieldRef<"PurchaseOrderLine", 'String'>
    readonly qty: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly unitPrice: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly taxRate: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly lineTotal: FieldRef<"PurchaseOrderLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderLine findUnique
   */
  export type PurchaseOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findUniqueOrThrow
   */
  export type PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findFirst
   */
  export type PurchaseOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findFirstOrThrow
   */
  export type PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findMany
   */
  export type PurchaseOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLines to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine create
   */
  export type PurchaseOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
  }

  /**
   * PurchaseOrderLine createMany
   */
  export type PurchaseOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderLine createManyAndReturn
   */
  export type PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLine update
   */
  export type PurchaseOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderLine to update.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine updateMany
   */
  export type PurchaseOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderLines.
     */
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLines to update
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLine updateManyAndReturn
   */
  export type PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderLines.
     */
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLines to update
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLine upsert
   */
  export type PurchaseOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderLine to update in case it exists.
     */
    where: PurchaseOrderLineWhereUniqueInput
    /**
     * In case the PurchaseOrderLine found by the `where` argument doesn't exist, create a new PurchaseOrderLine with this data.
     */
    create: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
    /**
     * In case the PurchaseOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderLine delete
   */
  export type PurchaseOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderLine to delete.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine deleteMany
   */
  export type PurchaseOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLines to delete
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLine.analytic
   */
  export type PurchaseOrderLine$analyticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
  }

  /**
   * PurchaseOrderLine without action
   */
  export type PurchaseOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model SalesOrder
   */

  export type AggregateSalesOrder = {
    _count: SalesOrderCountAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  export type SalesOrderMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    soNo: string | null
    customerId: string | null
    orderDate: Date | null
    status: $Enums.OrderStatus | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type SalesOrderMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    soNo: string | null
    customerId: string | null
    orderDate: Date | null
    status: $Enums.OrderStatus | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type SalesOrderCountAggregateOutputType = {
    id: number
    companyId: number
    soNo: number
    customerId: number
    orderDate: number
    status: number
    currency: number
    notes: number
    createdAt: number
    _all: number
  }


  export type SalesOrderMinAggregateInputType = {
    id?: true
    companyId?: true
    soNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    currency?: true
    notes?: true
    createdAt?: true
  }

  export type SalesOrderMaxAggregateInputType = {
    id?: true
    companyId?: true
    soNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    currency?: true
    notes?: true
    createdAt?: true
  }

  export type SalesOrderCountAggregateInputType = {
    id?: true
    companyId?: true
    soNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    currency?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type SalesOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrder to aggregate.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrders
    **/
    _count?: true | SalesOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderMaxAggregateInputType
  }

  export type GetSalesOrderAggregateType<T extends SalesOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrder[P]>
      : GetScalarType<T[P], AggregateSalesOrder[P]>
  }




  export type SalesOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithAggregationInput | SalesOrderOrderByWithAggregationInput[]
    by: SalesOrderScalarFieldEnum[] | SalesOrderScalarFieldEnum
    having?: SalesOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderCountAggregateInputType | true
    _min?: SalesOrderMinAggregateInputType
    _max?: SalesOrderMaxAggregateInputType
  }

  export type SalesOrderGroupByOutputType = {
    id: string
    companyId: string
    soNo: string
    customerId: string
    orderDate: Date
    status: $Enums.OrderStatus
    currency: string
    notes: string | null
    createdAt: Date
    _count: SalesOrderCountAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  type GetSalesOrderGroupByPayload<T extends SalesOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    soNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    lines?: boolean | SalesOrder$linesArgs<ExtArgs>
    invoices?: boolean | SalesOrder$invoicesArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    soNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    soNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectScalar = {
    id?: boolean
    companyId?: boolean
    soNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type SalesOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "soNo" | "customerId" | "orderDate" | "status" | "currency" | "notes" | "createdAt", ExtArgs["result"]["salesOrder"]>
  export type SalesOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    lines?: boolean | SalesOrder$linesArgs<ExtArgs>
    invoices?: boolean | SalesOrder$invoicesArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type SalesOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $SalesOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOrder"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      customer: Prisma.$ContactPayload<ExtArgs>
      lines: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      invoices: Prisma.$CustomerInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      soNo: string
      customerId: string
      orderDate: Date
      status: $Enums.OrderStatus
      currency: string
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["salesOrder"]>
    composites: {}
  }

  type SalesOrderGetPayload<S extends boolean | null | undefined | SalesOrderDefaultArgs> = $Result.GetResult<Prisma.$SalesOrderPayload, S>

  type SalesOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesOrderCountAggregateInputType | true
    }

  export interface SalesOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOrder'], meta: { name: 'SalesOrder' } }
    /**
     * Find zero or one SalesOrder that matches the filter.
     * @param {SalesOrderFindUniqueArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOrderFindUniqueArgs>(args: SelectSubset<T, SalesOrderFindUniqueArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesOrderFindUniqueOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOrderFindFirstArgs>(args?: SelectSubset<T, SalesOrderFindFirstArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany()
     * 
     * // Get first 10 SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesOrderFindManyArgs>(args?: SelectSubset<T, SalesOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesOrder.
     * @param {SalesOrderCreateArgs} args - Arguments to create a SalesOrder.
     * @example
     * // Create one SalesOrder
     * const SalesOrder = await prisma.salesOrder.create({
     *   data: {
     *     // ... data to create a SalesOrder
     *   }
     * })
     * 
     */
    create<T extends SalesOrderCreateArgs>(args: SelectSubset<T, SalesOrderCreateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesOrders.
     * @param {SalesOrderCreateManyArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOrderCreateManyArgs>(args?: SelectSubset<T, SalesOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOrders and returns the data saved in the database.
     * @param {SalesOrderCreateManyAndReturnArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOrders and only return the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesOrder.
     * @param {SalesOrderDeleteArgs} args - Arguments to delete one SalesOrder.
     * @example
     * // Delete one SalesOrder
     * const SalesOrder = await prisma.salesOrder.delete({
     *   where: {
     *     // ... filter to delete one SalesOrder
     *   }
     * })
     * 
     */
    delete<T extends SalesOrderDeleteArgs>(args: SelectSubset<T, SalesOrderDeleteArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesOrder.
     * @param {SalesOrderUpdateArgs} args - Arguments to update one SalesOrder.
     * @example
     * // Update one SalesOrder
     * const salesOrder = await prisma.salesOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOrderUpdateArgs>(args: SelectSubset<T, SalesOrderUpdateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesOrders.
     * @param {SalesOrderDeleteManyArgs} args - Arguments to filter SalesOrders to delete.
     * @example
     * // Delete a few SalesOrders
     * const { count } = await prisma.salesOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOrderDeleteManyArgs>(args?: SelectSubset<T, SalesOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOrderUpdateManyArgs>(args: SelectSubset<T, SalesOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders and returns the data updated in the database.
     * @param {SalesOrderUpdateManyAndReturnArgs} args - Arguments to update many SalesOrders.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesOrders and only return the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesOrder.
     * @param {SalesOrderUpsertArgs} args - Arguments to update or create a SalesOrder.
     * @example
     * // Update or create a SalesOrder
     * const salesOrder = await prisma.salesOrder.upsert({
     *   create: {
     *     // ... data to create a SalesOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrder we want to update
     *   }
     * })
     */
    upsert<T extends SalesOrderUpsertArgs>(args: SelectSubset<T, SalesOrderUpsertArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderCountArgs} args - Arguments to filter SalesOrders to count.
     * @example
     * // Count the number of SalesOrders
     * const count = await prisma.salesOrder.count({
     *   where: {
     *     // ... the filter for the SalesOrders we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderCountArgs>(
      args?: Subset<T, SalesOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderAggregateArgs>(args: Subset<T, SalesOrderAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderAggregateType<T>>

    /**
     * Group by SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOrder model
   */
  readonly fields: SalesOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends SalesOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends SalesOrder$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOrder model
   */
  interface SalesOrderFieldRefs {
    readonly id: FieldRef<"SalesOrder", 'String'>
    readonly companyId: FieldRef<"SalesOrder", 'String'>
    readonly soNo: FieldRef<"SalesOrder", 'String'>
    readonly customerId: FieldRef<"SalesOrder", 'String'>
    readonly orderDate: FieldRef<"SalesOrder", 'DateTime'>
    readonly status: FieldRef<"SalesOrder", 'OrderStatus'>
    readonly currency: FieldRef<"SalesOrder", 'String'>
    readonly notes: FieldRef<"SalesOrder", 'String'>
    readonly createdAt: FieldRef<"SalesOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesOrder findUnique
   */
  export type SalesOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findUniqueOrThrow
   */
  export type SalesOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findFirst
   */
  export type SalesOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findFirstOrThrow
   */
  export type SalesOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findMany
   */
  export type SalesOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrders to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder create
   */
  export type SalesOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOrder.
     */
    data: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
  }

  /**
   * SalesOrder createMany
   */
  export type SalesOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesOrder createManyAndReturn
   */
  export type SalesOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrder update
   */
  export type SalesOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOrder.
     */
    data: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
    /**
     * Choose, which SalesOrder to update.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder updateMany
   */
  export type SalesOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOrders.
     */
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrders to update
     */
    where?: SalesOrderWhereInput
    /**
     * Limit how many SalesOrders to update.
     */
    limit?: number
  }

  /**
   * SalesOrder updateManyAndReturn
   */
  export type SalesOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * The data used to update SalesOrders.
     */
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrders to update
     */
    where?: SalesOrderWhereInput
    /**
     * Limit how many SalesOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrder upsert
   */
  export type SalesOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOrder to update in case it exists.
     */
    where: SalesOrderWhereUniqueInput
    /**
     * In case the SalesOrder found by the `where` argument doesn't exist, create a new SalesOrder with this data.
     */
    create: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
    /**
     * In case the SalesOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
  }

  /**
   * SalesOrder delete
   */
  export type SalesOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter which SalesOrder to delete.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder deleteMany
   */
  export type SalesOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrders to delete
     */
    where?: SalesOrderWhereInput
    /**
     * Limit how many SalesOrders to delete.
     */
    limit?: number
  }

  /**
   * SalesOrder.lines
   */
  export type SalesOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrder.invoices
   */
  export type SalesOrder$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    where?: CustomerInvoiceWhereInput
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    cursor?: CustomerInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * SalesOrder without action
   */
  export type SalesOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
  }


  /**
   * Model SalesOrderLine
   */

  export type AggregateSalesOrderLine = {
    _count: SalesOrderLineCountAggregateOutputType | null
    _avg: SalesOrderLineAvgAggregateOutputType | null
    _sum: SalesOrderLineSumAggregateOutputType | null
    _min: SalesOrderLineMinAggregateOutputType | null
    _max: SalesOrderLineMaxAggregateOutputType | null
  }

  export type SalesOrderLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineMinAggregateOutputType = {
    id: string | null
    salesOrderId: string | null
    productId: string | null
    analyticAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineMaxAggregateOutputType = {
    id: string | null
    salesOrderId: string | null
    productId: string | null
    analyticAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineCountAggregateOutputType = {
    id: number
    salesOrderId: number
    productId: number
    analyticAccountId: number
    description: number
    qty: number
    unitPrice: number
    taxRate: number
    lineTotal: number
    _all: number
  }


  export type SalesOrderLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type SalesOrderLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type SalesOrderLineMinAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    analyticAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type SalesOrderLineMaxAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    analyticAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type SalesOrderLineCountAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    analyticAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
    _all?: true
  }

  export type SalesOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrderLine to aggregate.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrderLines
    **/
    _count?: true | SalesOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderLineMaxAggregateInputType
  }

  export type GetSalesOrderLineAggregateType<T extends SalesOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrderLine[P]>
      : GetScalarType<T[P], AggregateSalesOrderLine[P]>
  }




  export type SalesOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithAggregationInput | SalesOrderLineOrderByWithAggregationInput[]
    by: SalesOrderLineScalarFieldEnum[] | SalesOrderLineScalarFieldEnum
    having?: SalesOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderLineCountAggregateInputType | true
    _avg?: SalesOrderLineAvgAggregateInputType
    _sum?: SalesOrderLineSumAggregateInputType
    _min?: SalesOrderLineMinAggregateInputType
    _max?: SalesOrderLineMaxAggregateInputType
  }

  export type SalesOrderLineGroupByOutputType = {
    id: string
    salesOrderId: string
    productId: string
    analyticAccountId: string | null
    description: string | null
    qty: Decimal
    unitPrice: Decimal
    taxRate: Decimal
    lineTotal: Decimal
    _count: SalesOrderLineCountAggregateOutputType | null
    _avg: SalesOrderLineAvgAggregateOutputType | null
    _sum: SalesOrderLineSumAggregateOutputType | null
    _min: SalesOrderLineMinAggregateOutputType | null
    _max: SalesOrderLineMaxAggregateOutputType | null
  }

  type GetSalesOrderLineGroupByPayload<T extends SalesOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | SalesOrderLine$analyticArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | SalesOrderLine$analyticArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | SalesOrderLine$analyticArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectScalar = {
    id?: boolean
    salesOrderId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
  }

  export type SalesOrderLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salesOrderId" | "productId" | "analyticAccountId" | "description" | "qty" | "unitPrice" | "taxRate" | "lineTotal", ExtArgs["result"]["salesOrderLine"]>
  export type SalesOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | SalesOrderLine$analyticArgs<ExtArgs>
  }
  export type SalesOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | SalesOrderLine$analyticArgs<ExtArgs>
  }
  export type SalesOrderLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    analytic?: boolean | SalesOrderLine$analyticArgs<ExtArgs>
  }

  export type $SalesOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOrderLine"
    objects: {
      salesOrder: Prisma.$SalesOrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      analytic: Prisma.$AnalyticAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      salesOrderId: string
      productId: string
      analyticAccountId: string | null
      description: string | null
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      taxRate: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["salesOrderLine"]>
    composites: {}
  }

  type SalesOrderLineGetPayload<S extends boolean | null | undefined | SalesOrderLineDefaultArgs> = $Result.GetResult<Prisma.$SalesOrderLinePayload, S>

  type SalesOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesOrderLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesOrderLineCountAggregateInputType | true
    }

  export interface SalesOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOrderLine'], meta: { name: 'SalesOrderLine' } }
    /**
     * Find zero or one SalesOrderLine that matches the filter.
     * @param {SalesOrderLineFindUniqueArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOrderLineFindUniqueArgs>(args: SelectSubset<T, SalesOrderLineFindUniqueArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesOrderLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesOrderLineFindUniqueOrThrowArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindFirstArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOrderLineFindFirstArgs>(args?: SelectSubset<T, SalesOrderLineFindFirstArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindFirstOrThrowArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrderLines
     * const salesOrderLines = await prisma.salesOrderLine.findMany()
     * 
     * // Get first 10 SalesOrderLines
     * const salesOrderLines = await prisma.salesOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOrderLineWithIdOnly = await prisma.salesOrderLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesOrderLineFindManyArgs>(args?: SelectSubset<T, SalesOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesOrderLine.
     * @param {SalesOrderLineCreateArgs} args - Arguments to create a SalesOrderLine.
     * @example
     * // Create one SalesOrderLine
     * const SalesOrderLine = await prisma.salesOrderLine.create({
     *   data: {
     *     // ... data to create a SalesOrderLine
     *   }
     * })
     * 
     */
    create<T extends SalesOrderLineCreateArgs>(args: SelectSubset<T, SalesOrderLineCreateArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesOrderLines.
     * @param {SalesOrderLineCreateManyArgs} args - Arguments to create many SalesOrderLines.
     * @example
     * // Create many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOrderLineCreateManyArgs>(args?: SelectSubset<T, SalesOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOrderLines and returns the data saved in the database.
     * @param {SalesOrderLineCreateManyAndReturnArgs} args - Arguments to create many SalesOrderLines.
     * @example
     * // Create many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOrderLines and only return the `id`
     * const salesOrderLineWithIdOnly = await prisma.salesOrderLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesOrderLine.
     * @param {SalesOrderLineDeleteArgs} args - Arguments to delete one SalesOrderLine.
     * @example
     * // Delete one SalesOrderLine
     * const SalesOrderLine = await prisma.salesOrderLine.delete({
     *   where: {
     *     // ... filter to delete one SalesOrderLine
     *   }
     * })
     * 
     */
    delete<T extends SalesOrderLineDeleteArgs>(args: SelectSubset<T, SalesOrderLineDeleteArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesOrderLine.
     * @param {SalesOrderLineUpdateArgs} args - Arguments to update one SalesOrderLine.
     * @example
     * // Update one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOrderLineUpdateArgs>(args: SelectSubset<T, SalesOrderLineUpdateArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesOrderLines.
     * @param {SalesOrderLineDeleteManyArgs} args - Arguments to filter SalesOrderLines to delete.
     * @example
     * // Delete a few SalesOrderLines
     * const { count } = await prisma.salesOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOrderLineDeleteManyArgs>(args?: SelectSubset<T, SalesOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOrderLineUpdateManyArgs>(args: SelectSubset<T, SalesOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrderLines and returns the data updated in the database.
     * @param {SalesOrderLineUpdateManyAndReturnArgs} args - Arguments to update many SalesOrderLines.
     * @example
     * // Update many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesOrderLines and only return the `id`
     * const salesOrderLineWithIdOnly = await prisma.salesOrderLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesOrderLineUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesOrderLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesOrderLine.
     * @param {SalesOrderLineUpsertArgs} args - Arguments to update or create a SalesOrderLine.
     * @example
     * // Update or create a SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.upsert({
     *   create: {
     *     // ... data to create a SalesOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends SalesOrderLineUpsertArgs>(args: SelectSubset<T, SalesOrderLineUpsertArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineCountArgs} args - Arguments to filter SalesOrderLines to count.
     * @example
     * // Count the number of SalesOrderLines
     * const count = await prisma.salesOrderLine.count({
     *   where: {
     *     // ... the filter for the SalesOrderLines we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderLineCountArgs>(
      args?: Subset<T, SalesOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderLineAggregateArgs>(args: Subset<T, SalesOrderLineAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderLineAggregateType<T>>

    /**
     * Group by SalesOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOrderLine model
   */
  readonly fields: SalesOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salesOrder<T extends SalesOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrderDefaultArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analytic<T extends SalesOrderLine$analyticArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrderLine$analyticArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOrderLine model
   */
  interface SalesOrderLineFieldRefs {
    readonly id: FieldRef<"SalesOrderLine", 'String'>
    readonly salesOrderId: FieldRef<"SalesOrderLine", 'String'>
    readonly productId: FieldRef<"SalesOrderLine", 'String'>
    readonly analyticAccountId: FieldRef<"SalesOrderLine", 'String'>
    readonly description: FieldRef<"SalesOrderLine", 'String'>
    readonly qty: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly unitPrice: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly taxRate: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly lineTotal: FieldRef<"SalesOrderLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SalesOrderLine findUnique
   */
  export type SalesOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine findUniqueOrThrow
   */
  export type SalesOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine findFirst
   */
  export type SalesOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrderLines.
     */
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine findFirstOrThrow
   */
  export type SalesOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrderLines.
     */
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine findMany
   */
  export type SalesOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLines to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine create
   */
  export type SalesOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOrderLine.
     */
    data: XOR<SalesOrderLineCreateInput, SalesOrderLineUncheckedCreateInput>
  }

  /**
   * SalesOrderLine createMany
   */
  export type SalesOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOrderLines.
     */
    data: SalesOrderLineCreateManyInput | SalesOrderLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesOrderLine createManyAndReturn
   */
  export type SalesOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * The data used to create many SalesOrderLines.
     */
    data: SalesOrderLineCreateManyInput | SalesOrderLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrderLine update
   */
  export type SalesOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOrderLine.
     */
    data: XOR<SalesOrderLineUpdateInput, SalesOrderLineUncheckedUpdateInput>
    /**
     * Choose, which SalesOrderLine to update.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine updateMany
   */
  export type SalesOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOrderLines.
     */
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrderLines to update
     */
    where?: SalesOrderLineWhereInput
    /**
     * Limit how many SalesOrderLines to update.
     */
    limit?: number
  }

  /**
   * SalesOrderLine updateManyAndReturn
   */
  export type SalesOrderLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * The data used to update SalesOrderLines.
     */
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrderLines to update
     */
    where?: SalesOrderLineWhereInput
    /**
     * Limit how many SalesOrderLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrderLine upsert
   */
  export type SalesOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOrderLine to update in case it exists.
     */
    where: SalesOrderLineWhereUniqueInput
    /**
     * In case the SalesOrderLine found by the `where` argument doesn't exist, create a new SalesOrderLine with this data.
     */
    create: XOR<SalesOrderLineCreateInput, SalesOrderLineUncheckedCreateInput>
    /**
     * In case the SalesOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderLineUpdateInput, SalesOrderLineUncheckedUpdateInput>
  }

  /**
   * SalesOrderLine delete
   */
  export type SalesOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter which SalesOrderLine to delete.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine deleteMany
   */
  export type SalesOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrderLines to delete
     */
    where?: SalesOrderLineWhereInput
    /**
     * Limit how many SalesOrderLines to delete.
     */
    limit?: number
  }

  /**
   * SalesOrderLine.analytic
   */
  export type SalesOrderLine$analyticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
  }

  /**
   * SalesOrderLine without action
   */
  export type SalesOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model VendorBill
   */

  export type AggregateVendorBill = {
    _count: VendorBillCountAggregateOutputType | null
    _avg: VendorBillAvgAggregateOutputType | null
    _sum: VendorBillSumAggregateOutputType | null
    _min: VendorBillMinAggregateOutputType | null
    _max: VendorBillMaxAggregateOutputType | null
  }

  export type VendorBillAvgAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type VendorBillSumAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type VendorBillMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    billNo: string | null
    vendorId: string | null
    billDate: Date | null
    dueDate: Date | null
    status: $Enums.DocStatus | null
    currency: string | null
    poId: string | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    paymentState: string | null
    createdAt: Date | null
  }

  export type VendorBillMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    billNo: string | null
    vendorId: string | null
    billDate: Date | null
    dueDate: Date | null
    status: $Enums.DocStatus | null
    currency: string | null
    poId: string | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    paymentState: string | null
    createdAt: Date | null
  }

  export type VendorBillCountAggregateOutputType = {
    id: number
    companyId: number
    billNo: number
    vendorId: number
    billDate: number
    dueDate: number
    status: number
    currency: number
    poId: number
    totalAmount: number
    paidAmount: number
    paymentState: number
    createdAt: number
    _all: number
  }


  export type VendorBillAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type VendorBillSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type VendorBillMinAggregateInputType = {
    id?: true
    companyId?: true
    billNo?: true
    vendorId?: true
    billDate?: true
    dueDate?: true
    status?: true
    currency?: true
    poId?: true
    totalAmount?: true
    paidAmount?: true
    paymentState?: true
    createdAt?: true
  }

  export type VendorBillMaxAggregateInputType = {
    id?: true
    companyId?: true
    billNo?: true
    vendorId?: true
    billDate?: true
    dueDate?: true
    status?: true
    currency?: true
    poId?: true
    totalAmount?: true
    paidAmount?: true
    paymentState?: true
    createdAt?: true
  }

  export type VendorBillCountAggregateInputType = {
    id?: true
    companyId?: true
    billNo?: true
    vendorId?: true
    billDate?: true
    dueDate?: true
    status?: true
    currency?: true
    poId?: true
    totalAmount?: true
    paidAmount?: true
    paymentState?: true
    createdAt?: true
    _all?: true
  }

  export type VendorBillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorBill to aggregate.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorBills
    **/
    _count?: true | VendorBillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorBillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorBillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorBillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorBillMaxAggregateInputType
  }

  export type GetVendorBillAggregateType<T extends VendorBillAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorBill[P]>
      : GetScalarType<T[P], AggregateVendorBill[P]>
  }




  export type VendorBillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillWhereInput
    orderBy?: VendorBillOrderByWithAggregationInput | VendorBillOrderByWithAggregationInput[]
    by: VendorBillScalarFieldEnum[] | VendorBillScalarFieldEnum
    having?: VendorBillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorBillCountAggregateInputType | true
    _avg?: VendorBillAvgAggregateInputType
    _sum?: VendorBillSumAggregateInputType
    _min?: VendorBillMinAggregateInputType
    _max?: VendorBillMaxAggregateInputType
  }

  export type VendorBillGroupByOutputType = {
    id: string
    companyId: string
    billNo: string
    vendorId: string
    billDate: Date
    dueDate: Date | null
    status: $Enums.DocStatus
    currency: string
    poId: string | null
    totalAmount: Decimal
    paidAmount: Decimal
    paymentState: string
    createdAt: Date
    _count: VendorBillCountAggregateOutputType | null
    _avg: VendorBillAvgAggregateOutputType | null
    _sum: VendorBillSumAggregateOutputType | null
    _min: VendorBillMinAggregateOutputType | null
    _max: VendorBillMaxAggregateOutputType | null
  }

  type GetVendorBillGroupByPayload<T extends VendorBillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorBillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorBillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorBillGroupByOutputType[P]>
            : GetScalarType<T[P], VendorBillGroupByOutputType[P]>
        }
      >
    >


  export type VendorBillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    billNo?: boolean
    vendorId?: boolean
    billDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    poId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    po?: boolean | VendorBill$poArgs<ExtArgs>
    lines?: boolean | VendorBill$linesArgs<ExtArgs>
    _count?: boolean | VendorBillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBill"]>

  export type VendorBillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    billNo?: boolean
    vendorId?: boolean
    billDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    poId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    po?: boolean | VendorBill$poArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBill"]>

  export type VendorBillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    billNo?: boolean
    vendorId?: boolean
    billDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    poId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    po?: boolean | VendorBill$poArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBill"]>

  export type VendorBillSelectScalar = {
    id?: boolean
    companyId?: boolean
    billNo?: boolean
    vendorId?: boolean
    billDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    poId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    createdAt?: boolean
  }

  export type VendorBillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "billNo" | "vendorId" | "billDate" | "dueDate" | "status" | "currency" | "poId" | "totalAmount" | "paidAmount" | "paymentState" | "createdAt", ExtArgs["result"]["vendorBill"]>
  export type VendorBillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    po?: boolean | VendorBill$poArgs<ExtArgs>
    lines?: boolean | VendorBill$linesArgs<ExtArgs>
    _count?: boolean | VendorBillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorBillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    po?: boolean | VendorBill$poArgs<ExtArgs>
  }
  export type VendorBillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vendor?: boolean | ContactDefaultArgs<ExtArgs>
    po?: boolean | VendorBill$poArgs<ExtArgs>
  }

  export type $VendorBillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorBill"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      vendor: Prisma.$ContactPayload<ExtArgs>
      po: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      lines: Prisma.$VendorBillLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      billNo: string
      vendorId: string
      billDate: Date
      dueDate: Date | null
      status: $Enums.DocStatus
      currency: string
      poId: string | null
      totalAmount: Prisma.Decimal
      paidAmount: Prisma.Decimal
      paymentState: string
      createdAt: Date
    }, ExtArgs["result"]["vendorBill"]>
    composites: {}
  }

  type VendorBillGetPayload<S extends boolean | null | undefined | VendorBillDefaultArgs> = $Result.GetResult<Prisma.$VendorBillPayload, S>

  type VendorBillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorBillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorBillCountAggregateInputType | true
    }

  export interface VendorBillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorBill'], meta: { name: 'VendorBill' } }
    /**
     * Find zero or one VendorBill that matches the filter.
     * @param {VendorBillFindUniqueArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorBillFindUniqueArgs>(args: SelectSubset<T, VendorBillFindUniqueArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorBill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorBillFindUniqueOrThrowArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorBillFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorBillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorBill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillFindFirstArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorBillFindFirstArgs>(args?: SelectSubset<T, VendorBillFindFirstArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorBill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillFindFirstOrThrowArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorBillFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorBillFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorBills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorBills
     * const vendorBills = await prisma.vendorBill.findMany()
     * 
     * // Get first 10 VendorBills
     * const vendorBills = await prisma.vendorBill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorBillWithIdOnly = await prisma.vendorBill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorBillFindManyArgs>(args?: SelectSubset<T, VendorBillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorBill.
     * @param {VendorBillCreateArgs} args - Arguments to create a VendorBill.
     * @example
     * // Create one VendorBill
     * const VendorBill = await prisma.vendorBill.create({
     *   data: {
     *     // ... data to create a VendorBill
     *   }
     * })
     * 
     */
    create<T extends VendorBillCreateArgs>(args: SelectSubset<T, VendorBillCreateArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorBills.
     * @param {VendorBillCreateManyArgs} args - Arguments to create many VendorBills.
     * @example
     * // Create many VendorBills
     * const vendorBill = await prisma.vendorBill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorBillCreateManyArgs>(args?: SelectSubset<T, VendorBillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorBills and returns the data saved in the database.
     * @param {VendorBillCreateManyAndReturnArgs} args - Arguments to create many VendorBills.
     * @example
     * // Create many VendorBills
     * const vendorBill = await prisma.vendorBill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorBills and only return the `id`
     * const vendorBillWithIdOnly = await prisma.vendorBill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorBillCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorBillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorBill.
     * @param {VendorBillDeleteArgs} args - Arguments to delete one VendorBill.
     * @example
     * // Delete one VendorBill
     * const VendorBill = await prisma.vendorBill.delete({
     *   where: {
     *     // ... filter to delete one VendorBill
     *   }
     * })
     * 
     */
    delete<T extends VendorBillDeleteArgs>(args: SelectSubset<T, VendorBillDeleteArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorBill.
     * @param {VendorBillUpdateArgs} args - Arguments to update one VendorBill.
     * @example
     * // Update one VendorBill
     * const vendorBill = await prisma.vendorBill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorBillUpdateArgs>(args: SelectSubset<T, VendorBillUpdateArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorBills.
     * @param {VendorBillDeleteManyArgs} args - Arguments to filter VendorBills to delete.
     * @example
     * // Delete a few VendorBills
     * const { count } = await prisma.vendorBill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorBillDeleteManyArgs>(args?: SelectSubset<T, VendorBillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorBills
     * const vendorBill = await prisma.vendorBill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorBillUpdateManyArgs>(args: SelectSubset<T, VendorBillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorBills and returns the data updated in the database.
     * @param {VendorBillUpdateManyAndReturnArgs} args - Arguments to update many VendorBills.
     * @example
     * // Update many VendorBills
     * const vendorBill = await prisma.vendorBill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorBills and only return the `id`
     * const vendorBillWithIdOnly = await prisma.vendorBill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorBillUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorBillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorBill.
     * @param {VendorBillUpsertArgs} args - Arguments to update or create a VendorBill.
     * @example
     * // Update or create a VendorBill
     * const vendorBill = await prisma.vendorBill.upsert({
     *   create: {
     *     // ... data to create a VendorBill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorBill we want to update
     *   }
     * })
     */
    upsert<T extends VendorBillUpsertArgs>(args: SelectSubset<T, VendorBillUpsertArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillCountArgs} args - Arguments to filter VendorBills to count.
     * @example
     * // Count the number of VendorBills
     * const count = await prisma.vendorBill.count({
     *   where: {
     *     // ... the filter for the VendorBills we want to count
     *   }
     * })
    **/
    count<T extends VendorBillCountArgs>(
      args?: Subset<T, VendorBillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorBillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorBill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorBillAggregateArgs>(args: Subset<T, VendorBillAggregateArgs>): Prisma.PrismaPromise<GetVendorBillAggregateType<T>>

    /**
     * Group by VendorBill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorBillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorBillGroupByArgs['orderBy'] }
        : { orderBy?: VendorBillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorBillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorBill model
   */
  readonly fields: VendorBillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorBill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorBillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    po<T extends VendorBill$poArgs<ExtArgs> = {}>(args?: Subset<T, VendorBill$poArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends VendorBill$linesArgs<ExtArgs> = {}>(args?: Subset<T, VendorBill$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorBill model
   */
  interface VendorBillFieldRefs {
    readonly id: FieldRef<"VendorBill", 'String'>
    readonly companyId: FieldRef<"VendorBill", 'String'>
    readonly billNo: FieldRef<"VendorBill", 'String'>
    readonly vendorId: FieldRef<"VendorBill", 'String'>
    readonly billDate: FieldRef<"VendorBill", 'DateTime'>
    readonly dueDate: FieldRef<"VendorBill", 'DateTime'>
    readonly status: FieldRef<"VendorBill", 'DocStatus'>
    readonly currency: FieldRef<"VendorBill", 'String'>
    readonly poId: FieldRef<"VendorBill", 'String'>
    readonly totalAmount: FieldRef<"VendorBill", 'Decimal'>
    readonly paidAmount: FieldRef<"VendorBill", 'Decimal'>
    readonly paymentState: FieldRef<"VendorBill", 'String'>
    readonly createdAt: FieldRef<"VendorBill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorBill findUnique
   */
  export type VendorBillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill findUniqueOrThrow
   */
  export type VendorBillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill findFirst
   */
  export type VendorBillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorBills.
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorBills.
     */
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * VendorBill findFirstOrThrow
   */
  export type VendorBillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorBills.
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorBills.
     */
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * VendorBill findMany
   */
  export type VendorBillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBills to fetch.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorBills.
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * VendorBill create
   */
  export type VendorBillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorBill.
     */
    data: XOR<VendorBillCreateInput, VendorBillUncheckedCreateInput>
  }

  /**
   * VendorBill createMany
   */
  export type VendorBillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorBills.
     */
    data: VendorBillCreateManyInput | VendorBillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorBill createManyAndReturn
   */
  export type VendorBillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * The data used to create many VendorBills.
     */
    data: VendorBillCreateManyInput | VendorBillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorBill update
   */
  export type VendorBillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorBill.
     */
    data: XOR<VendorBillUpdateInput, VendorBillUncheckedUpdateInput>
    /**
     * Choose, which VendorBill to update.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill updateMany
   */
  export type VendorBillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorBills.
     */
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyInput>
    /**
     * Filter which VendorBills to update
     */
    where?: VendorBillWhereInput
    /**
     * Limit how many VendorBills to update.
     */
    limit?: number
  }

  /**
   * VendorBill updateManyAndReturn
   */
  export type VendorBillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * The data used to update VendorBills.
     */
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyInput>
    /**
     * Filter which VendorBills to update
     */
    where?: VendorBillWhereInput
    /**
     * Limit how many VendorBills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorBill upsert
   */
  export type VendorBillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorBill to update in case it exists.
     */
    where: VendorBillWhereUniqueInput
    /**
     * In case the VendorBill found by the `where` argument doesn't exist, create a new VendorBill with this data.
     */
    create: XOR<VendorBillCreateInput, VendorBillUncheckedCreateInput>
    /**
     * In case the VendorBill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorBillUpdateInput, VendorBillUncheckedUpdateInput>
  }

  /**
   * VendorBill delete
   */
  export type VendorBillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter which VendorBill to delete.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill deleteMany
   */
  export type VendorBillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorBills to delete
     */
    where?: VendorBillWhereInput
    /**
     * Limit how many VendorBills to delete.
     */
    limit?: number
  }

  /**
   * VendorBill.po
   */
  export type VendorBill$poArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * VendorBill.lines
   */
  export type VendorBill$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    where?: VendorBillLineWhereInput
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    cursor?: VendorBillLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillLineScalarFieldEnum | VendorBillLineScalarFieldEnum[]
  }

  /**
   * VendorBill without action
   */
  export type VendorBillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
  }


  /**
   * Model VendorBillLine
   */

  export type AggregateVendorBillLine = {
    _count: VendorBillLineCountAggregateOutputType | null
    _avg: VendorBillLineAvgAggregateOutputType | null
    _sum: VendorBillLineSumAggregateOutputType | null
    _min: VendorBillLineMinAggregateOutputType | null
    _max: VendorBillLineMaxAggregateOutputType | null
  }

  export type VendorBillLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type VendorBillLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type VendorBillLineMinAggregateOutputType = {
    id: string | null
    vendorBillId: string | null
    productId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type VendorBillLineMaxAggregateOutputType = {
    id: string | null
    vendorBillId: string | null
    productId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type VendorBillLineCountAggregateOutputType = {
    id: number
    vendorBillId: number
    productId: number
    analyticAccountId: number
    glAccountId: number
    description: number
    qty: number
    unitPrice: number
    taxRate: number
    lineTotal: number
    _all: number
  }


  export type VendorBillLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type VendorBillLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type VendorBillLineMinAggregateInputType = {
    id?: true
    vendorBillId?: true
    productId?: true
    analyticAccountId?: true
    glAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type VendorBillLineMaxAggregateInputType = {
    id?: true
    vendorBillId?: true
    productId?: true
    analyticAccountId?: true
    glAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type VendorBillLineCountAggregateInputType = {
    id?: true
    vendorBillId?: true
    productId?: true
    analyticAccountId?: true
    glAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
    _all?: true
  }

  export type VendorBillLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorBillLine to aggregate.
     */
    where?: VendorBillLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBillLines to fetch.
     */
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorBillLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBillLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBillLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorBillLines
    **/
    _count?: true | VendorBillLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorBillLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorBillLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorBillLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorBillLineMaxAggregateInputType
  }

  export type GetVendorBillLineAggregateType<T extends VendorBillLineAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorBillLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorBillLine[P]>
      : GetScalarType<T[P], AggregateVendorBillLine[P]>
  }




  export type VendorBillLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillLineWhereInput
    orderBy?: VendorBillLineOrderByWithAggregationInput | VendorBillLineOrderByWithAggregationInput[]
    by: VendorBillLineScalarFieldEnum[] | VendorBillLineScalarFieldEnum
    having?: VendorBillLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorBillLineCountAggregateInputType | true
    _avg?: VendorBillLineAvgAggregateInputType
    _sum?: VendorBillLineSumAggregateInputType
    _min?: VendorBillLineMinAggregateInputType
    _max?: VendorBillLineMaxAggregateInputType
  }

  export type VendorBillLineGroupByOutputType = {
    id: string
    vendorBillId: string
    productId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    description: string | null
    qty: Decimal
    unitPrice: Decimal
    taxRate: Decimal
    lineTotal: Decimal
    _count: VendorBillLineCountAggregateOutputType | null
    _avg: VendorBillLineAvgAggregateOutputType | null
    _sum: VendorBillLineSumAggregateOutputType | null
    _min: VendorBillLineMinAggregateOutputType | null
    _max: VendorBillLineMaxAggregateOutputType | null
  }

  type GetVendorBillLineGroupByPayload<T extends VendorBillLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorBillLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorBillLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorBillLineGroupByOutputType[P]>
            : GetScalarType<T[P], VendorBillLineGroupByOutputType[P]>
        }
      >
    >


  export type VendorBillLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorBillId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    bill?: boolean | VendorBillDefaultArgs<ExtArgs>
    product?: boolean | VendorBillLine$productArgs<ExtArgs>
    analytic?: boolean | VendorBillLine$analyticArgs<ExtArgs>
    gl?: boolean | VendorBillLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBillLine"]>

  export type VendorBillLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorBillId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    bill?: boolean | VendorBillDefaultArgs<ExtArgs>
    product?: boolean | VendorBillLine$productArgs<ExtArgs>
    analytic?: boolean | VendorBillLine$analyticArgs<ExtArgs>
    gl?: boolean | VendorBillLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBillLine"]>

  export type VendorBillLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorBillId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    bill?: boolean | VendorBillDefaultArgs<ExtArgs>
    product?: boolean | VendorBillLine$productArgs<ExtArgs>
    analytic?: boolean | VendorBillLine$analyticArgs<ExtArgs>
    gl?: boolean | VendorBillLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBillLine"]>

  export type VendorBillLineSelectScalar = {
    id?: boolean
    vendorBillId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
  }

  export type VendorBillLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorBillId" | "productId" | "analyticAccountId" | "glAccountId" | "description" | "qty" | "unitPrice" | "taxRate" | "lineTotal", ExtArgs["result"]["vendorBillLine"]>
  export type VendorBillLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | VendorBillDefaultArgs<ExtArgs>
    product?: boolean | VendorBillLine$productArgs<ExtArgs>
    analytic?: boolean | VendorBillLine$analyticArgs<ExtArgs>
    gl?: boolean | VendorBillLine$glArgs<ExtArgs>
  }
  export type VendorBillLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | VendorBillDefaultArgs<ExtArgs>
    product?: boolean | VendorBillLine$productArgs<ExtArgs>
    analytic?: boolean | VendorBillLine$analyticArgs<ExtArgs>
    gl?: boolean | VendorBillLine$glArgs<ExtArgs>
  }
  export type VendorBillLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | VendorBillDefaultArgs<ExtArgs>
    product?: boolean | VendorBillLine$productArgs<ExtArgs>
    analytic?: boolean | VendorBillLine$analyticArgs<ExtArgs>
    gl?: boolean | VendorBillLine$glArgs<ExtArgs>
  }

  export type $VendorBillLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorBillLine"
    objects: {
      bill: Prisma.$VendorBillPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      analytic: Prisma.$AnalyticAccountPayload<ExtArgs> | null
      gl: Prisma.$GLAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorBillId: string
      productId: string | null
      analyticAccountId: string | null
      glAccountId: string | null
      description: string | null
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      taxRate: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["vendorBillLine"]>
    composites: {}
  }

  type VendorBillLineGetPayload<S extends boolean | null | undefined | VendorBillLineDefaultArgs> = $Result.GetResult<Prisma.$VendorBillLinePayload, S>

  type VendorBillLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorBillLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorBillLineCountAggregateInputType | true
    }

  export interface VendorBillLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorBillLine'], meta: { name: 'VendorBillLine' } }
    /**
     * Find zero or one VendorBillLine that matches the filter.
     * @param {VendorBillLineFindUniqueArgs} args - Arguments to find a VendorBillLine
     * @example
     * // Get one VendorBillLine
     * const vendorBillLine = await prisma.vendorBillLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorBillLineFindUniqueArgs>(args: SelectSubset<T, VendorBillLineFindUniqueArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorBillLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorBillLineFindUniqueOrThrowArgs} args - Arguments to find a VendorBillLine
     * @example
     * // Get one VendorBillLine
     * const vendorBillLine = await prisma.vendorBillLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorBillLineFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorBillLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorBillLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillLineFindFirstArgs} args - Arguments to find a VendorBillLine
     * @example
     * // Get one VendorBillLine
     * const vendorBillLine = await prisma.vendorBillLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorBillLineFindFirstArgs>(args?: SelectSubset<T, VendorBillLineFindFirstArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorBillLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillLineFindFirstOrThrowArgs} args - Arguments to find a VendorBillLine
     * @example
     * // Get one VendorBillLine
     * const vendorBillLine = await prisma.vendorBillLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorBillLineFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorBillLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorBillLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorBillLines
     * const vendorBillLines = await prisma.vendorBillLine.findMany()
     * 
     * // Get first 10 VendorBillLines
     * const vendorBillLines = await prisma.vendorBillLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorBillLineWithIdOnly = await prisma.vendorBillLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorBillLineFindManyArgs>(args?: SelectSubset<T, VendorBillLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorBillLine.
     * @param {VendorBillLineCreateArgs} args - Arguments to create a VendorBillLine.
     * @example
     * // Create one VendorBillLine
     * const VendorBillLine = await prisma.vendorBillLine.create({
     *   data: {
     *     // ... data to create a VendorBillLine
     *   }
     * })
     * 
     */
    create<T extends VendorBillLineCreateArgs>(args: SelectSubset<T, VendorBillLineCreateArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorBillLines.
     * @param {VendorBillLineCreateManyArgs} args - Arguments to create many VendorBillLines.
     * @example
     * // Create many VendorBillLines
     * const vendorBillLine = await prisma.vendorBillLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorBillLineCreateManyArgs>(args?: SelectSubset<T, VendorBillLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorBillLines and returns the data saved in the database.
     * @param {VendorBillLineCreateManyAndReturnArgs} args - Arguments to create many VendorBillLines.
     * @example
     * // Create many VendorBillLines
     * const vendorBillLine = await prisma.vendorBillLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorBillLines and only return the `id`
     * const vendorBillLineWithIdOnly = await prisma.vendorBillLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorBillLineCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorBillLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorBillLine.
     * @param {VendorBillLineDeleteArgs} args - Arguments to delete one VendorBillLine.
     * @example
     * // Delete one VendorBillLine
     * const VendorBillLine = await prisma.vendorBillLine.delete({
     *   where: {
     *     // ... filter to delete one VendorBillLine
     *   }
     * })
     * 
     */
    delete<T extends VendorBillLineDeleteArgs>(args: SelectSubset<T, VendorBillLineDeleteArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorBillLine.
     * @param {VendorBillLineUpdateArgs} args - Arguments to update one VendorBillLine.
     * @example
     * // Update one VendorBillLine
     * const vendorBillLine = await prisma.vendorBillLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorBillLineUpdateArgs>(args: SelectSubset<T, VendorBillLineUpdateArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorBillLines.
     * @param {VendorBillLineDeleteManyArgs} args - Arguments to filter VendorBillLines to delete.
     * @example
     * // Delete a few VendorBillLines
     * const { count } = await prisma.vendorBillLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorBillLineDeleteManyArgs>(args?: SelectSubset<T, VendorBillLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorBillLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorBillLines
     * const vendorBillLine = await prisma.vendorBillLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorBillLineUpdateManyArgs>(args: SelectSubset<T, VendorBillLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorBillLines and returns the data updated in the database.
     * @param {VendorBillLineUpdateManyAndReturnArgs} args - Arguments to update many VendorBillLines.
     * @example
     * // Update many VendorBillLines
     * const vendorBillLine = await prisma.vendorBillLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorBillLines and only return the `id`
     * const vendorBillLineWithIdOnly = await prisma.vendorBillLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorBillLineUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorBillLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorBillLine.
     * @param {VendorBillLineUpsertArgs} args - Arguments to update or create a VendorBillLine.
     * @example
     * // Update or create a VendorBillLine
     * const vendorBillLine = await prisma.vendorBillLine.upsert({
     *   create: {
     *     // ... data to create a VendorBillLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorBillLine we want to update
     *   }
     * })
     */
    upsert<T extends VendorBillLineUpsertArgs>(args: SelectSubset<T, VendorBillLineUpsertArgs<ExtArgs>>): Prisma__VendorBillLineClient<$Result.GetResult<Prisma.$VendorBillLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorBillLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillLineCountArgs} args - Arguments to filter VendorBillLines to count.
     * @example
     * // Count the number of VendorBillLines
     * const count = await prisma.vendorBillLine.count({
     *   where: {
     *     // ... the filter for the VendorBillLines we want to count
     *   }
     * })
    **/
    count<T extends VendorBillLineCountArgs>(
      args?: Subset<T, VendorBillLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorBillLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorBillLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorBillLineAggregateArgs>(args: Subset<T, VendorBillLineAggregateArgs>): Prisma.PrismaPromise<GetVendorBillLineAggregateType<T>>

    /**
     * Group by VendorBillLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorBillLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorBillLineGroupByArgs['orderBy'] }
        : { orderBy?: VendorBillLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorBillLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorBillLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorBillLine model
   */
  readonly fields: VendorBillLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorBillLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorBillLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends VendorBillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorBillDefaultArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends VendorBillLine$productArgs<ExtArgs> = {}>(args?: Subset<T, VendorBillLine$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    analytic<T extends VendorBillLine$analyticArgs<ExtArgs> = {}>(args?: Subset<T, VendorBillLine$analyticArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gl<T extends VendorBillLine$glArgs<ExtArgs> = {}>(args?: Subset<T, VendorBillLine$glArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorBillLine model
   */
  interface VendorBillLineFieldRefs {
    readonly id: FieldRef<"VendorBillLine", 'String'>
    readonly vendorBillId: FieldRef<"VendorBillLine", 'String'>
    readonly productId: FieldRef<"VendorBillLine", 'String'>
    readonly analyticAccountId: FieldRef<"VendorBillLine", 'String'>
    readonly glAccountId: FieldRef<"VendorBillLine", 'String'>
    readonly description: FieldRef<"VendorBillLine", 'String'>
    readonly qty: FieldRef<"VendorBillLine", 'Decimal'>
    readonly unitPrice: FieldRef<"VendorBillLine", 'Decimal'>
    readonly taxRate: FieldRef<"VendorBillLine", 'Decimal'>
    readonly lineTotal: FieldRef<"VendorBillLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * VendorBillLine findUnique
   */
  export type VendorBillLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * Filter, which VendorBillLine to fetch.
     */
    where: VendorBillLineWhereUniqueInput
  }

  /**
   * VendorBillLine findUniqueOrThrow
   */
  export type VendorBillLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * Filter, which VendorBillLine to fetch.
     */
    where: VendorBillLineWhereUniqueInput
  }

  /**
   * VendorBillLine findFirst
   */
  export type VendorBillLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * Filter, which VendorBillLine to fetch.
     */
    where?: VendorBillLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBillLines to fetch.
     */
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorBillLines.
     */
    cursor?: VendorBillLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBillLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBillLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorBillLines.
     */
    distinct?: VendorBillLineScalarFieldEnum | VendorBillLineScalarFieldEnum[]
  }

  /**
   * VendorBillLine findFirstOrThrow
   */
  export type VendorBillLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * Filter, which VendorBillLine to fetch.
     */
    where?: VendorBillLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBillLines to fetch.
     */
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorBillLines.
     */
    cursor?: VendorBillLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBillLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBillLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorBillLines.
     */
    distinct?: VendorBillLineScalarFieldEnum | VendorBillLineScalarFieldEnum[]
  }

  /**
   * VendorBillLine findMany
   */
  export type VendorBillLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * Filter, which VendorBillLines to fetch.
     */
    where?: VendorBillLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBillLines to fetch.
     */
    orderBy?: VendorBillLineOrderByWithRelationInput | VendorBillLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorBillLines.
     */
    cursor?: VendorBillLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBillLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBillLines.
     */
    skip?: number
    distinct?: VendorBillLineScalarFieldEnum | VendorBillLineScalarFieldEnum[]
  }

  /**
   * VendorBillLine create
   */
  export type VendorBillLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorBillLine.
     */
    data: XOR<VendorBillLineCreateInput, VendorBillLineUncheckedCreateInput>
  }

  /**
   * VendorBillLine createMany
   */
  export type VendorBillLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorBillLines.
     */
    data: VendorBillLineCreateManyInput | VendorBillLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorBillLine createManyAndReturn
   */
  export type VendorBillLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * The data used to create many VendorBillLines.
     */
    data: VendorBillLineCreateManyInput | VendorBillLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorBillLine update
   */
  export type VendorBillLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorBillLine.
     */
    data: XOR<VendorBillLineUpdateInput, VendorBillLineUncheckedUpdateInput>
    /**
     * Choose, which VendorBillLine to update.
     */
    where: VendorBillLineWhereUniqueInput
  }

  /**
   * VendorBillLine updateMany
   */
  export type VendorBillLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorBillLines.
     */
    data: XOR<VendorBillLineUpdateManyMutationInput, VendorBillLineUncheckedUpdateManyInput>
    /**
     * Filter which VendorBillLines to update
     */
    where?: VendorBillLineWhereInput
    /**
     * Limit how many VendorBillLines to update.
     */
    limit?: number
  }

  /**
   * VendorBillLine updateManyAndReturn
   */
  export type VendorBillLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * The data used to update VendorBillLines.
     */
    data: XOR<VendorBillLineUpdateManyMutationInput, VendorBillLineUncheckedUpdateManyInput>
    /**
     * Filter which VendorBillLines to update
     */
    where?: VendorBillLineWhereInput
    /**
     * Limit how many VendorBillLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorBillLine upsert
   */
  export type VendorBillLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorBillLine to update in case it exists.
     */
    where: VendorBillLineWhereUniqueInput
    /**
     * In case the VendorBillLine found by the `where` argument doesn't exist, create a new VendorBillLine with this data.
     */
    create: XOR<VendorBillLineCreateInput, VendorBillLineUncheckedCreateInput>
    /**
     * In case the VendorBillLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorBillLineUpdateInput, VendorBillLineUncheckedUpdateInput>
  }

  /**
   * VendorBillLine delete
   */
  export type VendorBillLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
    /**
     * Filter which VendorBillLine to delete.
     */
    where: VendorBillLineWhereUniqueInput
  }

  /**
   * VendorBillLine deleteMany
   */
  export type VendorBillLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorBillLines to delete
     */
    where?: VendorBillLineWhereInput
    /**
     * Limit how many VendorBillLines to delete.
     */
    limit?: number
  }

  /**
   * VendorBillLine.product
   */
  export type VendorBillLine$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * VendorBillLine.analytic
   */
  export type VendorBillLine$analyticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
  }

  /**
   * VendorBillLine.gl
   */
  export type VendorBillLine$glArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    where?: GLAccountWhereInput
  }

  /**
   * VendorBillLine without action
   */
  export type VendorBillLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillLine
     */
    select?: VendorBillLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBillLine
     */
    omit?: VendorBillLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillLineInclude<ExtArgs> | null
  }


  /**
   * Model CustomerInvoice
   */

  export type AggregateCustomerInvoice = {
    _count: CustomerInvoiceCountAggregateOutputType | null
    _avg: CustomerInvoiceAvgAggregateOutputType | null
    _sum: CustomerInvoiceSumAggregateOutputType | null
    _min: CustomerInvoiceMinAggregateOutputType | null
    _max: CustomerInvoiceMaxAggregateOutputType | null
  }

  export type CustomerInvoiceAvgAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type CustomerInvoiceSumAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type CustomerInvoiceMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    invoiceNo: string | null
    customerId: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    status: $Enums.DocStatus | null
    currency: string | null
    soId: string | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    paymentState: string | null
    portalVisible: boolean | null
    createdAt: Date | null
  }

  export type CustomerInvoiceMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    invoiceNo: string | null
    customerId: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    status: $Enums.DocStatus | null
    currency: string | null
    soId: string | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    paymentState: string | null
    portalVisible: boolean | null
    createdAt: Date | null
  }

  export type CustomerInvoiceCountAggregateOutputType = {
    id: number
    companyId: number
    invoiceNo: number
    customerId: number
    invoiceDate: number
    dueDate: number
    status: number
    currency: number
    soId: number
    totalAmount: number
    paidAmount: number
    paymentState: number
    portalVisible: number
    createdAt: number
    _all: number
  }


  export type CustomerInvoiceAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type CustomerInvoiceSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type CustomerInvoiceMinAggregateInputType = {
    id?: true
    companyId?: true
    invoiceNo?: true
    customerId?: true
    invoiceDate?: true
    dueDate?: true
    status?: true
    currency?: true
    soId?: true
    totalAmount?: true
    paidAmount?: true
    paymentState?: true
    portalVisible?: true
    createdAt?: true
  }

  export type CustomerInvoiceMaxAggregateInputType = {
    id?: true
    companyId?: true
    invoiceNo?: true
    customerId?: true
    invoiceDate?: true
    dueDate?: true
    status?: true
    currency?: true
    soId?: true
    totalAmount?: true
    paidAmount?: true
    paymentState?: true
    portalVisible?: true
    createdAt?: true
  }

  export type CustomerInvoiceCountAggregateInputType = {
    id?: true
    companyId?: true
    invoiceNo?: true
    customerId?: true
    invoiceDate?: true
    dueDate?: true
    status?: true
    currency?: true
    soId?: true
    totalAmount?: true
    paidAmount?: true
    paymentState?: true
    portalVisible?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoice to aggregate.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerInvoices
    **/
    _count?: true | CustomerInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerInvoiceMaxAggregateInputType
  }

  export type GetCustomerInvoiceAggregateType<T extends CustomerInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerInvoice[P]>
      : GetScalarType<T[P], AggregateCustomerInvoice[P]>
  }




  export type CustomerInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceWhereInput
    orderBy?: CustomerInvoiceOrderByWithAggregationInput | CustomerInvoiceOrderByWithAggregationInput[]
    by: CustomerInvoiceScalarFieldEnum[] | CustomerInvoiceScalarFieldEnum
    having?: CustomerInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerInvoiceCountAggregateInputType | true
    _avg?: CustomerInvoiceAvgAggregateInputType
    _sum?: CustomerInvoiceSumAggregateInputType
    _min?: CustomerInvoiceMinAggregateInputType
    _max?: CustomerInvoiceMaxAggregateInputType
  }

  export type CustomerInvoiceGroupByOutputType = {
    id: string
    companyId: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date
    dueDate: Date | null
    status: $Enums.DocStatus
    currency: string
    soId: string | null
    totalAmount: Decimal
    paidAmount: Decimal
    paymentState: string
    portalVisible: boolean
    createdAt: Date
    _count: CustomerInvoiceCountAggregateOutputType | null
    _avg: CustomerInvoiceAvgAggregateOutputType | null
    _sum: CustomerInvoiceSumAggregateOutputType | null
    _min: CustomerInvoiceMinAggregateOutputType | null
    _max: CustomerInvoiceMaxAggregateOutputType | null
  }

  type GetCustomerInvoiceGroupByPayload<T extends CustomerInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    invoiceNo?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    soId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    portalVisible?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    so?: boolean | CustomerInvoice$soArgs<ExtArgs>
    lines?: boolean | CustomerInvoice$linesArgs<ExtArgs>
    _count?: boolean | CustomerInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoice"]>

  export type CustomerInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    invoiceNo?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    soId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    portalVisible?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    so?: boolean | CustomerInvoice$soArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoice"]>

  export type CustomerInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    invoiceNo?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    soId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    portalVisible?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    so?: boolean | CustomerInvoice$soArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoice"]>

  export type CustomerInvoiceSelectScalar = {
    id?: boolean
    companyId?: boolean
    invoiceNo?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    currency?: boolean
    soId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentState?: boolean
    portalVisible?: boolean
    createdAt?: boolean
  }

  export type CustomerInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "invoiceNo" | "customerId" | "invoiceDate" | "dueDate" | "status" | "currency" | "soId" | "totalAmount" | "paidAmount" | "paymentState" | "portalVisible" | "createdAt", ExtArgs["result"]["customerInvoice"]>
  export type CustomerInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    so?: boolean | CustomerInvoice$soArgs<ExtArgs>
    lines?: boolean | CustomerInvoice$linesArgs<ExtArgs>
    _count?: boolean | CustomerInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    so?: boolean | CustomerInvoice$soArgs<ExtArgs>
  }
  export type CustomerInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    customer?: boolean | ContactDefaultArgs<ExtArgs>
    so?: boolean | CustomerInvoice$soArgs<ExtArgs>
  }

  export type $CustomerInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerInvoice"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      customer: Prisma.$ContactPayload<ExtArgs>
      so: Prisma.$SalesOrderPayload<ExtArgs> | null
      lines: Prisma.$CustomerInvoiceLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      invoiceNo: string
      customerId: string
      invoiceDate: Date
      dueDate: Date | null
      status: $Enums.DocStatus
      currency: string
      soId: string | null
      totalAmount: Prisma.Decimal
      paidAmount: Prisma.Decimal
      paymentState: string
      portalVisible: boolean
      createdAt: Date
    }, ExtArgs["result"]["customerInvoice"]>
    composites: {}
  }

  type CustomerInvoiceGetPayload<S extends boolean | null | undefined | CustomerInvoiceDefaultArgs> = $Result.GetResult<Prisma.$CustomerInvoicePayload, S>

  type CustomerInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerInvoiceCountAggregateInputType | true
    }

  export interface CustomerInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerInvoice'], meta: { name: 'CustomerInvoice' } }
    /**
     * Find zero or one CustomerInvoice that matches the filter.
     * @param {CustomerInvoiceFindUniqueArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerInvoiceFindUniqueArgs>(args: SelectSubset<T, CustomerInvoiceFindUniqueArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerInvoiceFindUniqueOrThrowArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceFindFirstArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerInvoiceFindFirstArgs>(args?: SelectSubset<T, CustomerInvoiceFindFirstArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceFindFirstOrThrowArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerInvoices
     * const customerInvoices = await prisma.customerInvoice.findMany()
     * 
     * // Get first 10 CustomerInvoices
     * const customerInvoices = await prisma.customerInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerInvoiceWithIdOnly = await prisma.customerInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerInvoiceFindManyArgs>(args?: SelectSubset<T, CustomerInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerInvoice.
     * @param {CustomerInvoiceCreateArgs} args - Arguments to create a CustomerInvoice.
     * @example
     * // Create one CustomerInvoice
     * const CustomerInvoice = await prisma.customerInvoice.create({
     *   data: {
     *     // ... data to create a CustomerInvoice
     *   }
     * })
     * 
     */
    create<T extends CustomerInvoiceCreateArgs>(args: SelectSubset<T, CustomerInvoiceCreateArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerInvoices.
     * @param {CustomerInvoiceCreateManyArgs} args - Arguments to create many CustomerInvoices.
     * @example
     * // Create many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerInvoiceCreateManyArgs>(args?: SelectSubset<T, CustomerInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerInvoices and returns the data saved in the database.
     * @param {CustomerInvoiceCreateManyAndReturnArgs} args - Arguments to create many CustomerInvoices.
     * @example
     * // Create many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerInvoices and only return the `id`
     * const customerInvoiceWithIdOnly = await prisma.customerInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerInvoice.
     * @param {CustomerInvoiceDeleteArgs} args - Arguments to delete one CustomerInvoice.
     * @example
     * // Delete one CustomerInvoice
     * const CustomerInvoice = await prisma.customerInvoice.delete({
     *   where: {
     *     // ... filter to delete one CustomerInvoice
     *   }
     * })
     * 
     */
    delete<T extends CustomerInvoiceDeleteArgs>(args: SelectSubset<T, CustomerInvoiceDeleteArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerInvoice.
     * @param {CustomerInvoiceUpdateArgs} args - Arguments to update one CustomerInvoice.
     * @example
     * // Update one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerInvoiceUpdateArgs>(args: SelectSubset<T, CustomerInvoiceUpdateArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerInvoices.
     * @param {CustomerInvoiceDeleteManyArgs} args - Arguments to filter CustomerInvoices to delete.
     * @example
     * // Delete a few CustomerInvoices
     * const { count } = await prisma.customerInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerInvoiceDeleteManyArgs>(args?: SelectSubset<T, CustomerInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerInvoiceUpdateManyArgs>(args: SelectSubset<T, CustomerInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoices and returns the data updated in the database.
     * @param {CustomerInvoiceUpdateManyAndReturnArgs} args - Arguments to update many CustomerInvoices.
     * @example
     * // Update many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerInvoices and only return the `id`
     * const customerInvoiceWithIdOnly = await prisma.customerInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerInvoice.
     * @param {CustomerInvoiceUpsertArgs} args - Arguments to update or create a CustomerInvoice.
     * @example
     * // Update or create a CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.upsert({
     *   create: {
     *     // ... data to create a CustomerInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerInvoice we want to update
     *   }
     * })
     */
    upsert<T extends CustomerInvoiceUpsertArgs>(args: SelectSubset<T, CustomerInvoiceUpsertArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceCountArgs} args - Arguments to filter CustomerInvoices to count.
     * @example
     * // Count the number of CustomerInvoices
     * const count = await prisma.customerInvoice.count({
     *   where: {
     *     // ... the filter for the CustomerInvoices we want to count
     *   }
     * })
    **/
    count<T extends CustomerInvoiceCountArgs>(
      args?: Subset<T, CustomerInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerInvoiceAggregateArgs>(args: Subset<T, CustomerInvoiceAggregateArgs>): Prisma.PrismaPromise<GetCustomerInvoiceAggregateType<T>>

    /**
     * Group by CustomerInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerInvoice model
   */
  readonly fields: CustomerInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    so<T extends CustomerInvoice$soArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoice$soArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends CustomerInvoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerInvoice model
   */
  interface CustomerInvoiceFieldRefs {
    readonly id: FieldRef<"CustomerInvoice", 'String'>
    readonly companyId: FieldRef<"CustomerInvoice", 'String'>
    readonly invoiceNo: FieldRef<"CustomerInvoice", 'String'>
    readonly customerId: FieldRef<"CustomerInvoice", 'String'>
    readonly invoiceDate: FieldRef<"CustomerInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"CustomerInvoice", 'DateTime'>
    readonly status: FieldRef<"CustomerInvoice", 'DocStatus'>
    readonly currency: FieldRef<"CustomerInvoice", 'String'>
    readonly soId: FieldRef<"CustomerInvoice", 'String'>
    readonly totalAmount: FieldRef<"CustomerInvoice", 'Decimal'>
    readonly paidAmount: FieldRef<"CustomerInvoice", 'Decimal'>
    readonly paymentState: FieldRef<"CustomerInvoice", 'String'>
    readonly portalVisible: FieldRef<"CustomerInvoice", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerInvoice findUnique
   */
  export type CustomerInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice findUniqueOrThrow
   */
  export type CustomerInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice findFirst
   */
  export type CustomerInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoices.
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoices.
     */
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * CustomerInvoice findFirstOrThrow
   */
  export type CustomerInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoices.
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoices.
     */
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * CustomerInvoice findMany
   */
  export type CustomerInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoices to fetch.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerInvoices.
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * CustomerInvoice create
   */
  export type CustomerInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerInvoice.
     */
    data: XOR<CustomerInvoiceCreateInput, CustomerInvoiceUncheckedCreateInput>
  }

  /**
   * CustomerInvoice createMany
   */
  export type CustomerInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerInvoices.
     */
    data: CustomerInvoiceCreateManyInput | CustomerInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerInvoice createManyAndReturn
   */
  export type CustomerInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerInvoices.
     */
    data: CustomerInvoiceCreateManyInput | CustomerInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerInvoice update
   */
  export type CustomerInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerInvoice.
     */
    data: XOR<CustomerInvoiceUpdateInput, CustomerInvoiceUncheckedUpdateInput>
    /**
     * Choose, which CustomerInvoice to update.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice updateMany
   */
  export type CustomerInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerInvoices.
     */
    data: XOR<CustomerInvoiceUpdateManyMutationInput, CustomerInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoices to update
     */
    where?: CustomerInvoiceWhereInput
    /**
     * Limit how many CustomerInvoices to update.
     */
    limit?: number
  }

  /**
   * CustomerInvoice updateManyAndReturn
   */
  export type CustomerInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update CustomerInvoices.
     */
    data: XOR<CustomerInvoiceUpdateManyMutationInput, CustomerInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoices to update
     */
    where?: CustomerInvoiceWhereInput
    /**
     * Limit how many CustomerInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerInvoice upsert
   */
  export type CustomerInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerInvoice to update in case it exists.
     */
    where: CustomerInvoiceWhereUniqueInput
    /**
     * In case the CustomerInvoice found by the `where` argument doesn't exist, create a new CustomerInvoice with this data.
     */
    create: XOR<CustomerInvoiceCreateInput, CustomerInvoiceUncheckedCreateInput>
    /**
     * In case the CustomerInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerInvoiceUpdateInput, CustomerInvoiceUncheckedUpdateInput>
  }

  /**
   * CustomerInvoice delete
   */
  export type CustomerInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter which CustomerInvoice to delete.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice deleteMany
   */
  export type CustomerInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoices to delete
     */
    where?: CustomerInvoiceWhereInput
    /**
     * Limit how many CustomerInvoices to delete.
     */
    limit?: number
  }

  /**
   * CustomerInvoice.so
   */
  export type CustomerInvoice$soArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
  }

  /**
   * CustomerInvoice.lines
   */
  export type CustomerInvoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    where?: CustomerInvoiceLineWhereInput
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    cursor?: CustomerInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceLineScalarFieldEnum | CustomerInvoiceLineScalarFieldEnum[]
  }

  /**
   * CustomerInvoice without action
   */
  export type CustomerInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model CustomerInvoiceLine
   */

  export type AggregateCustomerInvoiceLine = {
    _count: CustomerInvoiceLineCountAggregateOutputType | null
    _avg: CustomerInvoiceLineAvgAggregateOutputType | null
    _sum: CustomerInvoiceLineSumAggregateOutputType | null
    _min: CustomerInvoiceLineMinAggregateOutputType | null
    _max: CustomerInvoiceLineMaxAggregateOutputType | null
  }

  export type CustomerInvoiceLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type CustomerInvoiceLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type CustomerInvoiceLineMinAggregateOutputType = {
    id: string | null
    customerInvoiceId: string | null
    productId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type CustomerInvoiceLineMaxAggregateOutputType = {
    id: string | null
    customerInvoiceId: string | null
    productId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    lineTotal: Decimal | null
  }

  export type CustomerInvoiceLineCountAggregateOutputType = {
    id: number
    customerInvoiceId: number
    productId: number
    analyticAccountId: number
    glAccountId: number
    description: number
    qty: number
    unitPrice: number
    taxRate: number
    lineTotal: number
    _all: number
  }


  export type CustomerInvoiceLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type CustomerInvoiceLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type CustomerInvoiceLineMinAggregateInputType = {
    id?: true
    customerInvoiceId?: true
    productId?: true
    analyticAccountId?: true
    glAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type CustomerInvoiceLineMaxAggregateInputType = {
    id?: true
    customerInvoiceId?: true
    productId?: true
    analyticAccountId?: true
    glAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
  }

  export type CustomerInvoiceLineCountAggregateInputType = {
    id?: true
    customerInvoiceId?: true
    productId?: true
    analyticAccountId?: true
    glAccountId?: true
    description?: true
    qty?: true
    unitPrice?: true
    taxRate?: true
    lineTotal?: true
    _all?: true
  }

  export type CustomerInvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoiceLine to aggregate.
     */
    where?: CustomerInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceLines to fetch.
     */
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerInvoiceLines
    **/
    _count?: true | CustomerInvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerInvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerInvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerInvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerInvoiceLineMaxAggregateInputType
  }

  export type GetCustomerInvoiceLineAggregateType<T extends CustomerInvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerInvoiceLine[P]>
      : GetScalarType<T[P], AggregateCustomerInvoiceLine[P]>
  }




  export type CustomerInvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceLineWhereInput
    orderBy?: CustomerInvoiceLineOrderByWithAggregationInput | CustomerInvoiceLineOrderByWithAggregationInput[]
    by: CustomerInvoiceLineScalarFieldEnum[] | CustomerInvoiceLineScalarFieldEnum
    having?: CustomerInvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerInvoiceLineCountAggregateInputType | true
    _avg?: CustomerInvoiceLineAvgAggregateInputType
    _sum?: CustomerInvoiceLineSumAggregateInputType
    _min?: CustomerInvoiceLineMinAggregateInputType
    _max?: CustomerInvoiceLineMaxAggregateInputType
  }

  export type CustomerInvoiceLineGroupByOutputType = {
    id: string
    customerInvoiceId: string
    productId: string | null
    analyticAccountId: string | null
    glAccountId: string | null
    description: string | null
    qty: Decimal
    unitPrice: Decimal
    taxRate: Decimal
    lineTotal: Decimal
    _count: CustomerInvoiceLineCountAggregateOutputType | null
    _avg: CustomerInvoiceLineAvgAggregateOutputType | null
    _sum: CustomerInvoiceLineSumAggregateOutputType | null
    _min: CustomerInvoiceLineMinAggregateOutputType | null
    _max: CustomerInvoiceLineMaxAggregateOutputType | null
  }

  type GetCustomerInvoiceLineGroupByPayload<T extends CustomerInvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerInvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerInvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerInvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerInvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type CustomerInvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerInvoiceId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
    product?: boolean | CustomerInvoiceLine$productArgs<ExtArgs>
    analytic?: boolean | CustomerInvoiceLine$analyticArgs<ExtArgs>
    gl?: boolean | CustomerInvoiceLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoiceLine"]>

  export type CustomerInvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerInvoiceId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
    product?: boolean | CustomerInvoiceLine$productArgs<ExtArgs>
    analytic?: boolean | CustomerInvoiceLine$analyticArgs<ExtArgs>
    gl?: boolean | CustomerInvoiceLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoiceLine"]>

  export type CustomerInvoiceLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerInvoiceId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
    product?: boolean | CustomerInvoiceLine$productArgs<ExtArgs>
    analytic?: boolean | CustomerInvoiceLine$analyticArgs<ExtArgs>
    gl?: boolean | CustomerInvoiceLine$glArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoiceLine"]>

  export type CustomerInvoiceLineSelectScalar = {
    id?: boolean
    customerInvoiceId?: boolean
    productId?: boolean
    analyticAccountId?: boolean
    glAccountId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxRate?: boolean
    lineTotal?: boolean
  }

  export type CustomerInvoiceLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerInvoiceId" | "productId" | "analyticAccountId" | "glAccountId" | "description" | "qty" | "unitPrice" | "taxRate" | "lineTotal", ExtArgs["result"]["customerInvoiceLine"]>
  export type CustomerInvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
    product?: boolean | CustomerInvoiceLine$productArgs<ExtArgs>
    analytic?: boolean | CustomerInvoiceLine$analyticArgs<ExtArgs>
    gl?: boolean | CustomerInvoiceLine$glArgs<ExtArgs>
  }
  export type CustomerInvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
    product?: boolean | CustomerInvoiceLine$productArgs<ExtArgs>
    analytic?: boolean | CustomerInvoiceLine$analyticArgs<ExtArgs>
    gl?: boolean | CustomerInvoiceLine$glArgs<ExtArgs>
  }
  export type CustomerInvoiceLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
    product?: boolean | CustomerInvoiceLine$productArgs<ExtArgs>
    analytic?: boolean | CustomerInvoiceLine$analyticArgs<ExtArgs>
    gl?: boolean | CustomerInvoiceLine$glArgs<ExtArgs>
  }

  export type $CustomerInvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerInvoiceLine"
    objects: {
      invoice: Prisma.$CustomerInvoicePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      analytic: Prisma.$AnalyticAccountPayload<ExtArgs> | null
      gl: Prisma.$GLAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerInvoiceId: string
      productId: string | null
      analyticAccountId: string | null
      glAccountId: string | null
      description: string | null
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      taxRate: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["customerInvoiceLine"]>
    composites: {}
  }

  type CustomerInvoiceLineGetPayload<S extends boolean | null | undefined | CustomerInvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$CustomerInvoiceLinePayload, S>

  type CustomerInvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerInvoiceLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerInvoiceLineCountAggregateInputType | true
    }

  export interface CustomerInvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerInvoiceLine'], meta: { name: 'CustomerInvoiceLine' } }
    /**
     * Find zero or one CustomerInvoiceLine that matches the filter.
     * @param {CustomerInvoiceLineFindUniqueArgs} args - Arguments to find a CustomerInvoiceLine
     * @example
     * // Get one CustomerInvoiceLine
     * const customerInvoiceLine = await prisma.customerInvoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerInvoiceLineFindUniqueArgs>(args: SelectSubset<T, CustomerInvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerInvoiceLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerInvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a CustomerInvoiceLine
     * @example
     * // Get one CustomerInvoiceLine
     * const customerInvoiceLine = await prisma.customerInvoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerInvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerInvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceLineFindFirstArgs} args - Arguments to find a CustomerInvoiceLine
     * @example
     * // Get one CustomerInvoiceLine
     * const customerInvoiceLine = await prisma.customerInvoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerInvoiceLineFindFirstArgs>(args?: SelectSubset<T, CustomerInvoiceLineFindFirstArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceLineFindFirstOrThrowArgs} args - Arguments to find a CustomerInvoiceLine
     * @example
     * // Get one CustomerInvoiceLine
     * const customerInvoiceLine = await prisma.customerInvoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerInvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerInvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerInvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerInvoiceLines
     * const customerInvoiceLines = await prisma.customerInvoiceLine.findMany()
     * 
     * // Get first 10 CustomerInvoiceLines
     * const customerInvoiceLines = await prisma.customerInvoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerInvoiceLineWithIdOnly = await prisma.customerInvoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerInvoiceLineFindManyArgs>(args?: SelectSubset<T, CustomerInvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerInvoiceLine.
     * @param {CustomerInvoiceLineCreateArgs} args - Arguments to create a CustomerInvoiceLine.
     * @example
     * // Create one CustomerInvoiceLine
     * const CustomerInvoiceLine = await prisma.customerInvoiceLine.create({
     *   data: {
     *     // ... data to create a CustomerInvoiceLine
     *   }
     * })
     * 
     */
    create<T extends CustomerInvoiceLineCreateArgs>(args: SelectSubset<T, CustomerInvoiceLineCreateArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerInvoiceLines.
     * @param {CustomerInvoiceLineCreateManyArgs} args - Arguments to create many CustomerInvoiceLines.
     * @example
     * // Create many CustomerInvoiceLines
     * const customerInvoiceLine = await prisma.customerInvoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerInvoiceLineCreateManyArgs>(args?: SelectSubset<T, CustomerInvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerInvoiceLines and returns the data saved in the database.
     * @param {CustomerInvoiceLineCreateManyAndReturnArgs} args - Arguments to create many CustomerInvoiceLines.
     * @example
     * // Create many CustomerInvoiceLines
     * const customerInvoiceLine = await prisma.customerInvoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerInvoiceLines and only return the `id`
     * const customerInvoiceLineWithIdOnly = await prisma.customerInvoiceLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerInvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerInvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerInvoiceLine.
     * @param {CustomerInvoiceLineDeleteArgs} args - Arguments to delete one CustomerInvoiceLine.
     * @example
     * // Delete one CustomerInvoiceLine
     * const CustomerInvoiceLine = await prisma.customerInvoiceLine.delete({
     *   where: {
     *     // ... filter to delete one CustomerInvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends CustomerInvoiceLineDeleteArgs>(args: SelectSubset<T, CustomerInvoiceLineDeleteArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerInvoiceLine.
     * @param {CustomerInvoiceLineUpdateArgs} args - Arguments to update one CustomerInvoiceLine.
     * @example
     * // Update one CustomerInvoiceLine
     * const customerInvoiceLine = await prisma.customerInvoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerInvoiceLineUpdateArgs>(args: SelectSubset<T, CustomerInvoiceLineUpdateArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerInvoiceLines.
     * @param {CustomerInvoiceLineDeleteManyArgs} args - Arguments to filter CustomerInvoiceLines to delete.
     * @example
     * // Delete a few CustomerInvoiceLines
     * const { count } = await prisma.customerInvoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerInvoiceLineDeleteManyArgs>(args?: SelectSubset<T, CustomerInvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerInvoiceLines
     * const customerInvoiceLine = await prisma.customerInvoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerInvoiceLineUpdateManyArgs>(args: SelectSubset<T, CustomerInvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoiceLines and returns the data updated in the database.
     * @param {CustomerInvoiceLineUpdateManyAndReturnArgs} args - Arguments to update many CustomerInvoiceLines.
     * @example
     * // Update many CustomerInvoiceLines
     * const customerInvoiceLine = await prisma.customerInvoiceLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerInvoiceLines and only return the `id`
     * const customerInvoiceLineWithIdOnly = await prisma.customerInvoiceLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerInvoiceLineUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerInvoiceLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerInvoiceLine.
     * @param {CustomerInvoiceLineUpsertArgs} args - Arguments to update or create a CustomerInvoiceLine.
     * @example
     * // Update or create a CustomerInvoiceLine
     * const customerInvoiceLine = await prisma.customerInvoiceLine.upsert({
     *   create: {
     *     // ... data to create a CustomerInvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerInvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends CustomerInvoiceLineUpsertArgs>(args: SelectSubset<T, CustomerInvoiceLineUpsertArgs<ExtArgs>>): Prisma__CustomerInvoiceLineClient<$Result.GetResult<Prisma.$CustomerInvoiceLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerInvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceLineCountArgs} args - Arguments to filter CustomerInvoiceLines to count.
     * @example
     * // Count the number of CustomerInvoiceLines
     * const count = await prisma.customerInvoiceLine.count({
     *   where: {
     *     // ... the filter for the CustomerInvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends CustomerInvoiceLineCountArgs>(
      args?: Subset<T, CustomerInvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerInvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerInvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerInvoiceLineAggregateArgs>(args: Subset<T, CustomerInvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetCustomerInvoiceLineAggregateType<T>>

    /**
     * Group by CustomerInvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerInvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerInvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: CustomerInvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerInvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerInvoiceLine model
   */
  readonly fields: CustomerInvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerInvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerInvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends CustomerInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoiceDefaultArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends CustomerInvoiceLine$productArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoiceLine$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    analytic<T extends CustomerInvoiceLine$analyticArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoiceLine$analyticArgs<ExtArgs>>): Prisma__AnalyticAccountClient<$Result.GetResult<Prisma.$AnalyticAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gl<T extends CustomerInvoiceLine$glArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoiceLine$glArgs<ExtArgs>>): Prisma__GLAccountClient<$Result.GetResult<Prisma.$GLAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerInvoiceLine model
   */
  interface CustomerInvoiceLineFieldRefs {
    readonly id: FieldRef<"CustomerInvoiceLine", 'String'>
    readonly customerInvoiceId: FieldRef<"CustomerInvoiceLine", 'String'>
    readonly productId: FieldRef<"CustomerInvoiceLine", 'String'>
    readonly analyticAccountId: FieldRef<"CustomerInvoiceLine", 'String'>
    readonly glAccountId: FieldRef<"CustomerInvoiceLine", 'String'>
    readonly description: FieldRef<"CustomerInvoiceLine", 'String'>
    readonly qty: FieldRef<"CustomerInvoiceLine", 'Decimal'>
    readonly unitPrice: FieldRef<"CustomerInvoiceLine", 'Decimal'>
    readonly taxRate: FieldRef<"CustomerInvoiceLine", 'Decimal'>
    readonly lineTotal: FieldRef<"CustomerInvoiceLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CustomerInvoiceLine findUnique
   */
  export type CustomerInvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceLine to fetch.
     */
    where: CustomerInvoiceLineWhereUniqueInput
  }

  /**
   * CustomerInvoiceLine findUniqueOrThrow
   */
  export type CustomerInvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceLine to fetch.
     */
    where: CustomerInvoiceLineWhereUniqueInput
  }

  /**
   * CustomerInvoiceLine findFirst
   */
  export type CustomerInvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceLine to fetch.
     */
    where?: CustomerInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceLines to fetch.
     */
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoiceLines.
     */
    cursor?: CustomerInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoiceLines.
     */
    distinct?: CustomerInvoiceLineScalarFieldEnum | CustomerInvoiceLineScalarFieldEnum[]
  }

  /**
   * CustomerInvoiceLine findFirstOrThrow
   */
  export type CustomerInvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceLine to fetch.
     */
    where?: CustomerInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceLines to fetch.
     */
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoiceLines.
     */
    cursor?: CustomerInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoiceLines.
     */
    distinct?: CustomerInvoiceLineScalarFieldEnum | CustomerInvoiceLineScalarFieldEnum[]
  }

  /**
   * CustomerInvoiceLine findMany
   */
  export type CustomerInvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceLines to fetch.
     */
    where?: CustomerInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceLines to fetch.
     */
    orderBy?: CustomerInvoiceLineOrderByWithRelationInput | CustomerInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerInvoiceLines.
     */
    cursor?: CustomerInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceLines.
     */
    skip?: number
    distinct?: CustomerInvoiceLineScalarFieldEnum | CustomerInvoiceLineScalarFieldEnum[]
  }

  /**
   * CustomerInvoiceLine create
   */
  export type CustomerInvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerInvoiceLine.
     */
    data: XOR<CustomerInvoiceLineCreateInput, CustomerInvoiceLineUncheckedCreateInput>
  }

  /**
   * CustomerInvoiceLine createMany
   */
  export type CustomerInvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerInvoiceLines.
     */
    data: CustomerInvoiceLineCreateManyInput | CustomerInvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerInvoiceLine createManyAndReturn
   */
  export type CustomerInvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerInvoiceLines.
     */
    data: CustomerInvoiceLineCreateManyInput | CustomerInvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerInvoiceLine update
   */
  export type CustomerInvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerInvoiceLine.
     */
    data: XOR<CustomerInvoiceLineUpdateInput, CustomerInvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which CustomerInvoiceLine to update.
     */
    where: CustomerInvoiceLineWhereUniqueInput
  }

  /**
   * CustomerInvoiceLine updateMany
   */
  export type CustomerInvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerInvoiceLines.
     */
    data: XOR<CustomerInvoiceLineUpdateManyMutationInput, CustomerInvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoiceLines to update
     */
    where?: CustomerInvoiceLineWhereInput
    /**
     * Limit how many CustomerInvoiceLines to update.
     */
    limit?: number
  }

  /**
   * CustomerInvoiceLine updateManyAndReturn
   */
  export type CustomerInvoiceLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to update CustomerInvoiceLines.
     */
    data: XOR<CustomerInvoiceLineUpdateManyMutationInput, CustomerInvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoiceLines to update
     */
    where?: CustomerInvoiceLineWhereInput
    /**
     * Limit how many CustomerInvoiceLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerInvoiceLine upsert
   */
  export type CustomerInvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerInvoiceLine to update in case it exists.
     */
    where: CustomerInvoiceLineWhereUniqueInput
    /**
     * In case the CustomerInvoiceLine found by the `where` argument doesn't exist, create a new CustomerInvoiceLine with this data.
     */
    create: XOR<CustomerInvoiceLineCreateInput, CustomerInvoiceLineUncheckedCreateInput>
    /**
     * In case the CustomerInvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerInvoiceLineUpdateInput, CustomerInvoiceLineUncheckedUpdateInput>
  }

  /**
   * CustomerInvoiceLine delete
   */
  export type CustomerInvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which CustomerInvoiceLine to delete.
     */
    where: CustomerInvoiceLineWhereUniqueInput
  }

  /**
   * CustomerInvoiceLine deleteMany
   */
  export type CustomerInvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoiceLines to delete
     */
    where?: CustomerInvoiceLineWhereInput
    /**
     * Limit how many CustomerInvoiceLines to delete.
     */
    limit?: number
  }

  /**
   * CustomerInvoiceLine.product
   */
  export type CustomerInvoiceLine$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * CustomerInvoiceLine.analytic
   */
  export type CustomerInvoiceLine$analyticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticAccount
     */
    select?: AnalyticAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticAccount
     */
    omit?: AnalyticAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticAccountInclude<ExtArgs> | null
    where?: AnalyticAccountWhereInput
  }

  /**
   * CustomerInvoiceLine.gl
   */
  export type CustomerInvoiceLine$glArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GLAccount
     */
    select?: GLAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GLAccount
     */
    omit?: GLAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GLAccountInclude<ExtArgs> | null
    where?: GLAccountWhereInput
  }

  /**
   * CustomerInvoiceLine without action
   */
  export type CustomerInvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceLine
     */
    select?: CustomerInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceLine
     */
    omit?: CustomerInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    direction: $Enums.PaymentDirection | null
    contactId: string | null
    paymentDate: Date | null
    method: $Enums.PaymentMethod | null
    reference: string | null
    amount: Decimal | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    direction: $Enums.PaymentDirection | null
    contactId: string | null
    paymentDate: Date | null
    method: $Enums.PaymentMethod | null
    reference: string | null
    amount: Decimal | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    companyId: number
    direction: number
    contactId: number
    paymentDate: number
    method: number
    reference: number
    amount: number
    status: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    companyId?: true
    direction?: true
    contactId?: true
    paymentDate?: true
    method?: true
    reference?: true
    amount?: true
    status?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    companyId?: true
    direction?: true
    contactId?: true
    paymentDate?: true
    method?: true
    reference?: true
    amount?: true
    status?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    companyId?: true
    direction?: true
    contactId?: true
    paymentDate?: true
    method?: true
    reference?: true
    amount?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    companyId: string
    direction: $Enums.PaymentDirection
    contactId: string
    paymentDate: Date
    method: $Enums.PaymentMethod
    reference: string | null
    amount: Decimal
    status: $Enums.PaymentStatus
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    direction?: boolean
    contactId?: boolean
    paymentDate?: boolean
    method?: boolean
    reference?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    allocations?: boolean | Payment$allocationsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    direction?: boolean
    contactId?: boolean
    paymentDate?: boolean
    method?: boolean
    reference?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    direction?: boolean
    contactId?: boolean
    paymentDate?: boolean
    method?: boolean
    reference?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    companyId?: boolean
    direction?: boolean
    contactId?: boolean
    paymentDate?: boolean
    method?: boolean
    reference?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "direction" | "contactId" | "paymentDate" | "method" | "reference" | "amount" | "status" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    allocations?: boolean | Payment$allocationsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      allocations: Prisma.$PaymentAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      direction: $Enums.PaymentDirection
      contactId: string
      paymentDate: Date
      method: $Enums.PaymentMethod
      reference: string | null
      amount: Prisma.Decimal
      status: $Enums.PaymentStatus
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    allocations<T extends Payment$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly companyId: FieldRef<"Payment", 'String'>
    readonly direction: FieldRef<"Payment", 'PaymentDirection'>
    readonly contactId: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.allocations
   */
  export type Payment$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    where?: PaymentAllocationWhereInput
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    cursor?: PaymentAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentAllocation
   */

  export type AggregatePaymentAllocation = {
    _count: PaymentAllocationCountAggregateOutputType | null
    _avg: PaymentAllocationAvgAggregateOutputType | null
    _sum: PaymentAllocationSumAggregateOutputType | null
    _min: PaymentAllocationMinAggregateOutputType | null
    _max: PaymentAllocationMaxAggregateOutputType | null
  }

  export type PaymentAllocationAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentAllocationSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentAllocationMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    targetType: $Enums.AllocationTargetType | null
    targetId: string | null
    amount: Decimal | null
  }

  export type PaymentAllocationMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    targetType: $Enums.AllocationTargetType | null
    targetId: string | null
    amount: Decimal | null
  }

  export type PaymentAllocationCountAggregateOutputType = {
    id: number
    paymentId: number
    targetType: number
    targetId: number
    amount: number
    _all: number
  }


  export type PaymentAllocationAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentAllocationSumAggregateInputType = {
    amount?: true
  }

  export type PaymentAllocationMinAggregateInputType = {
    id?: true
    paymentId?: true
    targetType?: true
    targetId?: true
    amount?: true
  }

  export type PaymentAllocationMaxAggregateInputType = {
    id?: true
    paymentId?: true
    targetType?: true
    targetId?: true
    amount?: true
  }

  export type PaymentAllocationCountAggregateInputType = {
    id?: true
    paymentId?: true
    targetType?: true
    targetId?: true
    amount?: true
    _all?: true
  }

  export type PaymentAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAllocation to aggregate.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAllocations
    **/
    _count?: true | PaymentAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAllocationMaxAggregateInputType
  }

  export type GetPaymentAllocationAggregateType<T extends PaymentAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAllocation[P]>
      : GetScalarType<T[P], AggregatePaymentAllocation[P]>
  }




  export type PaymentAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAllocationWhereInput
    orderBy?: PaymentAllocationOrderByWithAggregationInput | PaymentAllocationOrderByWithAggregationInput[]
    by: PaymentAllocationScalarFieldEnum[] | PaymentAllocationScalarFieldEnum
    having?: PaymentAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAllocationCountAggregateInputType | true
    _avg?: PaymentAllocationAvgAggregateInputType
    _sum?: PaymentAllocationSumAggregateInputType
    _min?: PaymentAllocationMinAggregateInputType
    _max?: PaymentAllocationMaxAggregateInputType
  }

  export type PaymentAllocationGroupByOutputType = {
    id: string
    paymentId: string
    targetType: $Enums.AllocationTargetType
    targetId: string
    amount: Decimal
    _count: PaymentAllocationCountAggregateOutputType | null
    _avg: PaymentAllocationAvgAggregateOutputType | null
    _sum: PaymentAllocationSumAggregateOutputType | null
    _min: PaymentAllocationMinAggregateOutputType | null
    _max: PaymentAllocationMaxAggregateOutputType | null
  }

  type GetPaymentAllocationGroupByPayload<T extends PaymentAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAllocationGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    targetType?: boolean
    targetId?: boolean
    amount?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAllocation"]>

  export type PaymentAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    targetType?: boolean
    targetId?: boolean
    amount?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAllocation"]>

  export type PaymentAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    targetType?: boolean
    targetId?: boolean
    amount?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAllocation"]>

  export type PaymentAllocationSelectScalar = {
    id?: boolean
    paymentId?: boolean
    targetType?: boolean
    targetId?: boolean
    amount?: boolean
  }

  export type PaymentAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "targetType" | "targetId" | "amount", ExtArgs["result"]["paymentAllocation"]>
  export type PaymentAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type PaymentAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type PaymentAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $PaymentAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAllocation"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      targetType: $Enums.AllocationTargetType
      targetId: string
      amount: Prisma.Decimal
    }, ExtArgs["result"]["paymentAllocation"]>
    composites: {}
  }

  type PaymentAllocationGetPayload<S extends boolean | null | undefined | PaymentAllocationDefaultArgs> = $Result.GetResult<Prisma.$PaymentAllocationPayload, S>

  type PaymentAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentAllocationCountAggregateInputType | true
    }

  export interface PaymentAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAllocation'], meta: { name: 'PaymentAllocation' } }
    /**
     * Find zero or one PaymentAllocation that matches the filter.
     * @param {PaymentAllocationFindUniqueArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAllocationFindUniqueArgs>(args: SelectSubset<T, PaymentAllocationFindUniqueArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentAllocationFindUniqueOrThrowArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationFindFirstArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAllocationFindFirstArgs>(args?: SelectSubset<T, PaymentAllocationFindFirstArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationFindFirstOrThrowArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAllocations
     * const paymentAllocations = await prisma.paymentAllocation.findMany()
     * 
     * // Get first 10 PaymentAllocations
     * const paymentAllocations = await prisma.paymentAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAllocationWithIdOnly = await prisma.paymentAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAllocationFindManyArgs>(args?: SelectSubset<T, PaymentAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentAllocation.
     * @param {PaymentAllocationCreateArgs} args - Arguments to create a PaymentAllocation.
     * @example
     * // Create one PaymentAllocation
     * const PaymentAllocation = await prisma.paymentAllocation.create({
     *   data: {
     *     // ... data to create a PaymentAllocation
     *   }
     * })
     * 
     */
    create<T extends PaymentAllocationCreateArgs>(args: SelectSubset<T, PaymentAllocationCreateArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentAllocations.
     * @param {PaymentAllocationCreateManyArgs} args - Arguments to create many PaymentAllocations.
     * @example
     * // Create many PaymentAllocations
     * const paymentAllocation = await prisma.paymentAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAllocationCreateManyArgs>(args?: SelectSubset<T, PaymentAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentAllocations and returns the data saved in the database.
     * @param {PaymentAllocationCreateManyAndReturnArgs} args - Arguments to create many PaymentAllocations.
     * @example
     * // Create many PaymentAllocations
     * const paymentAllocation = await prisma.paymentAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentAllocations and only return the `id`
     * const paymentAllocationWithIdOnly = await prisma.paymentAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentAllocation.
     * @param {PaymentAllocationDeleteArgs} args - Arguments to delete one PaymentAllocation.
     * @example
     * // Delete one PaymentAllocation
     * const PaymentAllocation = await prisma.paymentAllocation.delete({
     *   where: {
     *     // ... filter to delete one PaymentAllocation
     *   }
     * })
     * 
     */
    delete<T extends PaymentAllocationDeleteArgs>(args: SelectSubset<T, PaymentAllocationDeleteArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentAllocation.
     * @param {PaymentAllocationUpdateArgs} args - Arguments to update one PaymentAllocation.
     * @example
     * // Update one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAllocationUpdateArgs>(args: SelectSubset<T, PaymentAllocationUpdateArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentAllocations.
     * @param {PaymentAllocationDeleteManyArgs} args - Arguments to filter PaymentAllocations to delete.
     * @example
     * // Delete a few PaymentAllocations
     * const { count } = await prisma.paymentAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAllocationDeleteManyArgs>(args?: SelectSubset<T, PaymentAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAllocations
     * const paymentAllocation = await prisma.paymentAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAllocationUpdateManyArgs>(args: SelectSubset<T, PaymentAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAllocations and returns the data updated in the database.
     * @param {PaymentAllocationUpdateManyAndReturnArgs} args - Arguments to update many PaymentAllocations.
     * @example
     * // Update many PaymentAllocations
     * const paymentAllocation = await prisma.paymentAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentAllocations and only return the `id`
     * const paymentAllocationWithIdOnly = await prisma.paymentAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentAllocation.
     * @param {PaymentAllocationUpsertArgs} args - Arguments to update or create a PaymentAllocation.
     * @example
     * // Update or create a PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.upsert({
     *   create: {
     *     // ... data to create a PaymentAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAllocation we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAllocationUpsertArgs>(args: SelectSubset<T, PaymentAllocationUpsertArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationCountArgs} args - Arguments to filter PaymentAllocations to count.
     * @example
     * // Count the number of PaymentAllocations
     * const count = await prisma.paymentAllocation.count({
     *   where: {
     *     // ... the filter for the PaymentAllocations we want to count
     *   }
     * })
    **/
    count<T extends PaymentAllocationCountArgs>(
      args?: Subset<T, PaymentAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAllocationAggregateArgs>(args: Subset<T, PaymentAllocationAggregateArgs>): Prisma.PrismaPromise<GetPaymentAllocationAggregateType<T>>

    /**
     * Group by PaymentAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAllocationGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAllocation model
   */
  readonly fields: PaymentAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAllocation model
   */
  interface PaymentAllocationFieldRefs {
    readonly id: FieldRef<"PaymentAllocation", 'String'>
    readonly paymentId: FieldRef<"PaymentAllocation", 'String'>
    readonly targetType: FieldRef<"PaymentAllocation", 'AllocationTargetType'>
    readonly targetId: FieldRef<"PaymentAllocation", 'String'>
    readonly amount: FieldRef<"PaymentAllocation", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAllocation findUnique
   */
  export type PaymentAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation findUniqueOrThrow
   */
  export type PaymentAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation findFirst
   */
  export type PaymentAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAllocations.
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAllocations.
     */
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * PaymentAllocation findFirstOrThrow
   */
  export type PaymentAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAllocations.
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAllocations.
     */
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * PaymentAllocation findMany
   */
  export type PaymentAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocations to fetch.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAllocations.
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * PaymentAllocation create
   */
  export type PaymentAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentAllocation.
     */
    data: XOR<PaymentAllocationCreateInput, PaymentAllocationUncheckedCreateInput>
  }

  /**
   * PaymentAllocation createMany
   */
  export type PaymentAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAllocations.
     */
    data: PaymentAllocationCreateManyInput | PaymentAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAllocation createManyAndReturn
   */
  export type PaymentAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentAllocations.
     */
    data: PaymentAllocationCreateManyInput | PaymentAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAllocation update
   */
  export type PaymentAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentAllocation.
     */
    data: XOR<PaymentAllocationUpdateInput, PaymentAllocationUncheckedUpdateInput>
    /**
     * Choose, which PaymentAllocation to update.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation updateMany
   */
  export type PaymentAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAllocations.
     */
    data: XOR<PaymentAllocationUpdateManyMutationInput, PaymentAllocationUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAllocations to update
     */
    where?: PaymentAllocationWhereInput
    /**
     * Limit how many PaymentAllocations to update.
     */
    limit?: number
  }

  /**
   * PaymentAllocation updateManyAndReturn
   */
  export type PaymentAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * The data used to update PaymentAllocations.
     */
    data: XOR<PaymentAllocationUpdateManyMutationInput, PaymentAllocationUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAllocations to update
     */
    where?: PaymentAllocationWhereInput
    /**
     * Limit how many PaymentAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAllocation upsert
   */
  export type PaymentAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentAllocation to update in case it exists.
     */
    where: PaymentAllocationWhereUniqueInput
    /**
     * In case the PaymentAllocation found by the `where` argument doesn't exist, create a new PaymentAllocation with this data.
     */
    create: XOR<PaymentAllocationCreateInput, PaymentAllocationUncheckedCreateInput>
    /**
     * In case the PaymentAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAllocationUpdateInput, PaymentAllocationUncheckedUpdateInput>
  }

  /**
   * PaymentAllocation delete
   */
  export type PaymentAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter which PaymentAllocation to delete.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation deleteMany
   */
  export type PaymentAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAllocations to delete
     */
    where?: PaymentAllocationWhereInput
    /**
     * Limit how many PaymentAllocations to delete.
     */
    limit?: number
  }

  /**
   * PaymentAllocation without action
   */
  export type PaymentAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAllocation
     */
    omit?: PaymentAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
  }


  /**
   * Model DocumentFile
   */

  export type AggregateDocumentFile = {
    _count: DocumentFileCountAggregateOutputType | null
    _min: DocumentFileMinAggregateOutputType | null
    _max: DocumentFileMaxAggregateOutputType | null
  }

  export type DocumentFileMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    ownerType: $Enums.DocOwnerType | null
    ownerId: string | null
    fileName: string | null
    mimeType: string | null
    storageUrl: string | null
    createdAt: Date | null
  }

  export type DocumentFileMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    ownerType: $Enums.DocOwnerType | null
    ownerId: string | null
    fileName: string | null
    mimeType: string | null
    storageUrl: string | null
    createdAt: Date | null
  }

  export type DocumentFileCountAggregateOutputType = {
    id: number
    companyId: number
    ownerType: number
    ownerId: number
    fileName: number
    mimeType: number
    storageUrl: number
    createdAt: number
    _all: number
  }


  export type DocumentFileMinAggregateInputType = {
    id?: true
    companyId?: true
    ownerType?: true
    ownerId?: true
    fileName?: true
    mimeType?: true
    storageUrl?: true
    createdAt?: true
  }

  export type DocumentFileMaxAggregateInputType = {
    id?: true
    companyId?: true
    ownerType?: true
    ownerId?: true
    fileName?: true
    mimeType?: true
    storageUrl?: true
    createdAt?: true
  }

  export type DocumentFileCountAggregateInputType = {
    id?: true
    companyId?: true
    ownerType?: true
    ownerId?: true
    fileName?: true
    mimeType?: true
    storageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentFile to aggregate.
     */
    where?: DocumentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFiles to fetch.
     */
    orderBy?: DocumentFileOrderByWithRelationInput | DocumentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentFiles
    **/
    _count?: true | DocumentFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentFileMaxAggregateInputType
  }

  export type GetDocumentFileAggregateType<T extends DocumentFileAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentFile[P]>
      : GetScalarType<T[P], AggregateDocumentFile[P]>
  }




  export type DocumentFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentFileWhereInput
    orderBy?: DocumentFileOrderByWithAggregationInput | DocumentFileOrderByWithAggregationInput[]
    by: DocumentFileScalarFieldEnum[] | DocumentFileScalarFieldEnum
    having?: DocumentFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentFileCountAggregateInputType | true
    _min?: DocumentFileMinAggregateInputType
    _max?: DocumentFileMaxAggregateInputType
  }

  export type DocumentFileGroupByOutputType = {
    id: string
    companyId: string
    ownerType: $Enums.DocOwnerType
    ownerId: string
    fileName: string
    mimeType: string
    storageUrl: string
    createdAt: Date
    _count: DocumentFileCountAggregateOutputType | null
    _min: DocumentFileMinAggregateOutputType | null
    _max: DocumentFileMaxAggregateOutputType | null
  }

  type GetDocumentFileGroupByPayload<T extends DocumentFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentFileGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentFileGroupByOutputType[P]>
        }
      >
    >


  export type DocumentFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    ownerType?: boolean
    ownerId?: boolean
    fileName?: boolean
    mimeType?: boolean
    storageUrl?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentFile"]>

  export type DocumentFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    ownerType?: boolean
    ownerId?: boolean
    fileName?: boolean
    mimeType?: boolean
    storageUrl?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentFile"]>

  export type DocumentFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    ownerType?: boolean
    ownerId?: boolean
    fileName?: boolean
    mimeType?: boolean
    storageUrl?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentFile"]>

  export type DocumentFileSelectScalar = {
    id?: boolean
    companyId?: boolean
    ownerType?: boolean
    ownerId?: boolean
    fileName?: boolean
    mimeType?: boolean
    storageUrl?: boolean
    createdAt?: boolean
  }

  export type DocumentFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "ownerType" | "ownerId" | "fileName" | "mimeType" | "storageUrl" | "createdAt", ExtArgs["result"]["documentFile"]>
  export type DocumentFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DocumentFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DocumentFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DocumentFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentFile"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      ownerType: $Enums.DocOwnerType
      ownerId: string
      fileName: string
      mimeType: string
      storageUrl: string
      createdAt: Date
    }, ExtArgs["result"]["documentFile"]>
    composites: {}
  }

  type DocumentFileGetPayload<S extends boolean | null | undefined | DocumentFileDefaultArgs> = $Result.GetResult<Prisma.$DocumentFilePayload, S>

  type DocumentFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentFileCountAggregateInputType | true
    }

  export interface DocumentFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentFile'], meta: { name: 'DocumentFile' } }
    /**
     * Find zero or one DocumentFile that matches the filter.
     * @param {DocumentFileFindUniqueArgs} args - Arguments to find a DocumentFile
     * @example
     * // Get one DocumentFile
     * const documentFile = await prisma.documentFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFileFindUniqueArgs>(args: SelectSubset<T, DocumentFileFindUniqueArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFileFindUniqueOrThrowArgs} args - Arguments to find a DocumentFile
     * @example
     * // Get one DocumentFile
     * const documentFile = await prisma.documentFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFileFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFileFindFirstArgs} args - Arguments to find a DocumentFile
     * @example
     * // Get one DocumentFile
     * const documentFile = await prisma.documentFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFileFindFirstArgs>(args?: SelectSubset<T, DocumentFileFindFirstArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFileFindFirstOrThrowArgs} args - Arguments to find a DocumentFile
     * @example
     * // Get one DocumentFile
     * const documentFile = await prisma.documentFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFileFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentFiles
     * const documentFiles = await prisma.documentFile.findMany()
     * 
     * // Get first 10 DocumentFiles
     * const documentFiles = await prisma.documentFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentFileWithIdOnly = await prisma.documentFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFileFindManyArgs>(args?: SelectSubset<T, DocumentFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentFile.
     * @param {DocumentFileCreateArgs} args - Arguments to create a DocumentFile.
     * @example
     * // Create one DocumentFile
     * const DocumentFile = await prisma.documentFile.create({
     *   data: {
     *     // ... data to create a DocumentFile
     *   }
     * })
     * 
     */
    create<T extends DocumentFileCreateArgs>(args: SelectSubset<T, DocumentFileCreateArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentFiles.
     * @param {DocumentFileCreateManyArgs} args - Arguments to create many DocumentFiles.
     * @example
     * // Create many DocumentFiles
     * const documentFile = await prisma.documentFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentFileCreateManyArgs>(args?: SelectSubset<T, DocumentFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentFiles and returns the data saved in the database.
     * @param {DocumentFileCreateManyAndReturnArgs} args - Arguments to create many DocumentFiles.
     * @example
     * // Create many DocumentFiles
     * const documentFile = await prisma.documentFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentFiles and only return the `id`
     * const documentFileWithIdOnly = await prisma.documentFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentFileCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentFile.
     * @param {DocumentFileDeleteArgs} args - Arguments to delete one DocumentFile.
     * @example
     * // Delete one DocumentFile
     * const DocumentFile = await prisma.documentFile.delete({
     *   where: {
     *     // ... filter to delete one DocumentFile
     *   }
     * })
     * 
     */
    delete<T extends DocumentFileDeleteArgs>(args: SelectSubset<T, DocumentFileDeleteArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentFile.
     * @param {DocumentFileUpdateArgs} args - Arguments to update one DocumentFile.
     * @example
     * // Update one DocumentFile
     * const documentFile = await prisma.documentFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentFileUpdateArgs>(args: SelectSubset<T, DocumentFileUpdateArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentFiles.
     * @param {DocumentFileDeleteManyArgs} args - Arguments to filter DocumentFiles to delete.
     * @example
     * // Delete a few DocumentFiles
     * const { count } = await prisma.documentFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentFileDeleteManyArgs>(args?: SelectSubset<T, DocumentFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentFiles
     * const documentFile = await prisma.documentFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentFileUpdateManyArgs>(args: SelectSubset<T, DocumentFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentFiles and returns the data updated in the database.
     * @param {DocumentFileUpdateManyAndReturnArgs} args - Arguments to update many DocumentFiles.
     * @example
     * // Update many DocumentFiles
     * const documentFile = await prisma.documentFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentFiles and only return the `id`
     * const documentFileWithIdOnly = await prisma.documentFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentFileUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentFile.
     * @param {DocumentFileUpsertArgs} args - Arguments to update or create a DocumentFile.
     * @example
     * // Update or create a DocumentFile
     * const documentFile = await prisma.documentFile.upsert({
     *   create: {
     *     // ... data to create a DocumentFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentFile we want to update
     *   }
     * })
     */
    upsert<T extends DocumentFileUpsertArgs>(args: SelectSubset<T, DocumentFileUpsertArgs<ExtArgs>>): Prisma__DocumentFileClient<$Result.GetResult<Prisma.$DocumentFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFileCountArgs} args - Arguments to filter DocumentFiles to count.
     * @example
     * // Count the number of DocumentFiles
     * const count = await prisma.documentFile.count({
     *   where: {
     *     // ... the filter for the DocumentFiles we want to count
     *   }
     * })
    **/
    count<T extends DocumentFileCountArgs>(
      args?: Subset<T, DocumentFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentFileAggregateArgs>(args: Subset<T, DocumentFileAggregateArgs>): Prisma.PrismaPromise<GetDocumentFileAggregateType<T>>

    /**
     * Group by DocumentFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentFileGroupByArgs['orderBy'] }
        : { orderBy?: DocumentFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentFile model
   */
  readonly fields: DocumentFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentFile model
   */
  interface DocumentFileFieldRefs {
    readonly id: FieldRef<"DocumentFile", 'String'>
    readonly companyId: FieldRef<"DocumentFile", 'String'>
    readonly ownerType: FieldRef<"DocumentFile", 'DocOwnerType'>
    readonly ownerId: FieldRef<"DocumentFile", 'String'>
    readonly fileName: FieldRef<"DocumentFile", 'String'>
    readonly mimeType: FieldRef<"DocumentFile", 'String'>
    readonly storageUrl: FieldRef<"DocumentFile", 'String'>
    readonly createdAt: FieldRef<"DocumentFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentFile findUnique
   */
  export type DocumentFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFile to fetch.
     */
    where: DocumentFileWhereUniqueInput
  }

  /**
   * DocumentFile findUniqueOrThrow
   */
  export type DocumentFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFile to fetch.
     */
    where: DocumentFileWhereUniqueInput
  }

  /**
   * DocumentFile findFirst
   */
  export type DocumentFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFile to fetch.
     */
    where?: DocumentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFiles to fetch.
     */
    orderBy?: DocumentFileOrderByWithRelationInput | DocumentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentFiles.
     */
    cursor?: DocumentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentFiles.
     */
    distinct?: DocumentFileScalarFieldEnum | DocumentFileScalarFieldEnum[]
  }

  /**
   * DocumentFile findFirstOrThrow
   */
  export type DocumentFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFile to fetch.
     */
    where?: DocumentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFiles to fetch.
     */
    orderBy?: DocumentFileOrderByWithRelationInput | DocumentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentFiles.
     */
    cursor?: DocumentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentFiles.
     */
    distinct?: DocumentFileScalarFieldEnum | DocumentFileScalarFieldEnum[]
  }

  /**
   * DocumentFile findMany
   */
  export type DocumentFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * Filter, which DocumentFiles to fetch.
     */
    where?: DocumentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentFiles to fetch.
     */
    orderBy?: DocumentFileOrderByWithRelationInput | DocumentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentFiles.
     */
    cursor?: DocumentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentFiles.
     */
    skip?: number
    distinct?: DocumentFileScalarFieldEnum | DocumentFileScalarFieldEnum[]
  }

  /**
   * DocumentFile create
   */
  export type DocumentFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentFile.
     */
    data: XOR<DocumentFileCreateInput, DocumentFileUncheckedCreateInput>
  }

  /**
   * DocumentFile createMany
   */
  export type DocumentFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentFiles.
     */
    data: DocumentFileCreateManyInput | DocumentFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentFile createManyAndReturn
   */
  export type DocumentFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentFiles.
     */
    data: DocumentFileCreateManyInput | DocumentFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentFile update
   */
  export type DocumentFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentFile.
     */
    data: XOR<DocumentFileUpdateInput, DocumentFileUncheckedUpdateInput>
    /**
     * Choose, which DocumentFile to update.
     */
    where: DocumentFileWhereUniqueInput
  }

  /**
   * DocumentFile updateMany
   */
  export type DocumentFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentFiles.
     */
    data: XOR<DocumentFileUpdateManyMutationInput, DocumentFileUncheckedUpdateManyInput>
    /**
     * Filter which DocumentFiles to update
     */
    where?: DocumentFileWhereInput
    /**
     * Limit how many DocumentFiles to update.
     */
    limit?: number
  }

  /**
   * DocumentFile updateManyAndReturn
   */
  export type DocumentFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * The data used to update DocumentFiles.
     */
    data: XOR<DocumentFileUpdateManyMutationInput, DocumentFileUncheckedUpdateManyInput>
    /**
     * Filter which DocumentFiles to update
     */
    where?: DocumentFileWhereInput
    /**
     * Limit how many DocumentFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentFile upsert
   */
  export type DocumentFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentFile to update in case it exists.
     */
    where: DocumentFileWhereUniqueInput
    /**
     * In case the DocumentFile found by the `where` argument doesn't exist, create a new DocumentFile with this data.
     */
    create: XOR<DocumentFileCreateInput, DocumentFileUncheckedCreateInput>
    /**
     * In case the DocumentFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentFileUpdateInput, DocumentFileUncheckedUpdateInput>
  }

  /**
   * DocumentFile delete
   */
  export type DocumentFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
    /**
     * Filter which DocumentFile to delete.
     */
    where: DocumentFileWhereUniqueInput
  }

  /**
   * DocumentFile deleteMany
   */
  export type DocumentFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentFiles to delete
     */
    where?: DocumentFileWhereInput
    /**
     * Limit how many DocumentFiles to delete.
     */
    limit?: number
  }

  /**
   * DocumentFile without action
   */
  export type DocumentFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentFile
     */
    select?: DocumentFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentFile
     */
    omit?: DocumentFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentFileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    contactType: 'contactType',
    displayName: 'displayName',
    email: 'email',
    phone: 'phone',
    gstin: 'gstin',
    billingAddress: 'billingAddress',
    shippingAddress: 'shippingAddress',
    isPortalUser: 'isPortalUser',
    portalUserExternalId: 'portalUserExternalId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    parentId: 'parentId'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    sku: 'sku',
    name: 'name',
    categoryId: 'categoryId',
    uom: 'uom',
    salePrice: 'salePrice',
    costPrice: 'costPrice',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const AnalyticAccountScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    code: 'code',
    name: 'name',
    parentId: 'parentId',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AnalyticAccountScalarFieldEnum = (typeof AnalyticAccountScalarFieldEnum)[keyof typeof AnalyticAccountScalarFieldEnum]


  export const GLAccountScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    code: 'code',
    name: 'name',
    accountType: 'accountType',
    isActive: 'isActive'
  };

  export type GLAccountScalarFieldEnum = (typeof GLAccountScalarFieldEnum)[keyof typeof GLAccountScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    entryDate: 'entryDate',
    status: 'status',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    memo: 'memo',
    createdAt: 'createdAt',
    postedAt: 'postedAt'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const JournalLineScalarFieldEnum: {
    id: 'id',
    journalEntryId: 'journalEntryId',
    glAccountId: 'glAccountId',
    analyticAccountId: 'analyticAccountId',
    contactId: 'contactId',
    productId: 'productId',
    description: 'description',
    debit: 'debit',
    credit: 'credit'
  };

  export type JournalLineScalarFieldEnum = (typeof JournalLineScalarFieldEnum)[keyof typeof JournalLineScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    approvedAt: 'approvedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BudgetRevisionScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    revisionNo: 'revisionNo',
    revisionReason: 'revisionReason',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type BudgetRevisionScalarFieldEnum = (typeof BudgetRevisionScalarFieldEnum)[keyof typeof BudgetRevisionScalarFieldEnum]


  export const BudgetLineScalarFieldEnum: {
    id: 'id',
    budgetRevisionId: 'budgetRevisionId',
    analyticAccountId: 'analyticAccountId',
    glAccountId: 'glAccountId',
    amount: 'amount'
  };

  export type BudgetLineScalarFieldEnum = (typeof BudgetLineScalarFieldEnum)[keyof typeof BudgetLineScalarFieldEnum]


  export const AutoAnalyticModelScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    priority: 'priority',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AutoAnalyticModelScalarFieldEnum = (typeof AutoAnalyticModelScalarFieldEnum)[keyof typeof AutoAnalyticModelScalarFieldEnum]


  export const AutoAnalyticRuleScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    docType: 'docType',
    matchProductId: 'matchProductId',
    matchCategoryId: 'matchCategoryId',
    matchContactId: 'matchContactId',
    assignAnalyticAccountId: 'assignAnalyticAccountId',
    rulePriority: 'rulePriority',
    isActive: 'isActive'
  };

  export type AutoAnalyticRuleScalarFieldEnum = (typeof AutoAnalyticRuleScalarFieldEnum)[keyof typeof AutoAnalyticRuleScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    poNo: 'poNo',
    vendorId: 'vendorId',
    orderDate: 'orderDate',
    status: 'status',
    currency: 'currency',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderLineScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    analyticAccountId: 'analyticAccountId',
    description: 'description',
    qty: 'qty',
    unitPrice: 'unitPrice',
    taxRate: 'taxRate',
    lineTotal: 'lineTotal'
  };

  export type PurchaseOrderLineScalarFieldEnum = (typeof PurchaseOrderLineScalarFieldEnum)[keyof typeof PurchaseOrderLineScalarFieldEnum]


  export const SalesOrderScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    soNo: 'soNo',
    customerId: 'customerId',
    orderDate: 'orderDate',
    status: 'status',
    currency: 'currency',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type SalesOrderScalarFieldEnum = (typeof SalesOrderScalarFieldEnum)[keyof typeof SalesOrderScalarFieldEnum]


  export const SalesOrderLineScalarFieldEnum: {
    id: 'id',
    salesOrderId: 'salesOrderId',
    productId: 'productId',
    analyticAccountId: 'analyticAccountId',
    description: 'description',
    qty: 'qty',
    unitPrice: 'unitPrice',
    taxRate: 'taxRate',
    lineTotal: 'lineTotal'
  };

  export type SalesOrderLineScalarFieldEnum = (typeof SalesOrderLineScalarFieldEnum)[keyof typeof SalesOrderLineScalarFieldEnum]


  export const VendorBillScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    billNo: 'billNo',
    vendorId: 'vendorId',
    billDate: 'billDate',
    dueDate: 'dueDate',
    status: 'status',
    currency: 'currency',
    poId: 'poId',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    paymentState: 'paymentState',
    createdAt: 'createdAt'
  };

  export type VendorBillScalarFieldEnum = (typeof VendorBillScalarFieldEnum)[keyof typeof VendorBillScalarFieldEnum]


  export const VendorBillLineScalarFieldEnum: {
    id: 'id',
    vendorBillId: 'vendorBillId',
    productId: 'productId',
    analyticAccountId: 'analyticAccountId',
    glAccountId: 'glAccountId',
    description: 'description',
    qty: 'qty',
    unitPrice: 'unitPrice',
    taxRate: 'taxRate',
    lineTotal: 'lineTotal'
  };

  export type VendorBillLineScalarFieldEnum = (typeof VendorBillLineScalarFieldEnum)[keyof typeof VendorBillLineScalarFieldEnum]


  export const CustomerInvoiceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    invoiceNo: 'invoiceNo',
    customerId: 'customerId',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    status: 'status',
    currency: 'currency',
    soId: 'soId',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    paymentState: 'paymentState',
    portalVisible: 'portalVisible',
    createdAt: 'createdAt'
  };

  export type CustomerInvoiceScalarFieldEnum = (typeof CustomerInvoiceScalarFieldEnum)[keyof typeof CustomerInvoiceScalarFieldEnum]


  export const CustomerInvoiceLineScalarFieldEnum: {
    id: 'id',
    customerInvoiceId: 'customerInvoiceId',
    productId: 'productId',
    analyticAccountId: 'analyticAccountId',
    glAccountId: 'glAccountId',
    description: 'description',
    qty: 'qty',
    unitPrice: 'unitPrice',
    taxRate: 'taxRate',
    lineTotal: 'lineTotal'
  };

  export type CustomerInvoiceLineScalarFieldEnum = (typeof CustomerInvoiceLineScalarFieldEnum)[keyof typeof CustomerInvoiceLineScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    direction: 'direction',
    contactId: 'contactId',
    paymentDate: 'paymentDate',
    method: 'method',
    reference: 'reference',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentAllocationScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    targetType: 'targetType',
    targetId: 'targetId',
    amount: 'amount'
  };

  export type PaymentAllocationScalarFieldEnum = (typeof PaymentAllocationScalarFieldEnum)[keyof typeof PaymentAllocationScalarFieldEnum]


  export const DocumentFileScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    ownerType: 'ownerType',
    ownerId: 'ownerId',
    fileName: 'fileName',
    mimeType: 'mimeType',
    storageUrl: 'storageUrl',
    createdAt: 'createdAt'
  };

  export type DocumentFileScalarFieldEnum = (typeof DocumentFileScalarFieldEnum)[keyof typeof DocumentFileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'JournalStatus'
   */
  export type EnumJournalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalStatus'>
    


  /**
   * Reference to a field of type 'JournalStatus[]'
   */
  export type ListEnumJournalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalStatus[]'>
    


  /**
   * Reference to a field of type 'JournalSourceType'
   */
  export type EnumJournalSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalSourceType'>
    


  /**
   * Reference to a field of type 'JournalSourceType[]'
   */
  export type ListEnumJournalSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalSourceType[]'>
    


  /**
   * Reference to a field of type 'BudgetStatus'
   */
  export type EnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus'>
    


  /**
   * Reference to a field of type 'BudgetStatus[]'
   */
  export type ListEnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AutoDocType'
   */
  export type EnumAutoDocTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutoDocType'>
    


  /**
   * Reference to a field of type 'AutoDocType[]'
   */
  export type ListEnumAutoDocTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutoDocType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'DocStatus'
   */
  export type EnumDocStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocStatus'>
    


  /**
   * Reference to a field of type 'DocStatus[]'
   */
  export type ListEnumDocStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentDirection'
   */
  export type EnumPaymentDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentDirection'>
    


  /**
   * Reference to a field of type 'PaymentDirection[]'
   */
  export type ListEnumPaymentDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentDirection[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'AllocationTargetType'
   */
  export type EnumAllocationTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllocationTargetType'>
    


  /**
   * Reference to a field of type 'AllocationTargetType[]'
   */
  export type ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllocationTargetType[]'>
    


  /**
   * Reference to a field of type 'DocOwnerType'
   */
  export type EnumDocOwnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocOwnerType'>
    


  /**
   * Reference to a field of type 'DocOwnerType[]'
   */
  export type ListEnumDocOwnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocOwnerType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: UuidFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    contacts?: ContactListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    analyticAccounts?: AnalyticAccountListRelationFilter
    glAccounts?: GLAccountListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    budgets?: BudgetListRelationFilter
    autoAnalyticModels?: AutoAnalyticModelListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
    vendorBills?: VendorBillListRelationFilter
    customerInvoices?: CustomerInvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    documentFiles?: DocumentFileListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    contacts?: ContactOrderByRelationAggregateInput
    productCategories?: ProductCategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    analyticAccounts?: AnalyticAccountOrderByRelationAggregateInput
    glAccounts?: GLAccountOrderByRelationAggregateInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    autoAnalyticModels?: AutoAnalyticModelOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    salesOrders?: SalesOrderOrderByRelationAggregateInput
    vendorBills?: VendorBillOrderByRelationAggregateInput
    customerInvoices?: CustomerInvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    documentFiles?: DocumentFileOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    contacts?: ContactListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    analyticAccounts?: AnalyticAccountListRelationFilter
    glAccounts?: GLAccountListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    budgets?: BudgetListRelationFilter
    autoAnalyticModels?: AutoAnalyticModelListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
    vendorBills?: VendorBillListRelationFilter
    customerInvoices?: CustomerInvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    documentFiles?: DocumentFileListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: UuidFilter<"Contact"> | string
    companyId?: UuidFilter<"Contact"> | string
    contactType?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    displayName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    gstin?: StringNullableFilter<"Contact"> | string | null
    billingAddress?: JsonNullableFilter<"Contact">
    shippingAddress?: JsonNullableFilter<"Contact">
    isPortalUser?: BoolFilter<"Contact"> | boolean
    portalUserExternalId?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vendorPurchaseOrders?: PurchaseOrderListRelationFilter
    customerSalesOrders?: SalesOrderListRelationFilter
    vendorBills?: VendorBillListRelationFilter
    customerInvoices?: CustomerInvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    journalLines?: JournalLineListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactType?: SortOrder
    displayName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    isPortalUser?: SortOrder
    portalUserExternalId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    vendorPurchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    customerSalesOrders?: SalesOrderOrderByRelationAggregateInput
    vendorBills?: VendorBillOrderByRelationAggregateInput
    customerInvoices?: CustomerInvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    autoAnalyticRules?: AutoAnalyticRuleOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_email?: ContactCompanyIdEmailCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    companyId?: UuidFilter<"Contact"> | string
    contactType?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    displayName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    gstin?: StringNullableFilter<"Contact"> | string | null
    billingAddress?: JsonNullableFilter<"Contact">
    shippingAddress?: JsonNullableFilter<"Contact">
    isPortalUser?: BoolFilter<"Contact"> | boolean
    portalUserExternalId?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vendorPurchaseOrders?: PurchaseOrderListRelationFilter
    customerSalesOrders?: SalesOrderListRelationFilter
    vendorBills?: VendorBillListRelationFilter
    customerInvoices?: CustomerInvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    journalLines?: JournalLineListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }, "id" | "companyId_email">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactType?: SortOrder
    displayName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    isPortalUser?: SortOrder
    portalUserExternalId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Contact"> | string
    companyId?: UuidWithAggregatesFilter<"Contact"> | string
    contactType?: EnumContactTypeWithAggregatesFilter<"Contact"> | $Enums.ContactType
    displayName?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    gstin?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    billingAddress?: JsonNullableWithAggregatesFilter<"Contact">
    shippingAddress?: JsonNullableWithAggregatesFilter<"Contact">
    isPortalUser?: BoolWithAggregatesFilter<"Contact"> | boolean
    portalUserExternalId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isActive?: BoolWithAggregatesFilter<"Contact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: UuidFilter<"ProductCategory"> | string
    companyId?: UuidFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    parentId?: UuidNullableFilter<"ProductCategory"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    parent?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    parent?: ProductCategoryOrderByWithRelationInput
    children?: ProductCategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    autoAnalyticRules?: AutoAnalyticRuleOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_name?: ProductCategoryCompanyIdNameCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    companyId?: UuidFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    parentId?: UuidNullableFilter<"ProductCategory"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    parent?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }, "id" | "companyId_name">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductCategory"> | string
    companyId?: UuidWithAggregatesFilter<"ProductCategory"> | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    parentId?: UuidNullableWithAggregatesFilter<"ProductCategory"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    companyId?: UuidFilter<"Product"> | string
    sku?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    categoryId?: UuidNullableFilter<"Product"> | string | null
    uom?: StringFilter<"Product"> | string
    salePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    poLines?: PurchaseOrderLineListRelationFilter
    soLines?: SalesOrderLineListRelationFilter
    billLines?: VendorBillLineListRelationFilter
    invLines?: CustomerInvoiceLineListRelationFilter
    journalLines?: JournalLineListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    uom?: SortOrder
    salePrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    poLines?: PurchaseOrderLineOrderByRelationAggregateInput
    soLines?: SalesOrderLineOrderByRelationAggregateInput
    billLines?: VendorBillLineOrderByRelationAggregateInput
    invLines?: CustomerInvoiceLineOrderByRelationAggregateInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    autoAnalyticRules?: AutoAnalyticRuleOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_sku?: ProductCompanyIdSkuCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    companyId?: UuidFilter<"Product"> | string
    sku?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    categoryId?: UuidNullableFilter<"Product"> | string | null
    uom?: StringFilter<"Product"> | string
    salePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    poLines?: PurchaseOrderLineListRelationFilter
    soLines?: SalesOrderLineListRelationFilter
    billLines?: VendorBillLineListRelationFilter
    invLines?: CustomerInvoiceLineListRelationFilter
    journalLines?: JournalLineListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }, "id" | "companyId_sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    uom?: SortOrder
    salePrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    companyId?: UuidWithAggregatesFilter<"Product"> | string
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    categoryId?: UuidNullableWithAggregatesFilter<"Product"> | string | null
    uom?: StringWithAggregatesFilter<"Product"> | string
    salePrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type AnalyticAccountWhereInput = {
    AND?: AnalyticAccountWhereInput | AnalyticAccountWhereInput[]
    OR?: AnalyticAccountWhereInput[]
    NOT?: AnalyticAccountWhereInput | AnalyticAccountWhereInput[]
    id?: UuidFilter<"AnalyticAccount"> | string
    companyId?: UuidFilter<"AnalyticAccount"> | string
    code?: StringNullableFilter<"AnalyticAccount"> | string | null
    name?: StringFilter<"AnalyticAccount"> | string
    parentId?: UuidNullableFilter<"AnalyticAccount"> | string | null
    isActive?: BoolFilter<"AnalyticAccount"> | boolean
    createdAt?: DateTimeFilter<"AnalyticAccount"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    parent?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    children?: AnalyticAccountListRelationFilter
    budgetLines?: BudgetLineListRelationFilter
    journalLines?: JournalLineListRelationFilter
    poLines?: PurchaseOrderLineListRelationFilter
    soLines?: SalesOrderLineListRelationFilter
    billLines?: VendorBillLineListRelationFilter
    invLines?: CustomerInvoiceLineListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }

  export type AnalyticAccountOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    parent?: AnalyticAccountOrderByWithRelationInput
    children?: AnalyticAccountOrderByRelationAggregateInput
    budgetLines?: BudgetLineOrderByRelationAggregateInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    poLines?: PurchaseOrderLineOrderByRelationAggregateInput
    soLines?: SalesOrderLineOrderByRelationAggregateInput
    billLines?: VendorBillLineOrderByRelationAggregateInput
    invLines?: CustomerInvoiceLineOrderByRelationAggregateInput
    autoAnalyticRules?: AutoAnalyticRuleOrderByRelationAggregateInput
  }

  export type AnalyticAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: AnalyticAccountCompanyIdCodeCompoundUniqueInput
    companyId_name?: AnalyticAccountCompanyIdNameCompoundUniqueInput
    AND?: AnalyticAccountWhereInput | AnalyticAccountWhereInput[]
    OR?: AnalyticAccountWhereInput[]
    NOT?: AnalyticAccountWhereInput | AnalyticAccountWhereInput[]
    companyId?: UuidFilter<"AnalyticAccount"> | string
    code?: StringNullableFilter<"AnalyticAccount"> | string | null
    name?: StringFilter<"AnalyticAccount"> | string
    parentId?: UuidNullableFilter<"AnalyticAccount"> | string | null
    isActive?: BoolFilter<"AnalyticAccount"> | boolean
    createdAt?: DateTimeFilter<"AnalyticAccount"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    parent?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    children?: AnalyticAccountListRelationFilter
    budgetLines?: BudgetLineListRelationFilter
    journalLines?: JournalLineListRelationFilter
    poLines?: PurchaseOrderLineListRelationFilter
    soLines?: SalesOrderLineListRelationFilter
    billLines?: VendorBillLineListRelationFilter
    invLines?: CustomerInvoiceLineListRelationFilter
    autoAnalyticRules?: AutoAnalyticRuleListRelationFilter
  }, "id" | "companyId_code" | "companyId_name">

  export type AnalyticAccountOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AnalyticAccountCountOrderByAggregateInput
    _max?: AnalyticAccountMaxOrderByAggregateInput
    _min?: AnalyticAccountMinOrderByAggregateInput
  }

  export type AnalyticAccountScalarWhereWithAggregatesInput = {
    AND?: AnalyticAccountScalarWhereWithAggregatesInput | AnalyticAccountScalarWhereWithAggregatesInput[]
    OR?: AnalyticAccountScalarWhereWithAggregatesInput[]
    NOT?: AnalyticAccountScalarWhereWithAggregatesInput | AnalyticAccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AnalyticAccount"> | string
    companyId?: UuidWithAggregatesFilter<"AnalyticAccount"> | string
    code?: StringNullableWithAggregatesFilter<"AnalyticAccount"> | string | null
    name?: StringWithAggregatesFilter<"AnalyticAccount"> | string
    parentId?: UuidNullableWithAggregatesFilter<"AnalyticAccount"> | string | null
    isActive?: BoolWithAggregatesFilter<"AnalyticAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticAccount"> | Date | string
  }

  export type GLAccountWhereInput = {
    AND?: GLAccountWhereInput | GLAccountWhereInput[]
    OR?: GLAccountWhereInput[]
    NOT?: GLAccountWhereInput | GLAccountWhereInput[]
    id?: UuidFilter<"GLAccount"> | string
    companyId?: UuidFilter<"GLAccount"> | string
    code?: StringFilter<"GLAccount"> | string
    name?: StringFilter<"GLAccount"> | string
    accountType?: EnumAccountTypeFilter<"GLAccount"> | $Enums.AccountType
    isActive?: BoolFilter<"GLAccount"> | boolean
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    journalLines?: JournalLineListRelationFilter
    budgetLines?: BudgetLineListRelationFilter
    billLines?: VendorBillLineListRelationFilter
    invLines?: CustomerInvoiceLineListRelationFilter
  }

  export type GLAccountOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    company?: CompanyOrderByWithRelationInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    budgetLines?: BudgetLineOrderByRelationAggregateInput
    billLines?: VendorBillLineOrderByRelationAggregateInput
    invLines?: CustomerInvoiceLineOrderByRelationAggregateInput
  }

  export type GLAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: GLAccountCompanyIdCodeCompoundUniqueInput
    AND?: GLAccountWhereInput | GLAccountWhereInput[]
    OR?: GLAccountWhereInput[]
    NOT?: GLAccountWhereInput | GLAccountWhereInput[]
    companyId?: UuidFilter<"GLAccount"> | string
    code?: StringFilter<"GLAccount"> | string
    name?: StringFilter<"GLAccount"> | string
    accountType?: EnumAccountTypeFilter<"GLAccount"> | $Enums.AccountType
    isActive?: BoolFilter<"GLAccount"> | boolean
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    journalLines?: JournalLineListRelationFilter
    budgetLines?: BudgetLineListRelationFilter
    billLines?: VendorBillLineListRelationFilter
    invLines?: CustomerInvoiceLineListRelationFilter
  }, "id" | "companyId_code">

  export type GLAccountOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    _count?: GLAccountCountOrderByAggregateInput
    _max?: GLAccountMaxOrderByAggregateInput
    _min?: GLAccountMinOrderByAggregateInput
  }

  export type GLAccountScalarWhereWithAggregatesInput = {
    AND?: GLAccountScalarWhereWithAggregatesInput | GLAccountScalarWhereWithAggregatesInput[]
    OR?: GLAccountScalarWhereWithAggregatesInput[]
    NOT?: GLAccountScalarWhereWithAggregatesInput | GLAccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GLAccount"> | string
    companyId?: UuidWithAggregatesFilter<"GLAccount"> | string
    code?: StringWithAggregatesFilter<"GLAccount"> | string
    name?: StringWithAggregatesFilter<"GLAccount"> | string
    accountType?: EnumAccountTypeWithAggregatesFilter<"GLAccount"> | $Enums.AccountType
    isActive?: BoolWithAggregatesFilter<"GLAccount"> | boolean
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: UuidFilter<"JournalEntry"> | string
    companyId?: UuidFilter<"JournalEntry"> | string
    entryDate?: DateTimeFilter<"JournalEntry"> | Date | string
    status?: EnumJournalStatusFilter<"JournalEntry"> | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFilter<"JournalEntry"> | $Enums.JournalSourceType
    sourceId?: UuidNullableFilter<"JournalEntry"> | string | null
    memo?: StringNullableFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    postedAt?: DateTimeNullableFilter<"JournalEntry"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    lines?: JournalLineListRelationFilter
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    entryDate?: SortOrder
    status?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    memo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    lines?: JournalLineOrderByRelationAggregateInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    companyId?: UuidFilter<"JournalEntry"> | string
    entryDate?: DateTimeFilter<"JournalEntry"> | Date | string
    status?: EnumJournalStatusFilter<"JournalEntry"> | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFilter<"JournalEntry"> | $Enums.JournalSourceType
    sourceId?: UuidNullableFilter<"JournalEntry"> | string | null
    memo?: StringNullableFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    postedAt?: DateTimeNullableFilter<"JournalEntry"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    lines?: JournalLineListRelationFilter
  }, "id">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    entryDate?: SortOrder
    status?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    memo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"JournalEntry"> | string
    companyId?: UuidWithAggregatesFilter<"JournalEntry"> | string
    entryDate?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    status?: EnumJournalStatusWithAggregatesFilter<"JournalEntry"> | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeWithAggregatesFilter<"JournalEntry"> | $Enums.JournalSourceType
    sourceId?: UuidNullableWithAggregatesFilter<"JournalEntry"> | string | null
    memo?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    postedAt?: DateTimeNullableWithAggregatesFilter<"JournalEntry"> | Date | string | null
  }

  export type JournalLineWhereInput = {
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    id?: UuidFilter<"JournalLine"> | string
    journalEntryId?: UuidFilter<"JournalLine"> | string
    glAccountId?: UuidFilter<"JournalLine"> | string
    analyticAccountId?: UuidNullableFilter<"JournalLine"> | string | null
    contactId?: UuidNullableFilter<"JournalLine"> | string | null
    productId?: UuidNullableFilter<"JournalLine"> | string | null
    description?: StringNullableFilter<"JournalLine"> | string | null
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    entry?: XOR<JournalEntryScalarRelationFilter, JournalEntryWhereInput>
    gl?: XOR<GLAccountScalarRelationFilter, GLAccountWhereInput>
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type JournalLineOrderByWithRelationInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    glAccountId?: SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    debit?: SortOrder
    credit?: SortOrder
    entry?: JournalEntryOrderByWithRelationInput
    gl?: GLAccountOrderByWithRelationInput
    analytic?: AnalyticAccountOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type JournalLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    journalEntryId?: UuidFilter<"JournalLine"> | string
    glAccountId?: UuidFilter<"JournalLine"> | string
    analyticAccountId?: UuidNullableFilter<"JournalLine"> | string | null
    contactId?: UuidNullableFilter<"JournalLine"> | string | null
    productId?: UuidNullableFilter<"JournalLine"> | string | null
    description?: StringNullableFilter<"JournalLine"> | string | null
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    entry?: XOR<JournalEntryScalarRelationFilter, JournalEntryWhereInput>
    gl?: XOR<GLAccountScalarRelationFilter, GLAccountWhereInput>
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type JournalLineOrderByWithAggregationInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    glAccountId?: SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    debit?: SortOrder
    credit?: SortOrder
    _count?: JournalLineCountOrderByAggregateInput
    _avg?: JournalLineAvgOrderByAggregateInput
    _max?: JournalLineMaxOrderByAggregateInput
    _min?: JournalLineMinOrderByAggregateInput
    _sum?: JournalLineSumOrderByAggregateInput
  }

  export type JournalLineScalarWhereWithAggregatesInput = {
    AND?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    OR?: JournalLineScalarWhereWithAggregatesInput[]
    NOT?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"JournalLine"> | string
    journalEntryId?: UuidWithAggregatesFilter<"JournalLine"> | string
    glAccountId?: UuidWithAggregatesFilter<"JournalLine"> | string
    analyticAccountId?: UuidNullableWithAggregatesFilter<"JournalLine"> | string | null
    contactId?: UuidNullableWithAggregatesFilter<"JournalLine"> | string | null
    productId?: UuidNullableWithAggregatesFilter<"JournalLine"> | string | null
    description?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
    debit?: DecimalWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: UuidFilter<"Budget"> | string
    companyId?: UuidFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    periodStart?: DateTimeFilter<"Budget"> | Date | string
    periodEnd?: DateTimeFilter<"Budget"> | Date | string
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    createdBy?: UuidNullableFilter<"Budget"> | string | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Budget"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    revisions?: BudgetRevisionListRelationFilter
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    revisions?: BudgetRevisionOrderByRelationAggregateInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    companyId?: UuidFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    periodStart?: DateTimeFilter<"Budget"> | Date | string
    periodEnd?: DateTimeFilter<"Budget"> | Date | string
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    createdBy?: UuidNullableFilter<"Budget"> | string | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Budget"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    revisions?: BudgetRevisionListRelationFilter
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Budget"> | string
    companyId?: UuidWithAggregatesFilter<"Budget"> | string
    name?: StringWithAggregatesFilter<"Budget"> | string
    periodStart?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    status?: EnumBudgetStatusWithAggregatesFilter<"Budget"> | $Enums.BudgetStatus
    createdBy?: UuidNullableWithAggregatesFilter<"Budget"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Budget"> | Date | string | null
  }

  export type BudgetRevisionWhereInput = {
    AND?: BudgetRevisionWhereInput | BudgetRevisionWhereInput[]
    OR?: BudgetRevisionWhereInput[]
    NOT?: BudgetRevisionWhereInput | BudgetRevisionWhereInput[]
    id?: UuidFilter<"BudgetRevision"> | string
    budgetId?: UuidFilter<"BudgetRevision"> | string
    revisionNo?: IntFilter<"BudgetRevision"> | number
    revisionReason?: StringNullableFilter<"BudgetRevision"> | string | null
    createdAt?: DateTimeFilter<"BudgetRevision"> | Date | string
    createdBy?: UuidNullableFilter<"BudgetRevision"> | string | null
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
    lines?: BudgetLineListRelationFilter
  }

  export type BudgetRevisionOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    revisionNo?: SortOrder
    revisionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    budget?: BudgetOrderByWithRelationInput
    lines?: BudgetLineOrderByRelationAggregateInput
  }

  export type BudgetRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetId_revisionNo?: BudgetRevisionBudgetIdRevisionNoCompoundUniqueInput
    AND?: BudgetRevisionWhereInput | BudgetRevisionWhereInput[]
    OR?: BudgetRevisionWhereInput[]
    NOT?: BudgetRevisionWhereInput | BudgetRevisionWhereInput[]
    budgetId?: UuidFilter<"BudgetRevision"> | string
    revisionNo?: IntFilter<"BudgetRevision"> | number
    revisionReason?: StringNullableFilter<"BudgetRevision"> | string | null
    createdAt?: DateTimeFilter<"BudgetRevision"> | Date | string
    createdBy?: UuidNullableFilter<"BudgetRevision"> | string | null
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
    lines?: BudgetLineListRelationFilter
  }, "id" | "budgetId_revisionNo">

  export type BudgetRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    revisionNo?: SortOrder
    revisionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: BudgetRevisionCountOrderByAggregateInput
    _avg?: BudgetRevisionAvgOrderByAggregateInput
    _max?: BudgetRevisionMaxOrderByAggregateInput
    _min?: BudgetRevisionMinOrderByAggregateInput
    _sum?: BudgetRevisionSumOrderByAggregateInput
  }

  export type BudgetRevisionScalarWhereWithAggregatesInput = {
    AND?: BudgetRevisionScalarWhereWithAggregatesInput | BudgetRevisionScalarWhereWithAggregatesInput[]
    OR?: BudgetRevisionScalarWhereWithAggregatesInput[]
    NOT?: BudgetRevisionScalarWhereWithAggregatesInput | BudgetRevisionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BudgetRevision"> | string
    budgetId?: UuidWithAggregatesFilter<"BudgetRevision"> | string
    revisionNo?: IntWithAggregatesFilter<"BudgetRevision"> | number
    revisionReason?: StringNullableWithAggregatesFilter<"BudgetRevision"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BudgetRevision"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"BudgetRevision"> | string | null
  }

  export type BudgetLineWhereInput = {
    AND?: BudgetLineWhereInput | BudgetLineWhereInput[]
    OR?: BudgetLineWhereInput[]
    NOT?: BudgetLineWhereInput | BudgetLineWhereInput[]
    id?: UuidFilter<"BudgetLine"> | string
    budgetRevisionId?: UuidFilter<"BudgetLine"> | string
    analyticAccountId?: UuidFilter<"BudgetLine"> | string
    glAccountId?: UuidNullableFilter<"BudgetLine"> | string | null
    amount?: DecimalFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
    revision?: XOR<BudgetRevisionScalarRelationFilter, BudgetRevisionWhereInput>
    analytic?: XOR<AnalyticAccountScalarRelationFilter, AnalyticAccountWhereInput>
    gl?: XOR<GLAccountNullableScalarRelationFilter, GLAccountWhereInput> | null
  }

  export type BudgetLineOrderByWithRelationInput = {
    id?: SortOrder
    budgetRevisionId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrderInput | SortOrder
    amount?: SortOrder
    revision?: BudgetRevisionOrderByWithRelationInput
    analytic?: AnalyticAccountOrderByWithRelationInput
    gl?: GLAccountOrderByWithRelationInput
  }

  export type BudgetLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetRevisionId_analyticAccountId_glAccountId?: BudgetLineBudgetRevisionIdAnalyticAccountIdGlAccountIdCompoundUniqueInput
    AND?: BudgetLineWhereInput | BudgetLineWhereInput[]
    OR?: BudgetLineWhereInput[]
    NOT?: BudgetLineWhereInput | BudgetLineWhereInput[]
    budgetRevisionId?: UuidFilter<"BudgetLine"> | string
    analyticAccountId?: UuidFilter<"BudgetLine"> | string
    glAccountId?: UuidNullableFilter<"BudgetLine"> | string | null
    amount?: DecimalFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
    revision?: XOR<BudgetRevisionScalarRelationFilter, BudgetRevisionWhereInput>
    analytic?: XOR<AnalyticAccountScalarRelationFilter, AnalyticAccountWhereInput>
    gl?: XOR<GLAccountNullableScalarRelationFilter, GLAccountWhereInput> | null
  }, "id" | "budgetRevisionId_analyticAccountId_glAccountId">

  export type BudgetLineOrderByWithAggregationInput = {
    id?: SortOrder
    budgetRevisionId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrderInput | SortOrder
    amount?: SortOrder
    _count?: BudgetLineCountOrderByAggregateInput
    _avg?: BudgetLineAvgOrderByAggregateInput
    _max?: BudgetLineMaxOrderByAggregateInput
    _min?: BudgetLineMinOrderByAggregateInput
    _sum?: BudgetLineSumOrderByAggregateInput
  }

  export type BudgetLineScalarWhereWithAggregatesInput = {
    AND?: BudgetLineScalarWhereWithAggregatesInput | BudgetLineScalarWhereWithAggregatesInput[]
    OR?: BudgetLineScalarWhereWithAggregatesInput[]
    NOT?: BudgetLineScalarWhereWithAggregatesInput | BudgetLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BudgetLine"> | string
    budgetRevisionId?: UuidWithAggregatesFilter<"BudgetLine"> | string
    analyticAccountId?: UuidWithAggregatesFilter<"BudgetLine"> | string
    glAccountId?: UuidNullableWithAggregatesFilter<"BudgetLine"> | string | null
    amount?: DecimalWithAggregatesFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticModelWhereInput = {
    AND?: AutoAnalyticModelWhereInput | AutoAnalyticModelWhereInput[]
    OR?: AutoAnalyticModelWhereInput[]
    NOT?: AutoAnalyticModelWhereInput | AutoAnalyticModelWhereInput[]
    id?: UuidFilter<"AutoAnalyticModel"> | string
    companyId?: UuidFilter<"AutoAnalyticModel"> | string
    name?: StringFilter<"AutoAnalyticModel"> | string
    priority?: IntFilter<"AutoAnalyticModel"> | number
    isActive?: BoolFilter<"AutoAnalyticModel"> | boolean
    createdAt?: DateTimeFilter<"AutoAnalyticModel"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    rules?: AutoAnalyticRuleListRelationFilter
  }

  export type AutoAnalyticModelOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    rules?: AutoAnalyticRuleOrderByRelationAggregateInput
  }

  export type AutoAnalyticModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoAnalyticModelWhereInput | AutoAnalyticModelWhereInput[]
    OR?: AutoAnalyticModelWhereInput[]
    NOT?: AutoAnalyticModelWhereInput | AutoAnalyticModelWhereInput[]
    companyId?: UuidFilter<"AutoAnalyticModel"> | string
    name?: StringFilter<"AutoAnalyticModel"> | string
    priority?: IntFilter<"AutoAnalyticModel"> | number
    isActive?: BoolFilter<"AutoAnalyticModel"> | boolean
    createdAt?: DateTimeFilter<"AutoAnalyticModel"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    rules?: AutoAnalyticRuleListRelationFilter
  }, "id">

  export type AutoAnalyticModelOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AutoAnalyticModelCountOrderByAggregateInput
    _avg?: AutoAnalyticModelAvgOrderByAggregateInput
    _max?: AutoAnalyticModelMaxOrderByAggregateInput
    _min?: AutoAnalyticModelMinOrderByAggregateInput
    _sum?: AutoAnalyticModelSumOrderByAggregateInput
  }

  export type AutoAnalyticModelScalarWhereWithAggregatesInput = {
    AND?: AutoAnalyticModelScalarWhereWithAggregatesInput | AutoAnalyticModelScalarWhereWithAggregatesInput[]
    OR?: AutoAnalyticModelScalarWhereWithAggregatesInput[]
    NOT?: AutoAnalyticModelScalarWhereWithAggregatesInput | AutoAnalyticModelScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AutoAnalyticModel"> | string
    companyId?: UuidWithAggregatesFilter<"AutoAnalyticModel"> | string
    name?: StringWithAggregatesFilter<"AutoAnalyticModel"> | string
    priority?: IntWithAggregatesFilter<"AutoAnalyticModel"> | number
    isActive?: BoolWithAggregatesFilter<"AutoAnalyticModel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AutoAnalyticModel"> | Date | string
  }

  export type AutoAnalyticRuleWhereInput = {
    AND?: AutoAnalyticRuleWhereInput | AutoAnalyticRuleWhereInput[]
    OR?: AutoAnalyticRuleWhereInput[]
    NOT?: AutoAnalyticRuleWhereInput | AutoAnalyticRuleWhereInput[]
    id?: UuidFilter<"AutoAnalyticRule"> | string
    modelId?: UuidFilter<"AutoAnalyticRule"> | string
    docType?: EnumAutoDocTypeFilter<"AutoAnalyticRule"> | $Enums.AutoDocType
    matchProductId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    matchCategoryId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    matchContactId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    assignAnalyticAccountId?: UuidFilter<"AutoAnalyticRule"> | string
    rulePriority?: IntFilter<"AutoAnalyticRule"> | number
    isActive?: BoolFilter<"AutoAnalyticRule"> | boolean
    model?: XOR<AutoAnalyticModelScalarRelationFilter, AutoAnalyticModelWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    assignAnalytic?: XOR<AnalyticAccountScalarRelationFilter, AnalyticAccountWhereInput>
  }

  export type AutoAnalyticRuleOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    docType?: SortOrder
    matchProductId?: SortOrderInput | SortOrder
    matchCategoryId?: SortOrderInput | SortOrder
    matchContactId?: SortOrderInput | SortOrder
    assignAnalyticAccountId?: SortOrder
    rulePriority?: SortOrder
    isActive?: SortOrder
    model?: AutoAnalyticModelOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    assignAnalytic?: AnalyticAccountOrderByWithRelationInput
  }

  export type AutoAnalyticRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoAnalyticRuleWhereInput | AutoAnalyticRuleWhereInput[]
    OR?: AutoAnalyticRuleWhereInput[]
    NOT?: AutoAnalyticRuleWhereInput | AutoAnalyticRuleWhereInput[]
    modelId?: UuidFilter<"AutoAnalyticRule"> | string
    docType?: EnumAutoDocTypeFilter<"AutoAnalyticRule"> | $Enums.AutoDocType
    matchProductId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    matchCategoryId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    matchContactId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    assignAnalyticAccountId?: UuidFilter<"AutoAnalyticRule"> | string
    rulePriority?: IntFilter<"AutoAnalyticRule"> | number
    isActive?: BoolFilter<"AutoAnalyticRule"> | boolean
    model?: XOR<AutoAnalyticModelScalarRelationFilter, AutoAnalyticModelWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    assignAnalytic?: XOR<AnalyticAccountScalarRelationFilter, AnalyticAccountWhereInput>
  }, "id">

  export type AutoAnalyticRuleOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    docType?: SortOrder
    matchProductId?: SortOrderInput | SortOrder
    matchCategoryId?: SortOrderInput | SortOrder
    matchContactId?: SortOrderInput | SortOrder
    assignAnalyticAccountId?: SortOrder
    rulePriority?: SortOrder
    isActive?: SortOrder
    _count?: AutoAnalyticRuleCountOrderByAggregateInput
    _avg?: AutoAnalyticRuleAvgOrderByAggregateInput
    _max?: AutoAnalyticRuleMaxOrderByAggregateInput
    _min?: AutoAnalyticRuleMinOrderByAggregateInput
    _sum?: AutoAnalyticRuleSumOrderByAggregateInput
  }

  export type AutoAnalyticRuleScalarWhereWithAggregatesInput = {
    AND?: AutoAnalyticRuleScalarWhereWithAggregatesInput | AutoAnalyticRuleScalarWhereWithAggregatesInput[]
    OR?: AutoAnalyticRuleScalarWhereWithAggregatesInput[]
    NOT?: AutoAnalyticRuleScalarWhereWithAggregatesInput | AutoAnalyticRuleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AutoAnalyticRule"> | string
    modelId?: UuidWithAggregatesFilter<"AutoAnalyticRule"> | string
    docType?: EnumAutoDocTypeWithAggregatesFilter<"AutoAnalyticRule"> | $Enums.AutoDocType
    matchProductId?: UuidNullableWithAggregatesFilter<"AutoAnalyticRule"> | string | null
    matchCategoryId?: UuidNullableWithAggregatesFilter<"AutoAnalyticRule"> | string | null
    matchContactId?: UuidNullableWithAggregatesFilter<"AutoAnalyticRule"> | string | null
    assignAnalyticAccountId?: UuidWithAggregatesFilter<"AutoAnalyticRule"> | string
    rulePriority?: IntWithAggregatesFilter<"AutoAnalyticRule"> | number
    isActive?: BoolWithAggregatesFilter<"AutoAnalyticRule"> | boolean
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: UuidFilter<"PurchaseOrder"> | string
    companyId?: UuidFilter<"PurchaseOrder"> | string
    poNo?: StringFilter<"PurchaseOrder"> | string
    vendorId?: UuidFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: EnumOrderStatusFilter<"PurchaseOrder"> | $Enums.OrderStatus
    currency?: StringFilter<"PurchaseOrder"> | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vendor?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    lines?: PurchaseOrderLineListRelationFilter
    bills?: VendorBillListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    poNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    vendor?: ContactOrderByWithRelationInput
    lines?: PurchaseOrderLineOrderByRelationAggregateInput
    bills?: VendorBillOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_poNo?: PurchaseOrderCompanyIdPoNoCompoundUniqueInput
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    companyId?: UuidFilter<"PurchaseOrder"> | string
    poNo?: StringFilter<"PurchaseOrder"> | string
    vendorId?: UuidFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: EnumOrderStatusFilter<"PurchaseOrder"> | $Enums.OrderStatus
    currency?: StringFilter<"PurchaseOrder"> | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vendor?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    lines?: PurchaseOrderLineListRelationFilter
    bills?: VendorBillListRelationFilter
  }, "id" | "companyId_poNo">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    poNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PurchaseOrder"> | string
    companyId?: UuidWithAggregatesFilter<"PurchaseOrder"> | string
    poNo?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    vendorId?: UuidWithAggregatesFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    status?: EnumOrderStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.OrderStatus
    currency?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderLineWhereInput = {
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    id?: UuidFilter<"PurchaseOrderLine"> | string
    purchaseOrderId?: UuidFilter<"PurchaseOrderLine"> | string
    productId?: UuidFilter<"PurchaseOrderLine"> | string
    analyticAccountId?: UuidNullableFilter<"PurchaseOrderLine"> | string | null
    description?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
  }

  export type PurchaseOrderLineOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    analytic?: AnalyticAccountOrderByWithRelationInput
  }

  export type PurchaseOrderLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    purchaseOrderId?: UuidFilter<"PurchaseOrderLine"> | string
    productId?: UuidFilter<"PurchaseOrderLine"> | string
    analyticAccountId?: UuidNullableFilter<"PurchaseOrderLine"> | string | null
    description?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
  }, "id">

  export type PurchaseOrderLineOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    _count?: PurchaseOrderLineCountOrderByAggregateInput
    _avg?: PurchaseOrderLineAvgOrderByAggregateInput
    _max?: PurchaseOrderLineMaxOrderByAggregateInput
    _min?: PurchaseOrderLineMinOrderByAggregateInput
    _sum?: PurchaseOrderLineSumOrderByAggregateInput
  }

  export type PurchaseOrderLineScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderLineScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PurchaseOrderLine"> | string
    purchaseOrderId?: UuidWithAggregatesFilter<"PurchaseOrderLine"> | string
    productId?: UuidWithAggregatesFilter<"PurchaseOrderLine"> | string
    analyticAccountId?: UuidNullableWithAggregatesFilter<"PurchaseOrderLine"> | string | null
    description?: StringNullableWithAggregatesFilter<"PurchaseOrderLine"> | string | null
    qty?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderWhereInput = {
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    id?: UuidFilter<"SalesOrder"> | string
    companyId?: UuidFilter<"SalesOrder"> | string
    soNo?: StringFilter<"SalesOrder"> | string
    customerId?: UuidFilter<"SalesOrder"> | string
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    status?: EnumOrderStatusFilter<"SalesOrder"> | $Enums.OrderStatus
    currency?: StringFilter<"SalesOrder"> | string
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    lines?: SalesOrderLineListRelationFilter
    invoices?: CustomerInvoiceListRelationFilter
  }

  export type SalesOrderOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    soNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    customer?: ContactOrderByWithRelationInput
    lines?: SalesOrderLineOrderByRelationAggregateInput
    invoices?: CustomerInvoiceOrderByRelationAggregateInput
  }

  export type SalesOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_soNo?: SalesOrderCompanyIdSoNoCompoundUniqueInput
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    companyId?: UuidFilter<"SalesOrder"> | string
    soNo?: StringFilter<"SalesOrder"> | string
    customerId?: UuidFilter<"SalesOrder"> | string
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    status?: EnumOrderStatusFilter<"SalesOrder"> | $Enums.OrderStatus
    currency?: StringFilter<"SalesOrder"> | string
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    lines?: SalesOrderLineListRelationFilter
    invoices?: CustomerInvoiceListRelationFilter
  }, "id" | "companyId_soNo">

  export type SalesOrderOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    soNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SalesOrderCountOrderByAggregateInput
    _max?: SalesOrderMaxOrderByAggregateInput
    _min?: SalesOrderMinOrderByAggregateInput
  }

  export type SalesOrderScalarWhereWithAggregatesInput = {
    AND?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    OR?: SalesOrderScalarWhereWithAggregatesInput[]
    NOT?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SalesOrder"> | string
    companyId?: UuidWithAggregatesFilter<"SalesOrder"> | string
    soNo?: StringWithAggregatesFilter<"SalesOrder"> | string
    customerId?: UuidWithAggregatesFilter<"SalesOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
    status?: EnumOrderStatusWithAggregatesFilter<"SalesOrder"> | $Enums.OrderStatus
    currency?: StringWithAggregatesFilter<"SalesOrder"> | string
    notes?: StringNullableWithAggregatesFilter<"SalesOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
  }

  export type SalesOrderLineWhereInput = {
    AND?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    OR?: SalesOrderLineWhereInput[]
    NOT?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    id?: UuidFilter<"SalesOrderLine"> | string
    salesOrderId?: UuidFilter<"SalesOrderLine"> | string
    productId?: UuidFilter<"SalesOrderLine"> | string
    analyticAccountId?: UuidNullableFilter<"SalesOrderLine"> | string | null
    description?: StringNullableFilter<"SalesOrderLine"> | string | null
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    salesOrder?: XOR<SalesOrderScalarRelationFilter, SalesOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
  }

  export type SalesOrderLineOrderByWithRelationInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    salesOrder?: SalesOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    analytic?: AnalyticAccountOrderByWithRelationInput
  }

  export type SalesOrderLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    OR?: SalesOrderLineWhereInput[]
    NOT?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    salesOrderId?: UuidFilter<"SalesOrderLine"> | string
    productId?: UuidFilter<"SalesOrderLine"> | string
    analyticAccountId?: UuidNullableFilter<"SalesOrderLine"> | string | null
    description?: StringNullableFilter<"SalesOrderLine"> | string | null
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    salesOrder?: XOR<SalesOrderScalarRelationFilter, SalesOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
  }, "id">

  export type SalesOrderLineOrderByWithAggregationInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    _count?: SalesOrderLineCountOrderByAggregateInput
    _avg?: SalesOrderLineAvgOrderByAggregateInput
    _max?: SalesOrderLineMaxOrderByAggregateInput
    _min?: SalesOrderLineMinOrderByAggregateInput
    _sum?: SalesOrderLineSumOrderByAggregateInput
  }

  export type SalesOrderLineScalarWhereWithAggregatesInput = {
    AND?: SalesOrderLineScalarWhereWithAggregatesInput | SalesOrderLineScalarWhereWithAggregatesInput[]
    OR?: SalesOrderLineScalarWhereWithAggregatesInput[]
    NOT?: SalesOrderLineScalarWhereWithAggregatesInput | SalesOrderLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SalesOrderLine"> | string
    salesOrderId?: UuidWithAggregatesFilter<"SalesOrderLine"> | string
    productId?: UuidWithAggregatesFilter<"SalesOrderLine"> | string
    analyticAccountId?: UuidNullableWithAggregatesFilter<"SalesOrderLine"> | string | null
    description?: StringNullableWithAggregatesFilter<"SalesOrderLine"> | string | null
    qty?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillWhereInput = {
    AND?: VendorBillWhereInput | VendorBillWhereInput[]
    OR?: VendorBillWhereInput[]
    NOT?: VendorBillWhereInput | VendorBillWhereInput[]
    id?: UuidFilter<"VendorBill"> | string
    companyId?: UuidFilter<"VendorBill"> | string
    billNo?: StringFilter<"VendorBill"> | string
    vendorId?: UuidFilter<"VendorBill"> | string
    billDate?: DateTimeFilter<"VendorBill"> | Date | string
    dueDate?: DateTimeNullableFilter<"VendorBill"> | Date | string | null
    status?: EnumDocStatusFilter<"VendorBill"> | $Enums.DocStatus
    currency?: StringFilter<"VendorBill"> | string
    poId?: UuidNullableFilter<"VendorBill"> | string | null
    totalAmount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringFilter<"VendorBill"> | string
    createdAt?: DateTimeFilter<"VendorBill"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vendor?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    po?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    lines?: VendorBillLineListRelationFilter
  }

  export type VendorBillOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    billNo?: SortOrder
    vendorId?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    poId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    vendor?: ContactOrderByWithRelationInput
    po?: PurchaseOrderOrderByWithRelationInput
    lines?: VendorBillLineOrderByRelationAggregateInput
  }

  export type VendorBillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_billNo?: VendorBillCompanyIdBillNoCompoundUniqueInput
    AND?: VendorBillWhereInput | VendorBillWhereInput[]
    OR?: VendorBillWhereInput[]
    NOT?: VendorBillWhereInput | VendorBillWhereInput[]
    companyId?: UuidFilter<"VendorBill"> | string
    billNo?: StringFilter<"VendorBill"> | string
    vendorId?: UuidFilter<"VendorBill"> | string
    billDate?: DateTimeFilter<"VendorBill"> | Date | string
    dueDate?: DateTimeNullableFilter<"VendorBill"> | Date | string | null
    status?: EnumDocStatusFilter<"VendorBill"> | $Enums.DocStatus
    currency?: StringFilter<"VendorBill"> | string
    poId?: UuidNullableFilter<"VendorBill"> | string | null
    totalAmount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringFilter<"VendorBill"> | string
    createdAt?: DateTimeFilter<"VendorBill"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vendor?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    po?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    lines?: VendorBillLineListRelationFilter
  }, "id" | "companyId_billNo">

  export type VendorBillOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    billNo?: SortOrder
    vendorId?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    poId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    createdAt?: SortOrder
    _count?: VendorBillCountOrderByAggregateInput
    _avg?: VendorBillAvgOrderByAggregateInput
    _max?: VendorBillMaxOrderByAggregateInput
    _min?: VendorBillMinOrderByAggregateInput
    _sum?: VendorBillSumOrderByAggregateInput
  }

  export type VendorBillScalarWhereWithAggregatesInput = {
    AND?: VendorBillScalarWhereWithAggregatesInput | VendorBillScalarWhereWithAggregatesInput[]
    OR?: VendorBillScalarWhereWithAggregatesInput[]
    NOT?: VendorBillScalarWhereWithAggregatesInput | VendorBillScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VendorBill"> | string
    companyId?: UuidWithAggregatesFilter<"VendorBill"> | string
    billNo?: StringWithAggregatesFilter<"VendorBill"> | string
    vendorId?: UuidWithAggregatesFilter<"VendorBill"> | string
    billDate?: DateTimeWithAggregatesFilter<"VendorBill"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"VendorBill"> | Date | string | null
    status?: EnumDocStatusWithAggregatesFilter<"VendorBill"> | $Enums.DocStatus
    currency?: StringWithAggregatesFilter<"VendorBill"> | string
    poId?: UuidNullableWithAggregatesFilter<"VendorBill"> | string | null
    totalAmount?: DecimalWithAggregatesFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringWithAggregatesFilter<"VendorBill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorBill"> | Date | string
  }

  export type VendorBillLineWhereInput = {
    AND?: VendorBillLineWhereInput | VendorBillLineWhereInput[]
    OR?: VendorBillLineWhereInput[]
    NOT?: VendorBillLineWhereInput | VendorBillLineWhereInput[]
    id?: UuidFilter<"VendorBillLine"> | string
    vendorBillId?: UuidFilter<"VendorBillLine"> | string
    productId?: UuidNullableFilter<"VendorBillLine"> | string | null
    analyticAccountId?: UuidNullableFilter<"VendorBillLine"> | string | null
    glAccountId?: UuidNullableFilter<"VendorBillLine"> | string | null
    description?: StringNullableFilter<"VendorBillLine"> | string | null
    qty?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    bill?: XOR<VendorBillScalarRelationFilter, VendorBillWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    gl?: XOR<GLAccountNullableScalarRelationFilter, GLAccountWhereInput> | null
  }

  export type VendorBillLineOrderByWithRelationInput = {
    id?: SortOrder
    vendorBillId?: SortOrder
    productId?: SortOrderInput | SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    glAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    bill?: VendorBillOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    analytic?: AnalyticAccountOrderByWithRelationInput
    gl?: GLAccountOrderByWithRelationInput
  }

  export type VendorBillLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorBillLineWhereInput | VendorBillLineWhereInput[]
    OR?: VendorBillLineWhereInput[]
    NOT?: VendorBillLineWhereInput | VendorBillLineWhereInput[]
    vendorBillId?: UuidFilter<"VendorBillLine"> | string
    productId?: UuidNullableFilter<"VendorBillLine"> | string | null
    analyticAccountId?: UuidNullableFilter<"VendorBillLine"> | string | null
    glAccountId?: UuidNullableFilter<"VendorBillLine"> | string | null
    description?: StringNullableFilter<"VendorBillLine"> | string | null
    qty?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    bill?: XOR<VendorBillScalarRelationFilter, VendorBillWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    gl?: XOR<GLAccountNullableScalarRelationFilter, GLAccountWhereInput> | null
  }, "id">

  export type VendorBillLineOrderByWithAggregationInput = {
    id?: SortOrder
    vendorBillId?: SortOrder
    productId?: SortOrderInput | SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    glAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    _count?: VendorBillLineCountOrderByAggregateInput
    _avg?: VendorBillLineAvgOrderByAggregateInput
    _max?: VendorBillLineMaxOrderByAggregateInput
    _min?: VendorBillLineMinOrderByAggregateInput
    _sum?: VendorBillLineSumOrderByAggregateInput
  }

  export type VendorBillLineScalarWhereWithAggregatesInput = {
    AND?: VendorBillLineScalarWhereWithAggregatesInput | VendorBillLineScalarWhereWithAggregatesInput[]
    OR?: VendorBillLineScalarWhereWithAggregatesInput[]
    NOT?: VendorBillLineScalarWhereWithAggregatesInput | VendorBillLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VendorBillLine"> | string
    vendorBillId?: UuidWithAggregatesFilter<"VendorBillLine"> | string
    productId?: UuidNullableWithAggregatesFilter<"VendorBillLine"> | string | null
    analyticAccountId?: UuidNullableWithAggregatesFilter<"VendorBillLine"> | string | null
    glAccountId?: UuidNullableWithAggregatesFilter<"VendorBillLine"> | string | null
    description?: StringNullableWithAggregatesFilter<"VendorBillLine"> | string | null
    qty?: DecimalWithAggregatesFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceWhereInput = {
    AND?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    OR?: CustomerInvoiceWhereInput[]
    NOT?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    id?: UuidFilter<"CustomerInvoice"> | string
    companyId?: UuidFilter<"CustomerInvoice"> | string
    invoiceNo?: StringFilter<"CustomerInvoice"> | string
    customerId?: UuidFilter<"CustomerInvoice"> | string
    invoiceDate?: DateTimeFilter<"CustomerInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"CustomerInvoice"> | Date | string | null
    status?: EnumDocStatusFilter<"CustomerInvoice"> | $Enums.DocStatus
    currency?: StringFilter<"CustomerInvoice"> | string
    soId?: UuidNullableFilter<"CustomerInvoice"> | string | null
    totalAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringFilter<"CustomerInvoice"> | string
    portalVisible?: BoolFilter<"CustomerInvoice"> | boolean
    createdAt?: DateTimeFilter<"CustomerInvoice"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    so?: XOR<SalesOrderNullableScalarRelationFilter, SalesOrderWhereInput> | null
    lines?: CustomerInvoiceLineListRelationFilter
  }

  export type CustomerInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    invoiceNo?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    soId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    portalVisible?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    customer?: ContactOrderByWithRelationInput
    so?: SalesOrderOrderByWithRelationInput
    lines?: CustomerInvoiceLineOrderByRelationAggregateInput
  }

  export type CustomerInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_invoiceNo?: CustomerInvoiceCompanyIdInvoiceNoCompoundUniqueInput
    AND?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    OR?: CustomerInvoiceWhereInput[]
    NOT?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    companyId?: UuidFilter<"CustomerInvoice"> | string
    invoiceNo?: StringFilter<"CustomerInvoice"> | string
    customerId?: UuidFilter<"CustomerInvoice"> | string
    invoiceDate?: DateTimeFilter<"CustomerInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"CustomerInvoice"> | Date | string | null
    status?: EnumDocStatusFilter<"CustomerInvoice"> | $Enums.DocStatus
    currency?: StringFilter<"CustomerInvoice"> | string
    soId?: UuidNullableFilter<"CustomerInvoice"> | string | null
    totalAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringFilter<"CustomerInvoice"> | string
    portalVisible?: BoolFilter<"CustomerInvoice"> | boolean
    createdAt?: DateTimeFilter<"CustomerInvoice"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    customer?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    so?: XOR<SalesOrderNullableScalarRelationFilter, SalesOrderWhereInput> | null
    lines?: CustomerInvoiceLineListRelationFilter
  }, "id" | "companyId_invoiceNo">

  export type CustomerInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    invoiceNo?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    soId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    portalVisible?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerInvoiceCountOrderByAggregateInput
    _avg?: CustomerInvoiceAvgOrderByAggregateInput
    _max?: CustomerInvoiceMaxOrderByAggregateInput
    _min?: CustomerInvoiceMinOrderByAggregateInput
    _sum?: CustomerInvoiceSumOrderByAggregateInput
  }

  export type CustomerInvoiceScalarWhereWithAggregatesInput = {
    AND?: CustomerInvoiceScalarWhereWithAggregatesInput | CustomerInvoiceScalarWhereWithAggregatesInput[]
    OR?: CustomerInvoiceScalarWhereWithAggregatesInput[]
    NOT?: CustomerInvoiceScalarWhereWithAggregatesInput | CustomerInvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CustomerInvoice"> | string
    companyId?: UuidWithAggregatesFilter<"CustomerInvoice"> | string
    invoiceNo?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    customerId?: UuidWithAggregatesFilter<"CustomerInvoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"CustomerInvoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"CustomerInvoice"> | Date | string | null
    status?: EnumDocStatusWithAggregatesFilter<"CustomerInvoice"> | $Enums.DocStatus
    currency?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    soId?: UuidNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    totalAmount?: DecimalWithAggregatesFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    portalVisible?: BoolWithAggregatesFilter<"CustomerInvoice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerInvoice"> | Date | string
  }

  export type CustomerInvoiceLineWhereInput = {
    AND?: CustomerInvoiceLineWhereInput | CustomerInvoiceLineWhereInput[]
    OR?: CustomerInvoiceLineWhereInput[]
    NOT?: CustomerInvoiceLineWhereInput | CustomerInvoiceLineWhereInput[]
    id?: UuidFilter<"CustomerInvoiceLine"> | string
    customerInvoiceId?: UuidFilter<"CustomerInvoiceLine"> | string
    productId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    analyticAccountId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    glAccountId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    description?: StringNullableFilter<"CustomerInvoiceLine"> | string | null
    qty?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<CustomerInvoiceScalarRelationFilter, CustomerInvoiceWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    gl?: XOR<GLAccountNullableScalarRelationFilter, GLAccountWhereInput> | null
  }

  export type CustomerInvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    customerInvoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    glAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    invoice?: CustomerInvoiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    analytic?: AnalyticAccountOrderByWithRelationInput
    gl?: GLAccountOrderByWithRelationInput
  }

  export type CustomerInvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerInvoiceLineWhereInput | CustomerInvoiceLineWhereInput[]
    OR?: CustomerInvoiceLineWhereInput[]
    NOT?: CustomerInvoiceLineWhereInput | CustomerInvoiceLineWhereInput[]
    customerInvoiceId?: UuidFilter<"CustomerInvoiceLine"> | string
    productId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    analyticAccountId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    glAccountId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    description?: StringNullableFilter<"CustomerInvoiceLine"> | string | null
    qty?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<CustomerInvoiceScalarRelationFilter, CustomerInvoiceWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    analytic?: XOR<AnalyticAccountNullableScalarRelationFilter, AnalyticAccountWhereInput> | null
    gl?: XOR<GLAccountNullableScalarRelationFilter, GLAccountWhereInput> | null
  }, "id">

  export type CustomerInvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    customerInvoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    analyticAccountId?: SortOrderInput | SortOrder
    glAccountId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
    _count?: CustomerInvoiceLineCountOrderByAggregateInput
    _avg?: CustomerInvoiceLineAvgOrderByAggregateInput
    _max?: CustomerInvoiceLineMaxOrderByAggregateInput
    _min?: CustomerInvoiceLineMinOrderByAggregateInput
    _sum?: CustomerInvoiceLineSumOrderByAggregateInput
  }

  export type CustomerInvoiceLineScalarWhereWithAggregatesInput = {
    AND?: CustomerInvoiceLineScalarWhereWithAggregatesInput | CustomerInvoiceLineScalarWhereWithAggregatesInput[]
    OR?: CustomerInvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: CustomerInvoiceLineScalarWhereWithAggregatesInput | CustomerInvoiceLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CustomerInvoiceLine"> | string
    customerInvoiceId?: UuidWithAggregatesFilter<"CustomerInvoiceLine"> | string
    productId?: UuidNullableWithAggregatesFilter<"CustomerInvoiceLine"> | string | null
    analyticAccountId?: UuidNullableWithAggregatesFilter<"CustomerInvoiceLine"> | string | null
    glAccountId?: UuidNullableWithAggregatesFilter<"CustomerInvoiceLine"> | string | null
    description?: StringNullableWithAggregatesFilter<"CustomerInvoiceLine"> | string | null
    qty?: DecimalWithAggregatesFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    companyId?: UuidFilter<"Payment"> | string
    direction?: EnumPaymentDirectionFilter<"Payment"> | $Enums.PaymentDirection
    contactId?: UuidFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    allocations?: PaymentAllocationListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    direction?: SortOrder
    contactId?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    allocations?: PaymentAllocationOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    companyId?: UuidFilter<"Payment"> | string
    direction?: EnumPaymentDirectionFilter<"Payment"> | $Enums.PaymentDirection
    contactId?: UuidFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    allocations?: PaymentAllocationListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    direction?: SortOrder
    contactId?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    companyId?: UuidWithAggregatesFilter<"Payment"> | string
    direction?: EnumPaymentDirectionWithAggregatesFilter<"Payment"> | $Enums.PaymentDirection
    contactId?: UuidWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentAllocationWhereInput = {
    AND?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    OR?: PaymentAllocationWhereInput[]
    NOT?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    id?: UuidFilter<"PaymentAllocation"> | string
    paymentId?: UuidFilter<"PaymentAllocation"> | string
    targetType?: EnumAllocationTargetTypeFilter<"PaymentAllocation"> | $Enums.AllocationTargetType
    targetId?: UuidFilter<"PaymentAllocation"> | string
    amount?: DecimalFilter<"PaymentAllocation"> | Decimal | DecimalJsLike | number | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type PaymentAllocationOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type PaymentAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentId_targetType_targetId?: PaymentAllocationPaymentIdTargetTypeTargetIdCompoundUniqueInput
    AND?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    OR?: PaymentAllocationWhereInput[]
    NOT?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    paymentId?: UuidFilter<"PaymentAllocation"> | string
    targetType?: EnumAllocationTargetTypeFilter<"PaymentAllocation"> | $Enums.AllocationTargetType
    targetId?: UuidFilter<"PaymentAllocation"> | string
    amount?: DecimalFilter<"PaymentAllocation"> | Decimal | DecimalJsLike | number | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id" | "paymentId_targetType_targetId">

  export type PaymentAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
    _count?: PaymentAllocationCountOrderByAggregateInput
    _avg?: PaymentAllocationAvgOrderByAggregateInput
    _max?: PaymentAllocationMaxOrderByAggregateInput
    _min?: PaymentAllocationMinOrderByAggregateInput
    _sum?: PaymentAllocationSumOrderByAggregateInput
  }

  export type PaymentAllocationScalarWhereWithAggregatesInput = {
    AND?: PaymentAllocationScalarWhereWithAggregatesInput | PaymentAllocationScalarWhereWithAggregatesInput[]
    OR?: PaymentAllocationScalarWhereWithAggregatesInput[]
    NOT?: PaymentAllocationScalarWhereWithAggregatesInput | PaymentAllocationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PaymentAllocation"> | string
    paymentId?: UuidWithAggregatesFilter<"PaymentAllocation"> | string
    targetType?: EnumAllocationTargetTypeWithAggregatesFilter<"PaymentAllocation"> | $Enums.AllocationTargetType
    targetId?: UuidWithAggregatesFilter<"PaymentAllocation"> | string
    amount?: DecimalWithAggregatesFilter<"PaymentAllocation"> | Decimal | DecimalJsLike | number | string
  }

  export type DocumentFileWhereInput = {
    AND?: DocumentFileWhereInput | DocumentFileWhereInput[]
    OR?: DocumentFileWhereInput[]
    NOT?: DocumentFileWhereInput | DocumentFileWhereInput[]
    id?: UuidFilter<"DocumentFile"> | string
    companyId?: UuidFilter<"DocumentFile"> | string
    ownerType?: EnumDocOwnerTypeFilter<"DocumentFile"> | $Enums.DocOwnerType
    ownerId?: UuidFilter<"DocumentFile"> | string
    fileName?: StringFilter<"DocumentFile"> | string
    mimeType?: StringFilter<"DocumentFile"> | string
    storageUrl?: StringFilter<"DocumentFile"> | string
    createdAt?: DateTimeFilter<"DocumentFile"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DocumentFileOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    storageUrl?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DocumentFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentFileWhereInput | DocumentFileWhereInput[]
    OR?: DocumentFileWhereInput[]
    NOT?: DocumentFileWhereInput | DocumentFileWhereInput[]
    companyId?: UuidFilter<"DocumentFile"> | string
    ownerType?: EnumDocOwnerTypeFilter<"DocumentFile"> | $Enums.DocOwnerType
    ownerId?: UuidFilter<"DocumentFile"> | string
    fileName?: StringFilter<"DocumentFile"> | string
    mimeType?: StringFilter<"DocumentFile"> | string
    storageUrl?: StringFilter<"DocumentFile"> | string
    createdAt?: DateTimeFilter<"DocumentFile"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DocumentFileOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    storageUrl?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentFileCountOrderByAggregateInput
    _max?: DocumentFileMaxOrderByAggregateInput
    _min?: DocumentFileMinOrderByAggregateInput
  }

  export type DocumentFileScalarWhereWithAggregatesInput = {
    AND?: DocumentFileScalarWhereWithAggregatesInput | DocumentFileScalarWhereWithAggregatesInput[]
    OR?: DocumentFileScalarWhereWithAggregatesInput[]
    NOT?: DocumentFileScalarWhereWithAggregatesInput | DocumentFileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DocumentFile"> | string
    companyId?: UuidWithAggregatesFilter<"DocumentFile"> | string
    ownerType?: EnumDocOwnerTypeWithAggregatesFilter<"DocumentFile"> | $Enums.DocOwnerType
    ownerId?: UuidWithAggregatesFilter<"DocumentFile"> | string
    fileName?: StringWithAggregatesFilter<"DocumentFile"> | string
    mimeType?: StringWithAggregatesFilter<"DocumentFile"> | string
    storageUrl?: StringWithAggregatesFilter<"DocumentFile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentFile"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    id?: string
    name: string
    company: CompanyCreateNestedOneWithoutProductCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    parentId?: string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    companyId: string
    name: string
    parentId?: string | null
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticAccountCreateInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountCreateManyInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AnalyticAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GLAccountCreateInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    company: CompanyCreateNestedOneWithoutGlAccountsInput
    journalLines?: JournalLineCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutGlInput
  }

  export type GLAccountUncheckedCreateInput = {
    id?: string
    companyId: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutGlInput
  }

  export type GLAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneRequiredWithoutGlAccountsNestedInput
    journalLines?: JournalLineUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutGlNestedInput
  }

  export type GLAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUncheckedUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutGlNestedInput
  }

  export type GLAccountCreateManyInput = {
    id?: string
    companyId: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
  }

  export type GLAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GLAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JournalEntryCreateInput = {
    id?: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
    lines?: JournalLineCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    companyId: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
    lines?: JournalLineUncheckedCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
    lines?: JournalLineUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: JournalLineUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    companyId: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalLineCreateInput = {
    id?: string
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    entry: JournalEntryCreateNestedOneWithoutLinesInput
    gl: GLAccountCreateNestedOneWithoutJournalLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutJournalLinesInput
    contact?: ContactCreateNestedOneWithoutJournalLinesInput
    product?: ProductCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    analyticAccountId?: string | null
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
    gl?: GLAccountUpdateOneRequiredWithoutJournalLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutJournalLinesNestedInput
    contact?: ContactUpdateOneWithoutJournalLinesNestedInput
    product?: ProductUpdateOneWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateManyInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    analyticAccountId?: string | null
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetCreateInput = {
    id?: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutBudgetsInput
    revisions?: BudgetRevisionCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    revisions?: BudgetRevisionUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutBudgetsNestedInput
    revisions?: BudgetRevisionUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: BudgetRevisionUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    companyId: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BudgetRevisionCreateInput = {
    id?: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    budget: BudgetCreateNestedOneWithoutRevisionsInput
    lines?: BudgetLineCreateNestedManyWithoutRevisionInput
  }

  export type BudgetRevisionUncheckedCreateInput = {
    id?: string
    budgetId: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    lines?: BudgetLineUncheckedCreateNestedManyWithoutRevisionInput
  }

  export type BudgetRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: BudgetUpdateOneRequiredWithoutRevisionsNestedInput
    lines?: BudgetLineUpdateManyWithoutRevisionNestedInput
  }

  export type BudgetRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: BudgetLineUncheckedUpdateManyWithoutRevisionNestedInput
  }

  export type BudgetRevisionCreateManyInput = {
    id?: string
    budgetId: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type BudgetRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BudgetRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BudgetLineCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    revision: BudgetRevisionCreateNestedOneWithoutLinesInput
    analytic: AnalyticAccountCreateNestedOneWithoutBudgetLinesInput
    gl?: GLAccountCreateNestedOneWithoutBudgetLinesInput
  }

  export type BudgetLineUncheckedCreateInput = {
    id?: string
    budgetRevisionId: string
    analyticAccountId: string
    glAccountId?: string | null
    amount: Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revision?: BudgetRevisionUpdateOneRequiredWithoutLinesNestedInput
    analytic?: AnalyticAccountUpdateOneRequiredWithoutBudgetLinesNestedInput
    gl?: GLAccountUpdateOneWithoutBudgetLinesNestedInput
  }

  export type BudgetLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetRevisionId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineCreateManyInput = {
    id?: string
    budgetRevisionId: string
    analyticAccountId: string
    glAccountId?: string | null
    amount: Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetRevisionId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticModelCreateInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAutoAnalyticModelsInput
    rules?: AutoAnalyticRuleCreateNestedManyWithoutModelInput
  }

  export type AutoAnalyticModelUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    rules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutModelInput
  }

  export type AutoAnalyticModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAutoAnalyticModelsNestedInput
    rules?: AutoAnalyticRuleUpdateManyWithoutModelNestedInput
  }

  export type AutoAnalyticModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutoAnalyticRuleUncheckedUpdateManyWithoutModelNestedInput
  }

  export type AutoAnalyticModelCreateManyInput = {
    id?: string
    companyId: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AutoAnalyticModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoAnalyticModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoAnalyticRuleCreateInput = {
    id?: string
    docType: $Enums.AutoDocType
    rulePriority?: number
    isActive?: boolean
    model: AutoAnalyticModelCreateNestedOneWithoutRulesInput
    product?: ProductCreateNestedOneWithoutAutoAnalyticRulesInput
    category?: ProductCategoryCreateNestedOneWithoutAutoAnalyticRulesInput
    contact?: ContactCreateNestedOneWithoutAutoAnalyticRulesInput
    assignAnalytic: AnalyticAccountCreateNestedOneWithoutAutoAnalyticRulesInput
  }

  export type AutoAnalyticRuleUncheckedCreateInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    model?: AutoAnalyticModelUpdateOneRequiredWithoutRulesNestedInput
    product?: ProductUpdateOneWithoutAutoAnalyticRulesNestedInput
    category?: ProductCategoryUpdateOneWithoutAutoAnalyticRulesNestedInput
    contact?: ContactUpdateOneWithoutAutoAnalyticRulesNestedInput
    assignAnalytic?: AnalyticAccountUpdateOneRequiredWithoutAutoAnalyticRulesNestedInput
  }

  export type AutoAnalyticRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoAnalyticRuleCreateManyInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoAnalyticRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    poNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    vendor: ContactCreateNestedOneWithoutVendorPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    bills?: VendorBillCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    companyId: string
    poNo: string
    vendorId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
    bills?: VendorBillUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    vendor?: ContactUpdateOneRequiredWithoutVendorPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    bills?: VendorBillUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    bills?: VendorBillUncheckedUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    companyId: string
    poNo: string
    vendorId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineCreateInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutPoLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutPoLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutPoLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutPoLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineCreateManyInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderCreateInput = {
    id?: string
    soNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutSalesOrdersInput
    customer: ContactCreateNestedOneWithoutCustomerSalesOrdersInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    invoices?: CustomerInvoiceCreateNestedManyWithoutSoInput
  }

  export type SalesOrderUncheckedCreateInput = {
    id?: string
    companyId: string
    soNo: string
    customerId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
    invoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutSoInput
  }

  export type SalesOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSalesOrdersNestedInput
    customer?: ContactUpdateOneRequiredWithoutCustomerSalesOrdersNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    invoices?: CustomerInvoiceUpdateManyWithoutSoNestedInput
  }

  export type SalesOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
    invoices?: CustomerInvoiceUncheckedUpdateManyWithoutSoNestedInput
  }

  export type SalesOrderCreateManyInput = {
    id?: string
    companyId: string
    soNo: string
    customerId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type SalesOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderLineCreateInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    salesOrder: SalesOrderCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutSoLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutSoLinesInput
  }

  export type SalesOrderLineUncheckedCreateInput = {
    id?: string
    salesOrderId: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesOrder?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutSoLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutSoLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateManyInput = {
    id?: string
    salesOrderId: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillCreateInput = {
    id?: string
    billNo: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutVendorBillsInput
    vendor: ContactCreateNestedOneWithoutVendorBillsInput
    po?: PurchaseOrderCreateNestedOneWithoutBillsInput
    lines?: VendorBillLineCreateNestedManyWithoutBillInput
  }

  export type VendorBillUncheckedCreateInput = {
    id?: string
    companyId: string
    billNo: string
    vendorId: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    poId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    lines?: VendorBillLineUncheckedCreateNestedManyWithoutBillInput
  }

  export type VendorBillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVendorBillsNestedInput
    vendor?: ContactUpdateOneRequiredWithoutVendorBillsNestedInput
    po?: PurchaseOrderUpdateOneWithoutBillsNestedInput
    lines?: VendorBillLineUpdateManyWithoutBillNestedInput
  }

  export type VendorBillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: VendorBillLineUncheckedUpdateManyWithoutBillNestedInput
  }

  export type VendorBillCreateManyInput = {
    id?: string
    companyId: string
    billNo: string
    vendorId: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    poId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
  }

  export type VendorBillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillLineCreateInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    bill: VendorBillCreateNestedOneWithoutLinesInput
    product?: ProductCreateNestedOneWithoutBillLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutBillLinesInput
    gl?: GLAccountCreateNestedOneWithoutBillLinesInput
  }

  export type VendorBillLineUncheckedCreateInput = {
    id?: string
    vendorBillId: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bill?: VendorBillUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneWithoutBillLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutBillLinesNestedInput
    gl?: GLAccountUpdateOneWithoutBillLinesNestedInput
  }

  export type VendorBillLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateManyInput = {
    id?: string
    vendorBillId: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceCreateInput = {
    id?: string
    invoiceNo: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCustomerInvoicesInput
    customer: ContactCreateNestedOneWithoutCustomerInvoicesInput
    so?: SalesOrderCreateNestedOneWithoutInvoicesInput
    lines?: CustomerInvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceUncheckedCreateInput = {
    id?: string
    companyId: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    soId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    lines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    customer?: ContactUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    so?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    lines?: CustomerInvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    soId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: CustomerInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceCreateManyInput = {
    id?: string
    companyId: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    soId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
  }

  export type CustomerInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    soId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceLineCreateInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: CustomerInvoiceCreateNestedOneWithoutLinesInput
    product?: ProductCreateNestedOneWithoutInvLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutInvLinesInput
    gl?: GLAccountCreateNestedOneWithoutInvLinesInput
  }

  export type CustomerInvoiceLineUncheckedCreateInput = {
    id?: string
    customerInvoiceId: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: CustomerInvoiceUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneWithoutInvLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutInvLinesNestedInput
    gl?: GLAccountUpdateOneWithoutInvLinesNestedInput
  }

  export type CustomerInvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateManyInput = {
    id?: string
    customerInvoiceId: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateInput = {
    id?: string
    direction: $Enums.PaymentDirection
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPaymentsInput
    contact: ContactCreateNestedOneWithoutPaymentsInput
    allocations?: PaymentAllocationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    companyId: string
    direction: $Enums.PaymentDirection
    contactId: string
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    allocations?: PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPaymentsNestedInput
    contact?: ContactUpdateOneRequiredWithoutPaymentsNestedInput
    allocations?: PaymentAllocationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    contactId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    companyId: string
    direction: $Enums.PaymentDirection
    contactId: string
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    contactId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAllocationCreateInput = {
    id?: string
    targetType: $Enums.AllocationTargetType
    targetId: string
    amount: Decimal | DecimalJsLike | number | string
    payment: PaymentCreateNestedOneWithoutAllocationsInput
  }

  export type PaymentAllocationUncheckedCreateInput = {
    id?: string
    paymentId: string
    targetType: $Enums.AllocationTargetType
    targetId: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumAllocationTargetTypeFieldUpdateOperationsInput | $Enums.AllocationTargetType
    targetId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment?: PaymentUpdateOneRequiredWithoutAllocationsNestedInput
  }

  export type PaymentAllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumAllocationTargetTypeFieldUpdateOperationsInput | $Enums.AllocationTargetType
    targetId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationCreateManyInput = {
    id?: string
    paymentId: string
    targetType: $Enums.AllocationTargetType
    targetId: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumAllocationTargetTypeFieldUpdateOperationsInput | $Enums.AllocationTargetType
    targetId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumAllocationTargetTypeFieldUpdateOperationsInput | $Enums.AllocationTargetType
    targetId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DocumentFileCreateInput = {
    id?: string
    ownerType: $Enums.DocOwnerType
    ownerId: string
    fileName: string
    mimeType: string
    storageUrl: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentFilesInput
  }

  export type DocumentFileUncheckedCreateInput = {
    id?: string
    companyId: string
    ownerType: $Enums.DocOwnerType
    ownerId: string
    fileName: string
    mimeType: string
    storageUrl: string
    createdAt?: Date | string
  }

  export type DocumentFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumDocOwnerTypeFieldUpdateOperationsInput | $Enums.DocOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    storageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentFilesNestedInput
  }

  export type DocumentFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumDocOwnerTypeFieldUpdateOperationsInput | $Enums.DocOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    storageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentFileCreateManyInput = {
    id?: string
    companyId: string
    ownerType: $Enums.DocOwnerType
    ownerId: string
    fileName: string
    mimeType: string
    storageUrl: string
    createdAt?: Date | string
  }

  export type DocumentFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumDocOwnerTypeFieldUpdateOperationsInput | $Enums.DocOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    storageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumDocOwnerTypeFieldUpdateOperationsInput | $Enums.DocOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    storageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type AnalyticAccountListRelationFilter = {
    every?: AnalyticAccountWhereInput
    some?: AnalyticAccountWhereInput
    none?: AnalyticAccountWhereInput
  }

  export type GLAccountListRelationFilter = {
    every?: GLAccountWhereInput
    some?: GLAccountWhereInput
    none?: GLAccountWhereInput
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type AutoAnalyticModelListRelationFilter = {
    every?: AutoAnalyticModelWhereInput
    some?: AutoAnalyticModelWhereInput
    none?: AutoAnalyticModelWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type SalesOrderListRelationFilter = {
    every?: SalesOrderWhereInput
    some?: SalesOrderWhereInput
    none?: SalesOrderWhereInput
  }

  export type VendorBillListRelationFilter = {
    every?: VendorBillWhereInput
    some?: VendorBillWhereInput
    none?: VendorBillWhereInput
  }

  export type CustomerInvoiceListRelationFilter = {
    every?: CustomerInvoiceWhereInput
    some?: CustomerInvoiceWhereInput
    none?: CustomerInvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type DocumentFileListRelationFilter = {
    every?: DocumentFileWhereInput
    some?: DocumentFileWhereInput
    none?: DocumentFileWhereInput
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GLAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoAnalyticModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorBillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type JournalLineListRelationFilter = {
    every?: JournalLineWhereInput
    some?: JournalLineWhereInput
    none?: JournalLineWhereInput
  }

  export type AutoAnalyticRuleListRelationFilter = {
    every?: AutoAnalyticRuleWhereInput
    some?: AutoAnalyticRuleWhereInput
    none?: AutoAnalyticRuleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type JournalLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoAnalyticRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCompanyIdEmailCompoundUniqueInput = {
    companyId: string
    email: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactType?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gstin?: SortOrder
    billingAddress?: SortOrder
    shippingAddress?: SortOrder
    isPortalUser?: SortOrder
    portalUserExternalId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactType?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gstin?: SortOrder
    isPortalUser?: SortOrder
    portalUserExternalId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactType?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gstin?: SortOrder
    isPortalUser?: SortOrder
    portalUserExternalId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ProductCategoryNullableScalarRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type ProductCategoryCompanyIdNameCompoundUniqueInput = {
    companyId: string
    name: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineListRelationFilter = {
    every?: PurchaseOrderLineWhereInput
    some?: PurchaseOrderLineWhereInput
    none?: PurchaseOrderLineWhereInput
  }

  export type SalesOrderLineListRelationFilter = {
    every?: SalesOrderLineWhereInput
    some?: SalesOrderLineWhereInput
    none?: SalesOrderLineWhereInput
  }

  export type VendorBillLineListRelationFilter = {
    every?: VendorBillLineWhereInput
    some?: VendorBillLineWhereInput
    none?: VendorBillLineWhereInput
  }

  export type CustomerInvoiceLineListRelationFilter = {
    every?: CustomerInvoiceLineWhereInput
    some?: CustomerInvoiceLineWhereInput
    none?: CustomerInvoiceLineWhereInput
  }

  export type PurchaseOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorBillLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerInvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCompanyIdSkuCompoundUniqueInput = {
    companyId: string
    sku: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    uom?: SortOrder
    salePrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    salePrice?: SortOrder
    costPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    uom?: SortOrder
    salePrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    uom?: SortOrder
    salePrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    salePrice?: SortOrder
    costPrice?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AnalyticAccountNullableScalarRelationFilter = {
    is?: AnalyticAccountWhereInput | null
    isNot?: AnalyticAccountWhereInput | null
  }

  export type BudgetLineListRelationFilter = {
    every?: BudgetLineWhereInput
    some?: BudgetLineWhereInput
    none?: BudgetLineWhereInput
  }

  export type BudgetLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticAccountCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type AnalyticAccountCompanyIdNameCompoundUniqueInput = {
    companyId: string
    name: string
  }

  export type AnalyticAccountCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticAccountMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type GLAccountCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type GLAccountCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
  }

  export type GLAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
  }

  export type GLAccountMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumJournalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusFilter<$PrismaModel> | $Enums.JournalStatus
  }

  export type EnumJournalSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalSourceType | EnumJournalSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalSourceTypeFilter<$PrismaModel> | $Enums.JournalSourceType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    entryDate?: SortOrder
    status?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    memo?: SortOrder
    createdAt?: SortOrder
    postedAt?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    entryDate?: SortOrder
    status?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    memo?: SortOrder
    createdAt?: SortOrder
    postedAt?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    entryDate?: SortOrder
    status?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    memo?: SortOrder
    createdAt?: SortOrder
    postedAt?: SortOrder
  }

  export type EnumJournalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusWithAggregatesFilter<$PrismaModel> | $Enums.JournalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalStatusFilter<$PrismaModel>
    _max?: NestedEnumJournalStatusFilter<$PrismaModel>
  }

  export type EnumJournalSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalSourceType | EnumJournalSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.JournalSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumJournalSourceTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type JournalEntryScalarRelationFilter = {
    is?: JournalEntryWhereInput
    isNot?: JournalEntryWhereInput
  }

  export type GLAccountScalarRelationFilter = {
    is?: GLAccountWhereInput
    isNot?: GLAccountWhereInput
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type JournalLineCountOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    glAccountId?: SortOrder
    analyticAccountId?: SortOrder
    contactId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type JournalLineAvgOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type JournalLineMaxOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    glAccountId?: SortOrder
    analyticAccountId?: SortOrder
    contactId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type JournalLineMinOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    glAccountId?: SortOrder
    analyticAccountId?: SortOrder
    contactId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type JournalLineSumOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type EnumBudgetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusFilter<$PrismaModel> | $Enums.BudgetStatus
  }

  export type BudgetRevisionListRelationFilter = {
    every?: BudgetRevisionWhereInput
    some?: BudgetRevisionWhereInput
    none?: BudgetRevisionWhereInput
  }

  export type BudgetRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type EnumBudgetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel> | $Enums.BudgetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetStatusFilter<$PrismaModel>
    _max?: NestedEnumBudgetStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BudgetScalarRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type BudgetRevisionBudgetIdRevisionNoCompoundUniqueInput = {
    budgetId: string
    revisionNo: number
  }

  export type BudgetRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    revisionNo?: SortOrder
    revisionReason?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type BudgetRevisionAvgOrderByAggregateInput = {
    revisionNo?: SortOrder
  }

  export type BudgetRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    revisionNo?: SortOrder
    revisionReason?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type BudgetRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    revisionNo?: SortOrder
    revisionReason?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type BudgetRevisionSumOrderByAggregateInput = {
    revisionNo?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BudgetRevisionScalarRelationFilter = {
    is?: BudgetRevisionWhereInput
    isNot?: BudgetRevisionWhereInput
  }

  export type AnalyticAccountScalarRelationFilter = {
    is?: AnalyticAccountWhereInput
    isNot?: AnalyticAccountWhereInput
  }

  export type GLAccountNullableScalarRelationFilter = {
    is?: GLAccountWhereInput | null
    isNot?: GLAccountWhereInput | null
  }

  export type BudgetLineBudgetRevisionIdAnalyticAccountIdGlAccountIdCompoundUniqueInput = {
    budgetRevisionId: string
    analyticAccountId: string
    glAccountId: string
  }

  export type BudgetLineCountOrderByAggregateInput = {
    id?: SortOrder
    budgetRevisionId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    amount?: SortOrder
  }

  export type BudgetLineAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BudgetLineMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetRevisionId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    amount?: SortOrder
  }

  export type BudgetLineMinOrderByAggregateInput = {
    id?: SortOrder
    budgetRevisionId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    amount?: SortOrder
  }

  export type BudgetLineSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AutoAnalyticModelCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AutoAnalyticModelAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type AutoAnalyticModelMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AutoAnalyticModelMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AutoAnalyticModelSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumAutoDocTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoDocType | EnumAutoDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoDocTypeFilter<$PrismaModel> | $Enums.AutoDocType
  }

  export type AutoAnalyticModelScalarRelationFilter = {
    is?: AutoAnalyticModelWhereInput
    isNot?: AutoAnalyticModelWhereInput
  }

  export type AutoAnalyticRuleCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    docType?: SortOrder
    matchProductId?: SortOrder
    matchCategoryId?: SortOrder
    matchContactId?: SortOrder
    assignAnalyticAccountId?: SortOrder
    rulePriority?: SortOrder
    isActive?: SortOrder
  }

  export type AutoAnalyticRuleAvgOrderByAggregateInput = {
    rulePriority?: SortOrder
  }

  export type AutoAnalyticRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    docType?: SortOrder
    matchProductId?: SortOrder
    matchCategoryId?: SortOrder
    matchContactId?: SortOrder
    assignAnalyticAccountId?: SortOrder
    rulePriority?: SortOrder
    isActive?: SortOrder
  }

  export type AutoAnalyticRuleMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    docType?: SortOrder
    matchProductId?: SortOrder
    matchCategoryId?: SortOrder
    matchContactId?: SortOrder
    assignAnalyticAccountId?: SortOrder
    rulePriority?: SortOrder
    isActive?: SortOrder
  }

  export type AutoAnalyticRuleSumOrderByAggregateInput = {
    rulePriority?: SortOrder
  }

  export type EnumAutoDocTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoDocType | EnumAutoDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoDocTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutoDocType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutoDocTypeFilter<$PrismaModel>
    _max?: NestedEnumAutoDocTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type PurchaseOrderCompanyIdPoNoCompoundUniqueInput = {
    companyId: string
    poNo: string
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    poNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    poNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    poNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type PurchaseOrderLineCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseOrderLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseOrderLineMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseOrderLineMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseOrderLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderCompanyIdSoNoCompoundUniqueInput = {
    companyId: string
    soNo: string
  }

  export type SalesOrderCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    soNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    soNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesOrderMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    soNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesOrderScalarRelationFilter = {
    is?: SalesOrderWhereInput
    isNot?: SalesOrderWhereInput
  }

  export type SalesOrderLineCountOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineMaxOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineMinOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type EnumDocStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusFilter<$PrismaModel> | $Enums.DocStatus
  }

  export type PurchaseOrderNullableScalarRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type VendorBillCompanyIdBillNoCompoundUniqueInput = {
    companyId: string
    billNo: string
  }

  export type VendorBillCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    billNo?: SortOrder
    vendorId?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    poId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorBillAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type VendorBillMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    billNo?: SortOrder
    vendorId?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    poId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorBillMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    billNo?: SortOrder
    vendorId?: SortOrder
    billDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    poId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorBillSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumDocStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocStatusFilter<$PrismaModel>
    _max?: NestedEnumDocStatusFilter<$PrismaModel>
  }

  export type VendorBillScalarRelationFilter = {
    is?: VendorBillWhereInput
    isNot?: VendorBillWhereInput
  }

  export type VendorBillLineCountOrderByAggregateInput = {
    id?: SortOrder
    vendorBillId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type VendorBillLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type VendorBillLineMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorBillId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type VendorBillLineMinOrderByAggregateInput = {
    id?: SortOrder
    vendorBillId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type VendorBillLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderNullableScalarRelationFilter = {
    is?: SalesOrderWhereInput | null
    isNot?: SalesOrderWhereInput | null
  }

  export type CustomerInvoiceCompanyIdInvoiceNoCompoundUniqueInput = {
    companyId: string
    invoiceNo: string
  }

  export type CustomerInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    invoiceNo?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    soId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    portalVisible?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerInvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type CustomerInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    invoiceNo?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    soId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    portalVisible?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    invoiceNo?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    soId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentState?: SortOrder
    portalVisible?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerInvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type CustomerInvoiceScalarRelationFilter = {
    is?: CustomerInvoiceWhereInput
    isNot?: CustomerInvoiceWhereInput
  }

  export type CustomerInvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    customerInvoiceId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type CustomerInvoiceLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type CustomerInvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    customerInvoiceId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type CustomerInvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    customerInvoiceId?: SortOrder
    productId?: SortOrder
    analyticAccountId?: SortOrder
    glAccountId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type CustomerInvoiceLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    lineTotal?: SortOrder
  }

  export type EnumPaymentDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentDirection | EnumPaymentDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentDirectionFilter<$PrismaModel> | $Enums.PaymentDirection
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentAllocationListRelationFilter = {
    every?: PaymentAllocationWhereInput
    some?: PaymentAllocationWhereInput
    none?: PaymentAllocationWhereInput
  }

  export type PaymentAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    direction?: SortOrder
    contactId?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    direction?: SortOrder
    contactId?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    direction?: SortOrder
    contactId?: SortOrder
    paymentDate?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentDirection | EnumPaymentDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentDirectionWithAggregatesFilter<$PrismaModel> | $Enums.PaymentDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentDirectionFilter<$PrismaModel>
    _max?: NestedEnumPaymentDirectionFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumAllocationTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationTargetType | EnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationTargetTypeFilter<$PrismaModel> | $Enums.AllocationTargetType
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PaymentAllocationPaymentIdTargetTypeTargetIdCompoundUniqueInput = {
    paymentId: string
    targetType: $Enums.AllocationTargetType
    targetId: string
  }

  export type PaymentAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentAllocationAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentAllocationSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumAllocationTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationTargetType | EnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AllocationTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllocationTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumAllocationTargetTypeFilter<$PrismaModel>
  }

  export type EnumDocOwnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocOwnerType | EnumDocOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocOwnerTypeFilter<$PrismaModel> | $Enums.DocOwnerType
  }

  export type DocumentFileCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    storageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentFileMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    storageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentFileMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    ownerType?: SortOrder
    ownerId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    storageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDocOwnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocOwnerType | EnumDocOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocOwnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocOwnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocOwnerTypeFilter<$PrismaModel>
    _max?: NestedEnumDocOwnerTypeFilter<$PrismaModel>
  }

  export type ContactCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AnalyticAccountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AnalyticAccountCreateWithoutCompanyInput, AnalyticAccountUncheckedCreateWithoutCompanyInput> | AnalyticAccountCreateWithoutCompanyInput[] | AnalyticAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutCompanyInput | AnalyticAccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AnalyticAccountCreateManyCompanyInputEnvelope
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
  }

  export type GLAccountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GLAccountCreateWithoutCompanyInput, GLAccountUncheckedCreateWithoutCompanyInput> | GLAccountCreateWithoutCompanyInput[] | GLAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GLAccountCreateOrConnectWithoutCompanyInput | GLAccountCreateOrConnectWithoutCompanyInput[]
    createMany?: GLAccountCreateManyCompanyInputEnvelope
    connect?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
  }

  export type JournalEntryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BudgetCreateWithoutCompanyInput, BudgetUncheckedCreateWithoutCompanyInput> | BudgetCreateWithoutCompanyInput[] | BudgetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCompanyInput | BudgetCreateOrConnectWithoutCompanyInput[]
    createMany?: BudgetCreateManyCompanyInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type AutoAnalyticModelCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AutoAnalyticModelCreateWithoutCompanyInput, AutoAnalyticModelUncheckedCreateWithoutCompanyInput> | AutoAnalyticModelCreateWithoutCompanyInput[] | AutoAnalyticModelUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AutoAnalyticModelCreateOrConnectWithoutCompanyInput | AutoAnalyticModelCreateOrConnectWithoutCompanyInput[]
    createMany?: AutoAnalyticModelCreateManyCompanyInputEnvelope
    connect?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SalesOrderCreateWithoutCompanyInput, SalesOrderUncheckedCreateWithoutCompanyInput> | SalesOrderCreateWithoutCompanyInput[] | SalesOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCompanyInput | SalesOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: SalesOrderCreateManyCompanyInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type VendorBillCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorBillCreateWithoutCompanyInput, VendorBillUncheckedCreateWithoutCompanyInput> | VendorBillCreateWithoutCompanyInput[] | VendorBillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutCompanyInput | VendorBillCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorBillCreateManyCompanyInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type CustomerInvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCompanyInput, CustomerInvoiceUncheckedCreateWithoutCompanyInput> | CustomerInvoiceCreateWithoutCompanyInput[] | CustomerInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCompanyInput | CustomerInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: CustomerInvoiceCreateManyCompanyInputEnvelope
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentFileCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentFileCreateWithoutCompanyInput, DocumentFileUncheckedCreateWithoutCompanyInput> | DocumentFileCreateWithoutCompanyInput[] | DocumentFileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentFileCreateOrConnectWithoutCompanyInput | DocumentFileCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentFileCreateManyCompanyInputEnvelope
    connect?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AnalyticAccountCreateWithoutCompanyInput, AnalyticAccountUncheckedCreateWithoutCompanyInput> | AnalyticAccountCreateWithoutCompanyInput[] | AnalyticAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutCompanyInput | AnalyticAccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AnalyticAccountCreateManyCompanyInputEnvelope
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
  }

  export type GLAccountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GLAccountCreateWithoutCompanyInput, GLAccountUncheckedCreateWithoutCompanyInput> | GLAccountCreateWithoutCompanyInput[] | GLAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GLAccountCreateOrConnectWithoutCompanyInput | GLAccountCreateOrConnectWithoutCompanyInput[]
    createMany?: GLAccountCreateManyCompanyInputEnvelope
    connect?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BudgetCreateWithoutCompanyInput, BudgetUncheckedCreateWithoutCompanyInput> | BudgetCreateWithoutCompanyInput[] | BudgetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCompanyInput | BudgetCreateOrConnectWithoutCompanyInput[]
    createMany?: BudgetCreateManyCompanyInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AutoAnalyticModelCreateWithoutCompanyInput, AutoAnalyticModelUncheckedCreateWithoutCompanyInput> | AutoAnalyticModelCreateWithoutCompanyInput[] | AutoAnalyticModelUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AutoAnalyticModelCreateOrConnectWithoutCompanyInput | AutoAnalyticModelCreateOrConnectWithoutCompanyInput[]
    createMany?: AutoAnalyticModelCreateManyCompanyInputEnvelope
    connect?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SalesOrderCreateWithoutCompanyInput, SalesOrderUncheckedCreateWithoutCompanyInput> | SalesOrderCreateWithoutCompanyInput[] | SalesOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCompanyInput | SalesOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: SalesOrderCreateManyCompanyInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type VendorBillUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorBillCreateWithoutCompanyInput, VendorBillUncheckedCreateWithoutCompanyInput> | VendorBillCreateWithoutCompanyInput[] | VendorBillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutCompanyInput | VendorBillCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorBillCreateManyCompanyInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCompanyInput, CustomerInvoiceUncheckedCreateWithoutCompanyInput> | CustomerInvoiceCreateWithoutCompanyInput[] | CustomerInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCompanyInput | CustomerInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: CustomerInvoiceCreateManyCompanyInputEnvelope
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentFileUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentFileCreateWithoutCompanyInput, DocumentFileUncheckedCreateWithoutCompanyInput> | DocumentFileCreateWithoutCompanyInput[] | DocumentFileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentFileCreateOrConnectWithoutCompanyInput | DocumentFileCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentFileCreateManyCompanyInputEnvelope
    connect?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ContactUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput | ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput | ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCompanyInput | ProductCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCompanyInput | ProductUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCompanyInput | ProductUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCompanyInput | ProductUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AnalyticAccountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutCompanyInput, AnalyticAccountUncheckedCreateWithoutCompanyInput> | AnalyticAccountCreateWithoutCompanyInput[] | AnalyticAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutCompanyInput | AnalyticAccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AnalyticAccountUpsertWithWhereUniqueWithoutCompanyInput | AnalyticAccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AnalyticAccountCreateManyCompanyInputEnvelope
    set?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    disconnect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    delete?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    update?: AnalyticAccountUpdateWithWhereUniqueWithoutCompanyInput | AnalyticAccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AnalyticAccountUpdateManyWithWhereWithoutCompanyInput | AnalyticAccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AnalyticAccountScalarWhereInput | AnalyticAccountScalarWhereInput[]
  }

  export type GLAccountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GLAccountCreateWithoutCompanyInput, GLAccountUncheckedCreateWithoutCompanyInput> | GLAccountCreateWithoutCompanyInput[] | GLAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GLAccountCreateOrConnectWithoutCompanyInput | GLAccountCreateOrConnectWithoutCompanyInput[]
    upsert?: GLAccountUpsertWithWhereUniqueWithoutCompanyInput | GLAccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GLAccountCreateManyCompanyInputEnvelope
    set?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    disconnect?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    delete?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    connect?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    update?: GLAccountUpdateWithWhereUniqueWithoutCompanyInput | GLAccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GLAccountUpdateManyWithWhereWithoutCompanyInput | GLAccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GLAccountScalarWhereInput | GLAccountScalarWhereInput[]
  }

  export type JournalEntryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutCompanyInput | JournalEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutCompanyInput | JournalEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutCompanyInput | JournalEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BudgetCreateWithoutCompanyInput, BudgetUncheckedCreateWithoutCompanyInput> | BudgetCreateWithoutCompanyInput[] | BudgetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCompanyInput | BudgetCreateOrConnectWithoutCompanyInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutCompanyInput | BudgetUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BudgetCreateManyCompanyInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutCompanyInput | BudgetUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutCompanyInput | BudgetUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type AutoAnalyticModelUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AutoAnalyticModelCreateWithoutCompanyInput, AutoAnalyticModelUncheckedCreateWithoutCompanyInput> | AutoAnalyticModelCreateWithoutCompanyInput[] | AutoAnalyticModelUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AutoAnalyticModelCreateOrConnectWithoutCompanyInput | AutoAnalyticModelCreateOrConnectWithoutCompanyInput[]
    upsert?: AutoAnalyticModelUpsertWithWhereUniqueWithoutCompanyInput | AutoAnalyticModelUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AutoAnalyticModelCreateManyCompanyInputEnvelope
    set?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    disconnect?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    delete?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    connect?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    update?: AutoAnalyticModelUpdateWithWhereUniqueWithoutCompanyInput | AutoAnalyticModelUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AutoAnalyticModelUpdateManyWithWhereWithoutCompanyInput | AutoAnalyticModelUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AutoAnalyticModelScalarWhereInput | AutoAnalyticModelScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCompanyInput, SalesOrderUncheckedCreateWithoutCompanyInput> | SalesOrderCreateWithoutCompanyInput[] | SalesOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCompanyInput | SalesOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCompanyInput | SalesOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SalesOrderCreateManyCompanyInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCompanyInput | SalesOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCompanyInput | SalesOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type VendorBillUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorBillCreateWithoutCompanyInput, VendorBillUncheckedCreateWithoutCompanyInput> | VendorBillCreateWithoutCompanyInput[] | VendorBillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutCompanyInput | VendorBillCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutCompanyInput | VendorBillUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorBillCreateManyCompanyInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutCompanyInput | VendorBillUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutCompanyInput | VendorBillUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type CustomerInvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCompanyInput, CustomerInvoiceUncheckedCreateWithoutCompanyInput> | CustomerInvoiceCreateWithoutCompanyInput[] | CustomerInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCompanyInput | CustomerInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: CustomerInvoiceUpsertWithWhereUniqueWithoutCompanyInput | CustomerInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CustomerInvoiceCreateManyCompanyInputEnvelope
    set?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    disconnect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    delete?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    update?: CustomerInvoiceUpdateWithWhereUniqueWithoutCompanyInput | CustomerInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CustomerInvoiceUpdateManyWithWhereWithoutCompanyInput | CustomerInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DocumentFileUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentFileCreateWithoutCompanyInput, DocumentFileUncheckedCreateWithoutCompanyInput> | DocumentFileCreateWithoutCompanyInput[] | DocumentFileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentFileCreateOrConnectWithoutCompanyInput | DocumentFileCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentFileUpsertWithWhereUniqueWithoutCompanyInput | DocumentFileUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentFileCreateManyCompanyInputEnvelope
    set?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    disconnect?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    delete?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    connect?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    update?: DocumentFileUpdateWithWhereUniqueWithoutCompanyInput | DocumentFileUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentFileUpdateManyWithWhereWithoutCompanyInput | DocumentFileUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentFileScalarWhereInput | DocumentFileScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput> | ProductCategoryCreateWithoutCompanyInput[] | ProductCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCompanyInput | ProductCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput | ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCategoryCreateManyCompanyInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput | ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCompanyInput | ProductCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput> | ProductCreateWithoutCompanyInput[] | ProductUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCompanyInput | ProductCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCompanyInput | ProductUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductCreateManyCompanyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCompanyInput | ProductUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCompanyInput | ProductUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutCompanyInput, AnalyticAccountUncheckedCreateWithoutCompanyInput> | AnalyticAccountCreateWithoutCompanyInput[] | AnalyticAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutCompanyInput | AnalyticAccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AnalyticAccountUpsertWithWhereUniqueWithoutCompanyInput | AnalyticAccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AnalyticAccountCreateManyCompanyInputEnvelope
    set?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    disconnect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    delete?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    update?: AnalyticAccountUpdateWithWhereUniqueWithoutCompanyInput | AnalyticAccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AnalyticAccountUpdateManyWithWhereWithoutCompanyInput | AnalyticAccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AnalyticAccountScalarWhereInput | AnalyticAccountScalarWhereInput[]
  }

  export type GLAccountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GLAccountCreateWithoutCompanyInput, GLAccountUncheckedCreateWithoutCompanyInput> | GLAccountCreateWithoutCompanyInput[] | GLAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GLAccountCreateOrConnectWithoutCompanyInput | GLAccountCreateOrConnectWithoutCompanyInput[]
    upsert?: GLAccountUpsertWithWhereUniqueWithoutCompanyInput | GLAccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GLAccountCreateManyCompanyInputEnvelope
    set?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    disconnect?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    delete?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    connect?: GLAccountWhereUniqueInput | GLAccountWhereUniqueInput[]
    update?: GLAccountUpdateWithWhereUniqueWithoutCompanyInput | GLAccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GLAccountUpdateManyWithWhereWithoutCompanyInput | GLAccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GLAccountScalarWhereInput | GLAccountScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutCompanyInput | JournalEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutCompanyInput | JournalEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutCompanyInput | JournalEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BudgetCreateWithoutCompanyInput, BudgetUncheckedCreateWithoutCompanyInput> | BudgetCreateWithoutCompanyInput[] | BudgetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCompanyInput | BudgetCreateOrConnectWithoutCompanyInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutCompanyInput | BudgetUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BudgetCreateManyCompanyInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutCompanyInput | BudgetUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutCompanyInput | BudgetUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AutoAnalyticModelCreateWithoutCompanyInput, AutoAnalyticModelUncheckedCreateWithoutCompanyInput> | AutoAnalyticModelCreateWithoutCompanyInput[] | AutoAnalyticModelUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AutoAnalyticModelCreateOrConnectWithoutCompanyInput | AutoAnalyticModelCreateOrConnectWithoutCompanyInput[]
    upsert?: AutoAnalyticModelUpsertWithWhereUniqueWithoutCompanyInput | AutoAnalyticModelUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AutoAnalyticModelCreateManyCompanyInputEnvelope
    set?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    disconnect?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    delete?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    connect?: AutoAnalyticModelWhereUniqueInput | AutoAnalyticModelWhereUniqueInput[]
    update?: AutoAnalyticModelUpdateWithWhereUniqueWithoutCompanyInput | AutoAnalyticModelUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AutoAnalyticModelUpdateManyWithWhereWithoutCompanyInput | AutoAnalyticModelUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AutoAnalyticModelScalarWhereInput | AutoAnalyticModelScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCompanyInput, SalesOrderUncheckedCreateWithoutCompanyInput> | SalesOrderCreateWithoutCompanyInput[] | SalesOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCompanyInput | SalesOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCompanyInput | SalesOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SalesOrderCreateManyCompanyInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCompanyInput | SalesOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCompanyInput | SalesOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type VendorBillUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorBillCreateWithoutCompanyInput, VendorBillUncheckedCreateWithoutCompanyInput> | VendorBillCreateWithoutCompanyInput[] | VendorBillUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutCompanyInput | VendorBillCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutCompanyInput | VendorBillUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorBillCreateManyCompanyInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutCompanyInput | VendorBillUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutCompanyInput | VendorBillUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCompanyInput, CustomerInvoiceUncheckedCreateWithoutCompanyInput> | CustomerInvoiceCreateWithoutCompanyInput[] | CustomerInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCompanyInput | CustomerInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: CustomerInvoiceUpsertWithWhereUniqueWithoutCompanyInput | CustomerInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CustomerInvoiceCreateManyCompanyInputEnvelope
    set?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    disconnect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    delete?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    update?: CustomerInvoiceUpdateWithWhereUniqueWithoutCompanyInput | CustomerInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CustomerInvoiceUpdateManyWithWhereWithoutCompanyInput | CustomerInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentFileCreateWithoutCompanyInput, DocumentFileUncheckedCreateWithoutCompanyInput> | DocumentFileCreateWithoutCompanyInput[] | DocumentFileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentFileCreateOrConnectWithoutCompanyInput | DocumentFileCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentFileUpsertWithWhereUniqueWithoutCompanyInput | DocumentFileUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentFileCreateManyCompanyInputEnvelope
    set?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    disconnect?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    delete?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    connect?: DocumentFileWhereUniqueInput | DocumentFileWhereUniqueInput[]
    update?: DocumentFileUpdateWithWhereUniqueWithoutCompanyInput | DocumentFileUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentFileUpdateManyWithWhereWithoutCompanyInput | DocumentFileUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentFileScalarWhereInput | DocumentFileScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutContactsInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type VendorBillCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type CustomerInvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCustomerInput, CustomerInvoiceUncheckedCreateWithoutCustomerInput> | CustomerInvoiceCreateWithoutCustomerInput[] | CustomerInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCustomerInput | CustomerInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerInvoiceCreateManyCustomerInputEnvelope
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutContactInput = {
    create?: XOR<PaymentCreateWithoutContactInput, PaymentUncheckedCreateWithoutContactInput> | PaymentCreateWithoutContactInput[] | PaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContactInput | PaymentCreateOrConnectWithoutContactInput[]
    createMany?: PaymentCreateManyContactInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type JournalLineCreateNestedManyWithoutContactInput = {
    create?: XOR<JournalLineCreateWithoutContactInput, JournalLineUncheckedCreateWithoutContactInput> | JournalLineCreateWithoutContactInput[] | JournalLineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutContactInput | JournalLineCreateOrConnectWithoutContactInput[]
    createMany?: JournalLineCreateManyContactInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type AutoAnalyticRuleCreateNestedManyWithoutContactInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutContactInput, AutoAnalyticRuleUncheckedCreateWithoutContactInput> | AutoAnalyticRuleCreateWithoutContactInput[] | AutoAnalyticRuleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutContactInput | AutoAnalyticRuleCreateOrConnectWithoutContactInput[]
    createMany?: AutoAnalyticRuleCreateManyContactInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type VendorBillUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCustomerInput, CustomerInvoiceUncheckedCreateWithoutCustomerInput> | CustomerInvoiceCreateWithoutCustomerInput[] | CustomerInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCustomerInput | CustomerInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerInvoiceCreateManyCustomerInputEnvelope
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<PaymentCreateWithoutContactInput, PaymentUncheckedCreateWithoutContactInput> | PaymentCreateWithoutContactInput[] | PaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContactInput | PaymentCreateOrConnectWithoutContactInput[]
    createMany?: PaymentCreateManyContactInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<JournalLineCreateWithoutContactInput, JournalLineUncheckedCreateWithoutContactInput> | JournalLineCreateWithoutContactInput[] | JournalLineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutContactInput | JournalLineCreateOrConnectWithoutContactInput[]
    createMany?: JournalLineCreateManyContactInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutContactInput, AutoAnalyticRuleUncheckedCreateWithoutContactInput> | AutoAnalyticRuleCreateWithoutContactInput[] | AutoAnalyticRuleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutContactInput | AutoAnalyticRuleCreateOrConnectWithoutContactInput[]
    createMany?: AutoAnalyticRuleCreateManyContactInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CompanyUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    upsert?: CompanyUpsertWithoutContactsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutContactsInput, CompanyUpdateWithoutContactsInput>, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type PurchaseOrderUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type VendorBillUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutVendorInput | VendorBillUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutVendorInput | VendorBillUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutVendorInput | VendorBillUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type CustomerInvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCustomerInput, CustomerInvoiceUncheckedCreateWithoutCustomerInput> | CustomerInvoiceCreateWithoutCustomerInput[] | CustomerInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCustomerInput | CustomerInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerInvoiceUpsertWithWhereUniqueWithoutCustomerInput | CustomerInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerInvoiceCreateManyCustomerInputEnvelope
    set?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    disconnect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    delete?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    update?: CustomerInvoiceUpdateWithWhereUniqueWithoutCustomerInput | CustomerInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerInvoiceUpdateManyWithWhereWithoutCustomerInput | CustomerInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutContactNestedInput = {
    create?: XOR<PaymentCreateWithoutContactInput, PaymentUncheckedCreateWithoutContactInput> | PaymentCreateWithoutContactInput[] | PaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContactInput | PaymentCreateOrConnectWithoutContactInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContactInput | PaymentUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PaymentCreateManyContactInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContactInput | PaymentUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContactInput | PaymentUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type JournalLineUpdateManyWithoutContactNestedInput = {
    create?: XOR<JournalLineCreateWithoutContactInput, JournalLineUncheckedCreateWithoutContactInput> | JournalLineCreateWithoutContactInput[] | JournalLineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutContactInput | JournalLineCreateOrConnectWithoutContactInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutContactInput | JournalLineUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: JournalLineCreateManyContactInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutContactInput | JournalLineUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutContactInput | JournalLineUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AutoAnalyticRuleUpdateManyWithoutContactNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutContactInput, AutoAnalyticRuleUncheckedCreateWithoutContactInput> | AutoAnalyticRuleCreateWithoutContactInput[] | AutoAnalyticRuleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutContactInput | AutoAnalyticRuleCreateOrConnectWithoutContactInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutContactInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: AutoAnalyticRuleCreateManyContactInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutContactInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutContactInput | AutoAnalyticRuleUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type VendorBillUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutVendorInput | VendorBillUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutVendorInput | VendorBillUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutVendorInput | VendorBillUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutCustomerInput, CustomerInvoiceUncheckedCreateWithoutCustomerInput> | CustomerInvoiceCreateWithoutCustomerInput[] | CustomerInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutCustomerInput | CustomerInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerInvoiceUpsertWithWhereUniqueWithoutCustomerInput | CustomerInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerInvoiceCreateManyCustomerInputEnvelope
    set?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    disconnect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    delete?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    update?: CustomerInvoiceUpdateWithWhereUniqueWithoutCustomerInput | CustomerInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerInvoiceUpdateManyWithWhereWithoutCustomerInput | CustomerInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<PaymentCreateWithoutContactInput, PaymentUncheckedCreateWithoutContactInput> | PaymentCreateWithoutContactInput[] | PaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContactInput | PaymentCreateOrConnectWithoutContactInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContactInput | PaymentUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PaymentCreateManyContactInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContactInput | PaymentUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContactInput | PaymentUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<JournalLineCreateWithoutContactInput, JournalLineUncheckedCreateWithoutContactInput> | JournalLineCreateWithoutContactInput[] | JournalLineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutContactInput | JournalLineCreateOrConnectWithoutContactInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutContactInput | JournalLineUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: JournalLineCreateManyContactInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutContactInput | JournalLineUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutContactInput | JournalLineUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutContactInput, AutoAnalyticRuleUncheckedCreateWithoutContactInput> | AutoAnalyticRuleCreateWithoutContactInput[] | AutoAnalyticRuleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutContactInput | AutoAnalyticRuleCreateOrConnectWithoutContactInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutContactInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: AutoAnalyticRuleCreateManyContactInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutContactInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutContactInput | AutoAnalyticRuleUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductCategoriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AutoAnalyticRuleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutCategoryInput, AutoAnalyticRuleUncheckedCreateWithoutCategoryInput> | AutoAnalyticRuleCreateWithoutCategoryInput[] | AutoAnalyticRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutCategoryInput | AutoAnalyticRuleCreateOrConnectWithoutCategoryInput[]
    createMany?: AutoAnalyticRuleCreateManyCategoryInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AutoAnalyticRuleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutCategoryInput, AutoAnalyticRuleUncheckedCreateWithoutCategoryInput> | AutoAnalyticRuleCreateWithoutCategoryInput[] | AutoAnalyticRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutCategoryInput | AutoAnalyticRuleCreateOrConnectWithoutCategoryInput[]
    createMany?: AutoAnalyticRuleCreateManyCategoryInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput = {
    create?: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductCategoriesInput
    upsert?: CompanyUpsertWithoutProductCategoriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProductCategoriesInput, CompanyUpdateWithoutProductCategoriesInput>, CompanyUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type ProductCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    upsert?: ProductCategoryUpsertWithoutChildrenInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutChildrenInput, ProductCategoryUpdateWithoutChildrenInput>, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AutoAnalyticRuleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutCategoryInput, AutoAnalyticRuleUncheckedCreateWithoutCategoryInput> | AutoAnalyticRuleCreateWithoutCategoryInput[] | AutoAnalyticRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutCategoryInput | AutoAnalyticRuleCreateOrConnectWithoutCategoryInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutCategoryInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AutoAnalyticRuleCreateManyCategoryInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutCategoryInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutCategoryInput | AutoAnalyticRuleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutCategoryInput, AutoAnalyticRuleUncheckedCreateWithoutCategoryInput> | AutoAnalyticRuleCreateWithoutCategoryInput[] | AutoAnalyticRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutCategoryInput | AutoAnalyticRuleCreateOrConnectWithoutCategoryInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutCategoryInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AutoAnalyticRuleCreateManyCategoryInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutCategoryInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutCategoryInput | AutoAnalyticRuleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutProductsInput = {
    create?: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type PurchaseOrderLineCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutProductInput, PurchaseOrderLineUncheckedCreateWithoutProductInput> | PurchaseOrderLineCreateWithoutProductInput[] | PurchaseOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutProductInput | PurchaseOrderLineCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderLineCreateManyProductInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineCreateNestedManyWithoutProductInput = {
    create?: XOR<SalesOrderLineCreateWithoutProductInput, SalesOrderLineUncheckedCreateWithoutProductInput> | SalesOrderLineCreateWithoutProductInput[] | SalesOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutProductInput | SalesOrderLineCreateOrConnectWithoutProductInput[]
    createMany?: SalesOrderLineCreateManyProductInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type VendorBillLineCreateNestedManyWithoutProductInput = {
    create?: XOR<VendorBillLineCreateWithoutProductInput, VendorBillLineUncheckedCreateWithoutProductInput> | VendorBillLineCreateWithoutProductInput[] | VendorBillLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutProductInput | VendorBillLineCreateOrConnectWithoutProductInput[]
    createMany?: VendorBillLineCreateManyProductInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type CustomerInvoiceLineCreateNestedManyWithoutProductInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutProductInput, CustomerInvoiceLineUncheckedCreateWithoutProductInput> | CustomerInvoiceLineCreateWithoutProductInput[] | CustomerInvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutProductInput | CustomerInvoiceLineCreateOrConnectWithoutProductInput[]
    createMany?: CustomerInvoiceLineCreateManyProductInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type JournalLineCreateNestedManyWithoutProductInput = {
    create?: XOR<JournalLineCreateWithoutProductInput, JournalLineUncheckedCreateWithoutProductInput> | JournalLineCreateWithoutProductInput[] | JournalLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutProductInput | JournalLineCreateOrConnectWithoutProductInput[]
    createMany?: JournalLineCreateManyProductInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type AutoAnalyticRuleCreateNestedManyWithoutProductInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutProductInput, AutoAnalyticRuleUncheckedCreateWithoutProductInput> | AutoAnalyticRuleCreateWithoutProductInput[] | AutoAnalyticRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutProductInput | AutoAnalyticRuleCreateOrConnectWithoutProductInput[]
    createMany?: AutoAnalyticRuleCreateManyProductInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutProductInput, PurchaseOrderLineUncheckedCreateWithoutProductInput> | PurchaseOrderLineCreateWithoutProductInput[] | PurchaseOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutProductInput | PurchaseOrderLineCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderLineCreateManyProductInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SalesOrderLineCreateWithoutProductInput, SalesOrderLineUncheckedCreateWithoutProductInput> | SalesOrderLineCreateWithoutProductInput[] | SalesOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutProductInput | SalesOrderLineCreateOrConnectWithoutProductInput[]
    createMany?: SalesOrderLineCreateManyProductInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type VendorBillLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<VendorBillLineCreateWithoutProductInput, VendorBillLineUncheckedCreateWithoutProductInput> | VendorBillLineCreateWithoutProductInput[] | VendorBillLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutProductInput | VendorBillLineCreateOrConnectWithoutProductInput[]
    createMany?: VendorBillLineCreateManyProductInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutProductInput, CustomerInvoiceLineUncheckedCreateWithoutProductInput> | CustomerInvoiceLineCreateWithoutProductInput[] | CustomerInvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutProductInput | CustomerInvoiceLineCreateOrConnectWithoutProductInput[]
    createMany?: CustomerInvoiceLineCreateManyProductInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<JournalLineCreateWithoutProductInput, JournalLineUncheckedCreateWithoutProductInput> | JournalLineCreateWithoutProductInput[] | JournalLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutProductInput | JournalLineCreateOrConnectWithoutProductInput[]
    createMany?: JournalLineCreateManyProductInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutProductInput, AutoAnalyticRuleUncheckedCreateWithoutProductInput> | AutoAnalyticRuleCreateWithoutProductInput[] | AutoAnalyticRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutProductInput | AutoAnalyticRuleCreateOrConnectWithoutProductInput[]
    createMany?: AutoAnalyticRuleCreateManyProductInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CompanyUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProductsInput
    upsert?: CompanyUpsertWithoutProductsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProductsInput, CompanyUpdateWithoutProductsInput>, CompanyUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseOrderLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutProductInput, PurchaseOrderLineUncheckedCreateWithoutProductInput> | PurchaseOrderLineCreateWithoutProductInput[] | PurchaseOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutProductInput | PurchaseOrderLineCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderLineCreateManyProductInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutProductInput | PurchaseOrderLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutProductInput, SalesOrderLineUncheckedCreateWithoutProductInput> | SalesOrderLineCreateWithoutProductInput[] | SalesOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutProductInput | SalesOrderLineCreateOrConnectWithoutProductInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutProductInput | SalesOrderLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SalesOrderLineCreateManyProductInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutProductInput | SalesOrderLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutProductInput | SalesOrderLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type VendorBillLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutProductInput, VendorBillLineUncheckedCreateWithoutProductInput> | VendorBillLineCreateWithoutProductInput[] | VendorBillLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutProductInput | VendorBillLineCreateOrConnectWithoutProductInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutProductInput | VendorBillLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VendorBillLineCreateManyProductInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutProductInput | VendorBillLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutProductInput | VendorBillLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type CustomerInvoiceLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutProductInput, CustomerInvoiceLineUncheckedCreateWithoutProductInput> | CustomerInvoiceLineCreateWithoutProductInput[] | CustomerInvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutProductInput | CustomerInvoiceLineCreateOrConnectWithoutProductInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutProductInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CustomerInvoiceLineCreateManyProductInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutProductInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutProductInput | CustomerInvoiceLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type JournalLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<JournalLineCreateWithoutProductInput, JournalLineUncheckedCreateWithoutProductInput> | JournalLineCreateWithoutProductInput[] | JournalLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutProductInput | JournalLineCreateOrConnectWithoutProductInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutProductInput | JournalLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: JournalLineCreateManyProductInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutProductInput | JournalLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutProductInput | JournalLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AutoAnalyticRuleUpdateManyWithoutProductNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutProductInput, AutoAnalyticRuleUncheckedCreateWithoutProductInput> | AutoAnalyticRuleCreateWithoutProductInput[] | AutoAnalyticRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutProductInput | AutoAnalyticRuleCreateOrConnectWithoutProductInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutProductInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AutoAnalyticRuleCreateManyProductInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutProductInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutProductInput | AutoAnalyticRuleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutProductInput, PurchaseOrderLineUncheckedCreateWithoutProductInput> | PurchaseOrderLineCreateWithoutProductInput[] | PurchaseOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutProductInput | PurchaseOrderLineCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderLineCreateManyProductInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutProductInput | PurchaseOrderLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutProductInput, SalesOrderLineUncheckedCreateWithoutProductInput> | SalesOrderLineCreateWithoutProductInput[] | SalesOrderLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutProductInput | SalesOrderLineCreateOrConnectWithoutProductInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutProductInput | SalesOrderLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SalesOrderLineCreateManyProductInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutProductInput | SalesOrderLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutProductInput | SalesOrderLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type VendorBillLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutProductInput, VendorBillLineUncheckedCreateWithoutProductInput> | VendorBillLineCreateWithoutProductInput[] | VendorBillLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutProductInput | VendorBillLineCreateOrConnectWithoutProductInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutProductInput | VendorBillLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VendorBillLineCreateManyProductInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutProductInput | VendorBillLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutProductInput | VendorBillLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutProductInput, CustomerInvoiceLineUncheckedCreateWithoutProductInput> | CustomerInvoiceLineCreateWithoutProductInput[] | CustomerInvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutProductInput | CustomerInvoiceLineCreateOrConnectWithoutProductInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutProductInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CustomerInvoiceLineCreateManyProductInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutProductInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutProductInput | CustomerInvoiceLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<JournalLineCreateWithoutProductInput, JournalLineUncheckedCreateWithoutProductInput> | JournalLineCreateWithoutProductInput[] | JournalLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutProductInput | JournalLineCreateOrConnectWithoutProductInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutProductInput | JournalLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: JournalLineCreateManyProductInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutProductInput | JournalLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutProductInput | JournalLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutProductInput, AutoAnalyticRuleUncheckedCreateWithoutProductInput> | AutoAnalyticRuleCreateWithoutProductInput[] | AutoAnalyticRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutProductInput | AutoAnalyticRuleCreateOrConnectWithoutProductInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutProductInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AutoAnalyticRuleCreateManyProductInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutProductInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutProductInput | AutoAnalyticRuleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutAnalyticAccountsInput = {
    create?: XOR<CompanyCreateWithoutAnalyticAccountsInput, CompanyUncheckedCreateWithoutAnalyticAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAnalyticAccountsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutChildrenInput = {
    create?: XOR<AnalyticAccountCreateWithoutChildrenInput, AnalyticAccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutChildrenInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedManyWithoutParentInput = {
    create?: XOR<AnalyticAccountCreateWithoutParentInput, AnalyticAccountUncheckedCreateWithoutParentInput> | AnalyticAccountCreateWithoutParentInput[] | AnalyticAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutParentInput | AnalyticAccountCreateOrConnectWithoutParentInput[]
    createMany?: AnalyticAccountCreateManyParentInputEnvelope
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
  }

  export type BudgetLineCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<BudgetLineCreateWithoutAnalyticInput, BudgetLineUncheckedCreateWithoutAnalyticInput> | BudgetLineCreateWithoutAnalyticInput[] | BudgetLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutAnalyticInput | BudgetLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: BudgetLineCreateManyAnalyticInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type JournalLineCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<JournalLineCreateWithoutAnalyticInput, JournalLineUncheckedCreateWithoutAnalyticInput> | JournalLineCreateWithoutAnalyticInput[] | JournalLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAnalyticInput | JournalLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: JournalLineCreateManyAnalyticInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type PurchaseOrderLineCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutAnalyticInput, PurchaseOrderLineUncheckedCreateWithoutAnalyticInput> | PurchaseOrderLineCreateWithoutAnalyticInput[] | PurchaseOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutAnalyticInput | PurchaseOrderLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: PurchaseOrderLineCreateManyAnalyticInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<SalesOrderLineCreateWithoutAnalyticInput, SalesOrderLineUncheckedCreateWithoutAnalyticInput> | SalesOrderLineCreateWithoutAnalyticInput[] | SalesOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutAnalyticInput | SalesOrderLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: SalesOrderLineCreateManyAnalyticInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type VendorBillLineCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<VendorBillLineCreateWithoutAnalyticInput, VendorBillLineUncheckedCreateWithoutAnalyticInput> | VendorBillLineCreateWithoutAnalyticInput[] | VendorBillLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutAnalyticInput | VendorBillLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: VendorBillLineCreateManyAnalyticInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutAnalyticInput, CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput> | CustomerInvoiceLineCreateWithoutAnalyticInput[] | CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput | CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: CustomerInvoiceLineCreateManyAnalyticInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput> | AutoAnalyticRuleCreateWithoutAssignAnalyticInput[] | AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput | AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput[]
    createMany?: AutoAnalyticRuleCreateManyAssignAnalyticInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type AnalyticAccountUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AnalyticAccountCreateWithoutParentInput, AnalyticAccountUncheckedCreateWithoutParentInput> | AnalyticAccountCreateWithoutParentInput[] | AnalyticAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutParentInput | AnalyticAccountCreateOrConnectWithoutParentInput[]
    createMany?: AnalyticAccountCreateManyParentInputEnvelope
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
  }

  export type BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<BudgetLineCreateWithoutAnalyticInput, BudgetLineUncheckedCreateWithoutAnalyticInput> | BudgetLineCreateWithoutAnalyticInput[] | BudgetLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutAnalyticInput | BudgetLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: BudgetLineCreateManyAnalyticInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<JournalLineCreateWithoutAnalyticInput, JournalLineUncheckedCreateWithoutAnalyticInput> | JournalLineCreateWithoutAnalyticInput[] | JournalLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAnalyticInput | JournalLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: JournalLineCreateManyAnalyticInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutAnalyticInput, PurchaseOrderLineUncheckedCreateWithoutAnalyticInput> | PurchaseOrderLineCreateWithoutAnalyticInput[] | PurchaseOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutAnalyticInput | PurchaseOrderLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: PurchaseOrderLineCreateManyAnalyticInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<SalesOrderLineCreateWithoutAnalyticInput, SalesOrderLineUncheckedCreateWithoutAnalyticInput> | SalesOrderLineCreateWithoutAnalyticInput[] | SalesOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutAnalyticInput | SalesOrderLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: SalesOrderLineCreateManyAnalyticInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<VendorBillLineCreateWithoutAnalyticInput, VendorBillLineUncheckedCreateWithoutAnalyticInput> | VendorBillLineCreateWithoutAnalyticInput[] | VendorBillLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutAnalyticInput | VendorBillLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: VendorBillLineCreateManyAnalyticInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutAnalyticInput, CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput> | CustomerInvoiceLineCreateWithoutAnalyticInput[] | CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput | CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput[]
    createMany?: CustomerInvoiceLineCreateManyAnalyticInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput> | AutoAnalyticRuleCreateWithoutAssignAnalyticInput[] | AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput | AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput[]
    createMany?: AutoAnalyticRuleCreateManyAssignAnalyticInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput = {
    create?: XOR<CompanyCreateWithoutAnalyticAccountsInput, CompanyUncheckedCreateWithoutAnalyticAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAnalyticAccountsInput
    upsert?: CompanyUpsertWithoutAnalyticAccountsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAnalyticAccountsInput, CompanyUpdateWithoutAnalyticAccountsInput>, CompanyUncheckedUpdateWithoutAnalyticAccountsInput>
  }

  export type AnalyticAccountUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutChildrenInput, AnalyticAccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutChildrenInput
    upsert?: AnalyticAccountUpsertWithoutChildrenInput
    disconnect?: AnalyticAccountWhereInput | boolean
    delete?: AnalyticAccountWhereInput | boolean
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutChildrenInput, AnalyticAccountUpdateWithoutChildrenInput>, AnalyticAccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AnalyticAccountUpdateManyWithoutParentNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutParentInput, AnalyticAccountUncheckedCreateWithoutParentInput> | AnalyticAccountCreateWithoutParentInput[] | AnalyticAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutParentInput | AnalyticAccountCreateOrConnectWithoutParentInput[]
    upsert?: AnalyticAccountUpsertWithWhereUniqueWithoutParentInput | AnalyticAccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AnalyticAccountCreateManyParentInputEnvelope
    set?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    disconnect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    delete?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    update?: AnalyticAccountUpdateWithWhereUniqueWithoutParentInput | AnalyticAccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AnalyticAccountUpdateManyWithWhereWithoutParentInput | AnalyticAccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AnalyticAccountScalarWhereInput | AnalyticAccountScalarWhereInput[]
  }

  export type BudgetLineUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<BudgetLineCreateWithoutAnalyticInput, BudgetLineUncheckedCreateWithoutAnalyticInput> | BudgetLineCreateWithoutAnalyticInput[] | BudgetLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutAnalyticInput | BudgetLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutAnalyticInput | BudgetLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: BudgetLineCreateManyAnalyticInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutAnalyticInput | BudgetLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutAnalyticInput | BudgetLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type JournalLineUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<JournalLineCreateWithoutAnalyticInput, JournalLineUncheckedCreateWithoutAnalyticInput> | JournalLineCreateWithoutAnalyticInput[] | JournalLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAnalyticInput | JournalLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAnalyticInput | JournalLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: JournalLineCreateManyAnalyticInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAnalyticInput | JournalLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAnalyticInput | JournalLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutAnalyticInput, PurchaseOrderLineUncheckedCreateWithoutAnalyticInput> | PurchaseOrderLineCreateWithoutAnalyticInput[] | PurchaseOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutAnalyticInput | PurchaseOrderLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutAnalyticInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: PurchaseOrderLineCreateManyAnalyticInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutAnalyticInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutAnalyticInput | PurchaseOrderLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutAnalyticInput, SalesOrderLineUncheckedCreateWithoutAnalyticInput> | SalesOrderLineCreateWithoutAnalyticInput[] | SalesOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutAnalyticInput | SalesOrderLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutAnalyticInput | SalesOrderLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: SalesOrderLineCreateManyAnalyticInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutAnalyticInput | SalesOrderLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutAnalyticInput | SalesOrderLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type VendorBillLineUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutAnalyticInput, VendorBillLineUncheckedCreateWithoutAnalyticInput> | VendorBillLineCreateWithoutAnalyticInput[] | VendorBillLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutAnalyticInput | VendorBillLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutAnalyticInput | VendorBillLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: VendorBillLineCreateManyAnalyticInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutAnalyticInput | VendorBillLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutAnalyticInput | VendorBillLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutAnalyticInput, CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput> | CustomerInvoiceLineCreateWithoutAnalyticInput[] | CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput | CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutAnalyticInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: CustomerInvoiceLineCreateManyAnalyticInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutAnalyticInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutAnalyticInput | CustomerInvoiceLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput> | AutoAnalyticRuleCreateWithoutAssignAnalyticInput[] | AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput | AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutAssignAnalyticInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutAssignAnalyticInput[]
    createMany?: AutoAnalyticRuleCreateManyAssignAnalyticInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutAssignAnalyticInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutAssignAnalyticInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutAssignAnalyticInput | AutoAnalyticRuleUpdateManyWithWhereWithoutAssignAnalyticInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutParentInput, AnalyticAccountUncheckedCreateWithoutParentInput> | AnalyticAccountCreateWithoutParentInput[] | AnalyticAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutParentInput | AnalyticAccountCreateOrConnectWithoutParentInput[]
    upsert?: AnalyticAccountUpsertWithWhereUniqueWithoutParentInput | AnalyticAccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AnalyticAccountCreateManyParentInputEnvelope
    set?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    disconnect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    delete?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    connect?: AnalyticAccountWhereUniqueInput | AnalyticAccountWhereUniqueInput[]
    update?: AnalyticAccountUpdateWithWhereUniqueWithoutParentInput | AnalyticAccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AnalyticAccountUpdateManyWithWhereWithoutParentInput | AnalyticAccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AnalyticAccountScalarWhereInput | AnalyticAccountScalarWhereInput[]
  }

  export type BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<BudgetLineCreateWithoutAnalyticInput, BudgetLineUncheckedCreateWithoutAnalyticInput> | BudgetLineCreateWithoutAnalyticInput[] | BudgetLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutAnalyticInput | BudgetLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutAnalyticInput | BudgetLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: BudgetLineCreateManyAnalyticInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutAnalyticInput | BudgetLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutAnalyticInput | BudgetLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<JournalLineCreateWithoutAnalyticInput, JournalLineUncheckedCreateWithoutAnalyticInput> | JournalLineCreateWithoutAnalyticInput[] | JournalLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAnalyticInput | JournalLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAnalyticInput | JournalLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: JournalLineCreateManyAnalyticInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAnalyticInput | JournalLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAnalyticInput | JournalLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutAnalyticInput, PurchaseOrderLineUncheckedCreateWithoutAnalyticInput> | PurchaseOrderLineCreateWithoutAnalyticInput[] | PurchaseOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutAnalyticInput | PurchaseOrderLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutAnalyticInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: PurchaseOrderLineCreateManyAnalyticInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutAnalyticInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutAnalyticInput | PurchaseOrderLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutAnalyticInput, SalesOrderLineUncheckedCreateWithoutAnalyticInput> | SalesOrderLineCreateWithoutAnalyticInput[] | SalesOrderLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutAnalyticInput | SalesOrderLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutAnalyticInput | SalesOrderLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: SalesOrderLineCreateManyAnalyticInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutAnalyticInput | SalesOrderLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutAnalyticInput | SalesOrderLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutAnalyticInput, VendorBillLineUncheckedCreateWithoutAnalyticInput> | VendorBillLineCreateWithoutAnalyticInput[] | VendorBillLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutAnalyticInput | VendorBillLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutAnalyticInput | VendorBillLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: VendorBillLineCreateManyAnalyticInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutAnalyticInput | VendorBillLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutAnalyticInput | VendorBillLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutAnalyticInput, CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput> | CustomerInvoiceLineCreateWithoutAnalyticInput[] | CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput | CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutAnalyticInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutAnalyticInput[]
    createMany?: CustomerInvoiceLineCreateManyAnalyticInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutAnalyticInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutAnalyticInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutAnalyticInput | CustomerInvoiceLineUpdateManyWithWhereWithoutAnalyticInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput> | AutoAnalyticRuleCreateWithoutAssignAnalyticInput[] | AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput | AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutAssignAnalyticInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutAssignAnalyticInput[]
    createMany?: AutoAnalyticRuleCreateManyAssignAnalyticInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutAssignAnalyticInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutAssignAnalyticInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutAssignAnalyticInput | AutoAnalyticRuleUpdateManyWithWhereWithoutAssignAnalyticInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutGlAccountsInput = {
    create?: XOR<CompanyCreateWithoutGlAccountsInput, CompanyUncheckedCreateWithoutGlAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGlAccountsInput
    connect?: CompanyWhereUniqueInput
  }

  export type JournalLineCreateNestedManyWithoutGlInput = {
    create?: XOR<JournalLineCreateWithoutGlInput, JournalLineUncheckedCreateWithoutGlInput> | JournalLineCreateWithoutGlInput[] | JournalLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutGlInput | JournalLineCreateOrConnectWithoutGlInput[]
    createMany?: JournalLineCreateManyGlInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type BudgetLineCreateNestedManyWithoutGlInput = {
    create?: XOR<BudgetLineCreateWithoutGlInput, BudgetLineUncheckedCreateWithoutGlInput> | BudgetLineCreateWithoutGlInput[] | BudgetLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutGlInput | BudgetLineCreateOrConnectWithoutGlInput[]
    createMany?: BudgetLineCreateManyGlInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type VendorBillLineCreateNestedManyWithoutGlInput = {
    create?: XOR<VendorBillLineCreateWithoutGlInput, VendorBillLineUncheckedCreateWithoutGlInput> | VendorBillLineCreateWithoutGlInput[] | VendorBillLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutGlInput | VendorBillLineCreateOrConnectWithoutGlInput[]
    createMany?: VendorBillLineCreateManyGlInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type CustomerInvoiceLineCreateNestedManyWithoutGlInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutGlInput, CustomerInvoiceLineUncheckedCreateWithoutGlInput> | CustomerInvoiceLineCreateWithoutGlInput[] | CustomerInvoiceLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutGlInput | CustomerInvoiceLineCreateOrConnectWithoutGlInput[]
    createMany?: CustomerInvoiceLineCreateManyGlInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutGlInput = {
    create?: XOR<JournalLineCreateWithoutGlInput, JournalLineUncheckedCreateWithoutGlInput> | JournalLineCreateWithoutGlInput[] | JournalLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutGlInput | JournalLineCreateOrConnectWithoutGlInput[]
    createMany?: JournalLineCreateManyGlInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type BudgetLineUncheckedCreateNestedManyWithoutGlInput = {
    create?: XOR<BudgetLineCreateWithoutGlInput, BudgetLineUncheckedCreateWithoutGlInput> | BudgetLineCreateWithoutGlInput[] | BudgetLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutGlInput | BudgetLineCreateOrConnectWithoutGlInput[]
    createMany?: BudgetLineCreateManyGlInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type VendorBillLineUncheckedCreateNestedManyWithoutGlInput = {
    create?: XOR<VendorBillLineCreateWithoutGlInput, VendorBillLineUncheckedCreateWithoutGlInput> | VendorBillLineCreateWithoutGlInput[] | VendorBillLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutGlInput | VendorBillLineCreateOrConnectWithoutGlInput[]
    createMany?: VendorBillLineCreateManyGlInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type CustomerInvoiceLineUncheckedCreateNestedManyWithoutGlInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutGlInput, CustomerInvoiceLineUncheckedCreateWithoutGlInput> | CustomerInvoiceLineCreateWithoutGlInput[] | CustomerInvoiceLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutGlInput | CustomerInvoiceLineCreateOrConnectWithoutGlInput[]
    createMany?: CustomerInvoiceLineCreateManyGlInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type CompanyUpdateOneRequiredWithoutGlAccountsNestedInput = {
    create?: XOR<CompanyCreateWithoutGlAccountsInput, CompanyUncheckedCreateWithoutGlAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGlAccountsInput
    upsert?: CompanyUpsertWithoutGlAccountsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutGlAccountsInput, CompanyUpdateWithoutGlAccountsInput>, CompanyUncheckedUpdateWithoutGlAccountsInput>
  }

  export type JournalLineUpdateManyWithoutGlNestedInput = {
    create?: XOR<JournalLineCreateWithoutGlInput, JournalLineUncheckedCreateWithoutGlInput> | JournalLineCreateWithoutGlInput[] | JournalLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutGlInput | JournalLineCreateOrConnectWithoutGlInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutGlInput | JournalLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: JournalLineCreateManyGlInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutGlInput | JournalLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutGlInput | JournalLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type BudgetLineUpdateManyWithoutGlNestedInput = {
    create?: XOR<BudgetLineCreateWithoutGlInput, BudgetLineUncheckedCreateWithoutGlInput> | BudgetLineCreateWithoutGlInput[] | BudgetLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutGlInput | BudgetLineCreateOrConnectWithoutGlInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutGlInput | BudgetLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: BudgetLineCreateManyGlInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutGlInput | BudgetLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutGlInput | BudgetLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type VendorBillLineUpdateManyWithoutGlNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutGlInput, VendorBillLineUncheckedCreateWithoutGlInput> | VendorBillLineCreateWithoutGlInput[] | VendorBillLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutGlInput | VendorBillLineCreateOrConnectWithoutGlInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutGlInput | VendorBillLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: VendorBillLineCreateManyGlInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutGlInput | VendorBillLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutGlInput | VendorBillLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type CustomerInvoiceLineUpdateManyWithoutGlNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutGlInput, CustomerInvoiceLineUncheckedCreateWithoutGlInput> | CustomerInvoiceLineCreateWithoutGlInput[] | CustomerInvoiceLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutGlInput | CustomerInvoiceLineCreateOrConnectWithoutGlInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutGlInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: CustomerInvoiceLineCreateManyGlInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutGlInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutGlInput | CustomerInvoiceLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutGlNestedInput = {
    create?: XOR<JournalLineCreateWithoutGlInput, JournalLineUncheckedCreateWithoutGlInput> | JournalLineCreateWithoutGlInput[] | JournalLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutGlInput | JournalLineCreateOrConnectWithoutGlInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutGlInput | JournalLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: JournalLineCreateManyGlInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutGlInput | JournalLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutGlInput | JournalLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type BudgetLineUncheckedUpdateManyWithoutGlNestedInput = {
    create?: XOR<BudgetLineCreateWithoutGlInput, BudgetLineUncheckedCreateWithoutGlInput> | BudgetLineCreateWithoutGlInput[] | BudgetLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutGlInput | BudgetLineCreateOrConnectWithoutGlInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutGlInput | BudgetLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: BudgetLineCreateManyGlInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutGlInput | BudgetLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutGlInput | BudgetLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type VendorBillLineUncheckedUpdateManyWithoutGlNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutGlInput, VendorBillLineUncheckedCreateWithoutGlInput> | VendorBillLineCreateWithoutGlInput[] | VendorBillLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutGlInput | VendorBillLineCreateOrConnectWithoutGlInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutGlInput | VendorBillLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: VendorBillLineCreateManyGlInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutGlInput | VendorBillLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutGlInput | VendorBillLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutGlNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutGlInput, CustomerInvoiceLineUncheckedCreateWithoutGlInput> | CustomerInvoiceLineCreateWithoutGlInput[] | CustomerInvoiceLineUncheckedCreateWithoutGlInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutGlInput | CustomerInvoiceLineCreateOrConnectWithoutGlInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutGlInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutGlInput[]
    createMany?: CustomerInvoiceLineCreateManyGlInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutGlInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutGlInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutGlInput | CustomerInvoiceLineUpdateManyWithWhereWithoutGlInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJournalEntriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type JournalLineCreateNestedManyWithoutEntryInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutEntryInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type EnumJournalStatusFieldUpdateOperationsInput = {
    set?: $Enums.JournalStatus
  }

  export type EnumJournalSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.JournalSourceType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJournalEntriesInput
    upsert?: CompanyUpsertWithoutJournalEntriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutJournalEntriesInput, CompanyUpdateWithoutJournalEntriesInput>, CompanyUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type JournalLineUpdateManyWithoutEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutEntryInput | JournalLineUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutEntryInput | JournalLineUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutEntryInput | JournalLineUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutEntryInput | JournalLineUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutEntryInput | JournalLineUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutEntryInput | JournalLineUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type JournalEntryCreateNestedOneWithoutLinesInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
  }

  export type GLAccountCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<GLAccountCreateWithoutJournalLinesInput, GLAccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutJournalLinesInput
    connect?: GLAccountWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<AnalyticAccountCreateWithoutJournalLinesInput, AnalyticAccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutJournalLinesInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<ContactCreateWithoutJournalLinesInput, ContactUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutJournalLinesInput
    connect?: ContactWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<ProductCreateWithoutJournalLinesInput, ProductUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutJournalLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type JournalEntryUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    upsert?: JournalEntryUpsertWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
    update?: XOR<XOR<JournalEntryUpdateToOneWithWhereWithoutLinesInput, JournalEntryUpdateWithoutLinesInput>, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type GLAccountUpdateOneRequiredWithoutJournalLinesNestedInput = {
    create?: XOR<GLAccountCreateWithoutJournalLinesInput, GLAccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutJournalLinesInput
    upsert?: GLAccountUpsertWithoutJournalLinesInput
    connect?: GLAccountWhereUniqueInput
    update?: XOR<XOR<GLAccountUpdateToOneWithWhereWithoutJournalLinesInput, GLAccountUpdateWithoutJournalLinesInput>, GLAccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type AnalyticAccountUpdateOneWithoutJournalLinesNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutJournalLinesInput, AnalyticAccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutJournalLinesInput
    upsert?: AnalyticAccountUpsertWithoutJournalLinesInput
    disconnect?: AnalyticAccountWhereInput | boolean
    delete?: AnalyticAccountWhereInput | boolean
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutJournalLinesInput, AnalyticAccountUpdateWithoutJournalLinesInput>, AnalyticAccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type ContactUpdateOneWithoutJournalLinesNestedInput = {
    create?: XOR<ContactCreateWithoutJournalLinesInput, ContactUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutJournalLinesInput
    upsert?: ContactUpsertWithoutJournalLinesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutJournalLinesInput, ContactUpdateWithoutJournalLinesInput>, ContactUncheckedUpdateWithoutJournalLinesInput>
  }

  export type ProductUpdateOneWithoutJournalLinesNestedInput = {
    create?: XOR<ProductCreateWithoutJournalLinesInput, ProductUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutJournalLinesInput
    upsert?: ProductUpsertWithoutJournalLinesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutJournalLinesInput, ProductUpdateWithoutJournalLinesInput>, ProductUncheckedUpdateWithoutJournalLinesInput>
  }

  export type CompanyCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<CompanyCreateWithoutBudgetsInput, CompanyUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBudgetsInput
    connect?: CompanyWhereUniqueInput
  }

  export type BudgetRevisionCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetRevisionCreateWithoutBudgetInput, BudgetRevisionUncheckedCreateWithoutBudgetInput> | BudgetRevisionCreateWithoutBudgetInput[] | BudgetRevisionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetRevisionCreateOrConnectWithoutBudgetInput | BudgetRevisionCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetRevisionCreateManyBudgetInputEnvelope
    connect?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
  }

  export type BudgetRevisionUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetRevisionCreateWithoutBudgetInput, BudgetRevisionUncheckedCreateWithoutBudgetInput> | BudgetRevisionCreateWithoutBudgetInput[] | BudgetRevisionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetRevisionCreateOrConnectWithoutBudgetInput | BudgetRevisionCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetRevisionCreateManyBudgetInputEnvelope
    connect?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
  }

  export type EnumBudgetStatusFieldUpdateOperationsInput = {
    set?: $Enums.BudgetStatus
  }

  export type CompanyUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<CompanyCreateWithoutBudgetsInput, CompanyUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBudgetsInput
    upsert?: CompanyUpsertWithoutBudgetsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBudgetsInput, CompanyUpdateWithoutBudgetsInput>, CompanyUncheckedUpdateWithoutBudgetsInput>
  }

  export type BudgetRevisionUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetRevisionCreateWithoutBudgetInput, BudgetRevisionUncheckedCreateWithoutBudgetInput> | BudgetRevisionCreateWithoutBudgetInput[] | BudgetRevisionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetRevisionCreateOrConnectWithoutBudgetInput | BudgetRevisionCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetRevisionUpsertWithWhereUniqueWithoutBudgetInput | BudgetRevisionUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetRevisionCreateManyBudgetInputEnvelope
    set?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    disconnect?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    delete?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    connect?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    update?: BudgetRevisionUpdateWithWhereUniqueWithoutBudgetInput | BudgetRevisionUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetRevisionUpdateManyWithWhereWithoutBudgetInput | BudgetRevisionUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetRevisionScalarWhereInput | BudgetRevisionScalarWhereInput[]
  }

  export type BudgetRevisionUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetRevisionCreateWithoutBudgetInput, BudgetRevisionUncheckedCreateWithoutBudgetInput> | BudgetRevisionCreateWithoutBudgetInput[] | BudgetRevisionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetRevisionCreateOrConnectWithoutBudgetInput | BudgetRevisionCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetRevisionUpsertWithWhereUniqueWithoutBudgetInput | BudgetRevisionUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetRevisionCreateManyBudgetInputEnvelope
    set?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    disconnect?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    delete?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    connect?: BudgetRevisionWhereUniqueInput | BudgetRevisionWhereUniqueInput[]
    update?: BudgetRevisionUpdateWithWhereUniqueWithoutBudgetInput | BudgetRevisionUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetRevisionUpdateManyWithWhereWithoutBudgetInput | BudgetRevisionUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetRevisionScalarWhereInput | BudgetRevisionScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutRevisionsInput = {
    create?: XOR<BudgetCreateWithoutRevisionsInput, BudgetUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutRevisionsInput
    connect?: BudgetWhereUniqueInput
  }

  export type BudgetLineCreateNestedManyWithoutRevisionInput = {
    create?: XOR<BudgetLineCreateWithoutRevisionInput, BudgetLineUncheckedCreateWithoutRevisionInput> | BudgetLineCreateWithoutRevisionInput[] | BudgetLineUncheckedCreateWithoutRevisionInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutRevisionInput | BudgetLineCreateOrConnectWithoutRevisionInput[]
    createMany?: BudgetLineCreateManyRevisionInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type BudgetLineUncheckedCreateNestedManyWithoutRevisionInput = {
    create?: XOR<BudgetLineCreateWithoutRevisionInput, BudgetLineUncheckedCreateWithoutRevisionInput> | BudgetLineCreateWithoutRevisionInput[] | BudgetLineUncheckedCreateWithoutRevisionInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutRevisionInput | BudgetLineCreateOrConnectWithoutRevisionInput[]
    createMany?: BudgetLineCreateManyRevisionInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BudgetUpdateOneRequiredWithoutRevisionsNestedInput = {
    create?: XOR<BudgetCreateWithoutRevisionsInput, BudgetUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutRevisionsInput
    upsert?: BudgetUpsertWithoutRevisionsInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutRevisionsInput, BudgetUpdateWithoutRevisionsInput>, BudgetUncheckedUpdateWithoutRevisionsInput>
  }

  export type BudgetLineUpdateManyWithoutRevisionNestedInput = {
    create?: XOR<BudgetLineCreateWithoutRevisionInput, BudgetLineUncheckedCreateWithoutRevisionInput> | BudgetLineCreateWithoutRevisionInput[] | BudgetLineUncheckedCreateWithoutRevisionInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutRevisionInput | BudgetLineCreateOrConnectWithoutRevisionInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutRevisionInput | BudgetLineUpsertWithWhereUniqueWithoutRevisionInput[]
    createMany?: BudgetLineCreateManyRevisionInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutRevisionInput | BudgetLineUpdateWithWhereUniqueWithoutRevisionInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutRevisionInput | BudgetLineUpdateManyWithWhereWithoutRevisionInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type BudgetLineUncheckedUpdateManyWithoutRevisionNestedInput = {
    create?: XOR<BudgetLineCreateWithoutRevisionInput, BudgetLineUncheckedCreateWithoutRevisionInput> | BudgetLineCreateWithoutRevisionInput[] | BudgetLineUncheckedCreateWithoutRevisionInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutRevisionInput | BudgetLineCreateOrConnectWithoutRevisionInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutRevisionInput | BudgetLineUpsertWithWhereUniqueWithoutRevisionInput[]
    createMany?: BudgetLineCreateManyRevisionInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutRevisionInput | BudgetLineUpdateWithWhereUniqueWithoutRevisionInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutRevisionInput | BudgetLineUpdateManyWithWhereWithoutRevisionInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type BudgetRevisionCreateNestedOneWithoutLinesInput = {
    create?: XOR<BudgetRevisionCreateWithoutLinesInput, BudgetRevisionUncheckedCreateWithoutLinesInput>
    connectOrCreate?: BudgetRevisionCreateOrConnectWithoutLinesInput
    connect?: BudgetRevisionWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutBudgetLinesInput = {
    create?: XOR<AnalyticAccountCreateWithoutBudgetLinesInput, AnalyticAccountUncheckedCreateWithoutBudgetLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutBudgetLinesInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type GLAccountCreateNestedOneWithoutBudgetLinesInput = {
    create?: XOR<GLAccountCreateWithoutBudgetLinesInput, GLAccountUncheckedCreateWithoutBudgetLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutBudgetLinesInput
    connect?: GLAccountWhereUniqueInput
  }

  export type BudgetRevisionUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<BudgetRevisionCreateWithoutLinesInput, BudgetRevisionUncheckedCreateWithoutLinesInput>
    connectOrCreate?: BudgetRevisionCreateOrConnectWithoutLinesInput
    upsert?: BudgetRevisionUpsertWithoutLinesInput
    connect?: BudgetRevisionWhereUniqueInput
    update?: XOR<XOR<BudgetRevisionUpdateToOneWithWhereWithoutLinesInput, BudgetRevisionUpdateWithoutLinesInput>, BudgetRevisionUncheckedUpdateWithoutLinesInput>
  }

  export type AnalyticAccountUpdateOneRequiredWithoutBudgetLinesNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutBudgetLinesInput, AnalyticAccountUncheckedCreateWithoutBudgetLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutBudgetLinesInput
    upsert?: AnalyticAccountUpsertWithoutBudgetLinesInput
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutBudgetLinesInput, AnalyticAccountUpdateWithoutBudgetLinesInput>, AnalyticAccountUncheckedUpdateWithoutBudgetLinesInput>
  }

  export type GLAccountUpdateOneWithoutBudgetLinesNestedInput = {
    create?: XOR<GLAccountCreateWithoutBudgetLinesInput, GLAccountUncheckedCreateWithoutBudgetLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutBudgetLinesInput
    upsert?: GLAccountUpsertWithoutBudgetLinesInput
    disconnect?: GLAccountWhereInput | boolean
    delete?: GLAccountWhereInput | boolean
    connect?: GLAccountWhereUniqueInput
    update?: XOR<XOR<GLAccountUpdateToOneWithWhereWithoutBudgetLinesInput, GLAccountUpdateWithoutBudgetLinesInput>, GLAccountUncheckedUpdateWithoutBudgetLinesInput>
  }

  export type CompanyCreateNestedOneWithoutAutoAnalyticModelsInput = {
    create?: XOR<CompanyCreateWithoutAutoAnalyticModelsInput, CompanyUncheckedCreateWithoutAutoAnalyticModelsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAutoAnalyticModelsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AutoAnalyticRuleCreateNestedManyWithoutModelInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutModelInput, AutoAnalyticRuleUncheckedCreateWithoutModelInput> | AutoAnalyticRuleCreateWithoutModelInput[] | AutoAnalyticRuleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutModelInput | AutoAnalyticRuleCreateOrConnectWithoutModelInput[]
    createMany?: AutoAnalyticRuleCreateManyModelInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type AutoAnalyticRuleUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutModelInput, AutoAnalyticRuleUncheckedCreateWithoutModelInput> | AutoAnalyticRuleCreateWithoutModelInput[] | AutoAnalyticRuleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutModelInput | AutoAnalyticRuleCreateOrConnectWithoutModelInput[]
    createMany?: AutoAnalyticRuleCreateManyModelInputEnvelope
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutAutoAnalyticModelsNestedInput = {
    create?: XOR<CompanyCreateWithoutAutoAnalyticModelsInput, CompanyUncheckedCreateWithoutAutoAnalyticModelsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAutoAnalyticModelsInput
    upsert?: CompanyUpsertWithoutAutoAnalyticModelsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAutoAnalyticModelsInput, CompanyUpdateWithoutAutoAnalyticModelsInput>, CompanyUncheckedUpdateWithoutAutoAnalyticModelsInput>
  }

  export type AutoAnalyticRuleUpdateManyWithoutModelNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutModelInput, AutoAnalyticRuleUncheckedCreateWithoutModelInput> | AutoAnalyticRuleCreateWithoutModelInput[] | AutoAnalyticRuleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutModelInput | AutoAnalyticRuleCreateOrConnectWithoutModelInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutModelInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: AutoAnalyticRuleCreateManyModelInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutModelInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutModelInput | AutoAnalyticRuleUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<AutoAnalyticRuleCreateWithoutModelInput, AutoAnalyticRuleUncheckedCreateWithoutModelInput> | AutoAnalyticRuleCreateWithoutModelInput[] | AutoAnalyticRuleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AutoAnalyticRuleCreateOrConnectWithoutModelInput | AutoAnalyticRuleCreateOrConnectWithoutModelInput[]
    upsert?: AutoAnalyticRuleUpsertWithWhereUniqueWithoutModelInput | AutoAnalyticRuleUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: AutoAnalyticRuleCreateManyModelInputEnvelope
    set?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    disconnect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    delete?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    connect?: AutoAnalyticRuleWhereUniqueInput | AutoAnalyticRuleWhereUniqueInput[]
    update?: AutoAnalyticRuleUpdateWithWhereUniqueWithoutModelInput | AutoAnalyticRuleUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: AutoAnalyticRuleUpdateManyWithWhereWithoutModelInput | AutoAnalyticRuleUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
  }

  export type AutoAnalyticModelCreateNestedOneWithoutRulesInput = {
    create?: XOR<AutoAnalyticModelCreateWithoutRulesInput, AutoAnalyticModelUncheckedCreateWithoutRulesInput>
    connectOrCreate?: AutoAnalyticModelCreateOrConnectWithoutRulesInput
    connect?: AutoAnalyticModelWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAutoAnalyticRulesInput = {
    create?: XOR<ProductCreateWithoutAutoAnalyticRulesInput, ProductUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAutoAnalyticRulesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutAutoAnalyticRulesInput = {
    create?: XOR<ProductCategoryCreateWithoutAutoAnalyticRulesInput, ProductCategoryUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAutoAnalyticRulesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutAutoAnalyticRulesInput = {
    create?: XOR<ContactCreateWithoutAutoAnalyticRulesInput, ContactUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutAutoAnalyticRulesInput
    connect?: ContactWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutAutoAnalyticRulesInput = {
    create?: XOR<AnalyticAccountCreateWithoutAutoAnalyticRulesInput, AnalyticAccountUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutAutoAnalyticRulesInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type EnumAutoDocTypeFieldUpdateOperationsInput = {
    set?: $Enums.AutoDocType
  }

  export type AutoAnalyticModelUpdateOneRequiredWithoutRulesNestedInput = {
    create?: XOR<AutoAnalyticModelCreateWithoutRulesInput, AutoAnalyticModelUncheckedCreateWithoutRulesInput>
    connectOrCreate?: AutoAnalyticModelCreateOrConnectWithoutRulesInput
    upsert?: AutoAnalyticModelUpsertWithoutRulesInput
    connect?: AutoAnalyticModelWhereUniqueInput
    update?: XOR<XOR<AutoAnalyticModelUpdateToOneWithWhereWithoutRulesInput, AutoAnalyticModelUpdateWithoutRulesInput>, AutoAnalyticModelUncheckedUpdateWithoutRulesInput>
  }

  export type ProductUpdateOneWithoutAutoAnalyticRulesNestedInput = {
    create?: XOR<ProductCreateWithoutAutoAnalyticRulesInput, ProductUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAutoAnalyticRulesInput
    upsert?: ProductUpsertWithoutAutoAnalyticRulesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAutoAnalyticRulesInput, ProductUpdateWithoutAutoAnalyticRulesInput>, ProductUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type ProductCategoryUpdateOneWithoutAutoAnalyticRulesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutAutoAnalyticRulesInput, ProductCategoryUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAutoAnalyticRulesInput
    upsert?: ProductCategoryUpsertWithoutAutoAnalyticRulesInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutAutoAnalyticRulesInput, ProductCategoryUpdateWithoutAutoAnalyticRulesInput>, ProductCategoryUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type ContactUpdateOneWithoutAutoAnalyticRulesNestedInput = {
    create?: XOR<ContactCreateWithoutAutoAnalyticRulesInput, ContactUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutAutoAnalyticRulesInput
    upsert?: ContactUpsertWithoutAutoAnalyticRulesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutAutoAnalyticRulesInput, ContactUpdateWithoutAutoAnalyticRulesInput>, ContactUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type AnalyticAccountUpdateOneRequiredWithoutAutoAnalyticRulesNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutAutoAnalyticRulesInput, AnalyticAccountUncheckedCreateWithoutAutoAnalyticRulesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutAutoAnalyticRulesInput
    upsert?: AnalyticAccountUpsertWithoutAutoAnalyticRulesInput
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutAutoAnalyticRulesInput, AnalyticAccountUpdateWithoutAutoAnalyticRulesInput>, AnalyticAccountUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type CompanyCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutVendorPurchaseOrdersInput = {
    create?: XOR<ContactCreateWithoutVendorPurchaseOrdersInput, ContactUncheckedCreateWithoutVendorPurchaseOrdersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutVendorPurchaseOrdersInput
    connect?: ContactWhereUniqueInput
  }

  export type PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type VendorBillCreateNestedManyWithoutPoInput = {
    create?: XOR<VendorBillCreateWithoutPoInput, VendorBillUncheckedCreateWithoutPoInput> | VendorBillCreateWithoutPoInput[] | VendorBillUncheckedCreateWithoutPoInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPoInput | VendorBillCreateOrConnectWithoutPoInput[]
    createMany?: VendorBillCreateManyPoInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type VendorBillUncheckedCreateNestedManyWithoutPoInput = {
    create?: XOR<VendorBillCreateWithoutPoInput, VendorBillUncheckedCreateWithoutPoInput> | VendorBillCreateWithoutPoInput[] | VendorBillUncheckedCreateWithoutPoInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPoInput | VendorBillCreateOrConnectWithoutPoInput[]
    createMany?: VendorBillCreateManyPoInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: CompanyUpsertWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput, CompanyUpdateWithoutPurchaseOrdersInput>, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type ContactUpdateOneRequiredWithoutVendorPurchaseOrdersNestedInput = {
    create?: XOR<ContactCreateWithoutVendorPurchaseOrdersInput, ContactUncheckedCreateWithoutVendorPurchaseOrdersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutVendorPurchaseOrdersInput
    upsert?: ContactUpsertWithoutVendorPurchaseOrdersInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutVendorPurchaseOrdersInput, ContactUpdateWithoutVendorPurchaseOrdersInput>, ContactUncheckedUpdateWithoutVendorPurchaseOrdersInput>
  }

  export type PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type VendorBillUpdateManyWithoutPoNestedInput = {
    create?: XOR<VendorBillCreateWithoutPoInput, VendorBillUncheckedCreateWithoutPoInput> | VendorBillCreateWithoutPoInput[] | VendorBillUncheckedCreateWithoutPoInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPoInput | VendorBillCreateOrConnectWithoutPoInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutPoInput | VendorBillUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: VendorBillCreateManyPoInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutPoInput | VendorBillUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutPoInput | VendorBillUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type VendorBillUncheckedUpdateManyWithoutPoNestedInput = {
    create?: XOR<VendorBillCreateWithoutPoInput, VendorBillUncheckedCreateWithoutPoInput> | VendorBillCreateWithoutPoInput[] | VendorBillUncheckedCreateWithoutPoInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPoInput | VendorBillCreateOrConnectWithoutPoInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutPoInput | VendorBillUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: VendorBillCreateManyPoInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutPoInput | VendorBillUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutPoInput | VendorBillUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPoLinesInput = {
    create?: XOR<ProductCreateWithoutPoLinesInput, ProductUncheckedCreateWithoutPoLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPoLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutPoLinesInput = {
    create?: XOR<AnalyticAccountCreateWithoutPoLinesInput, AnalyticAccountUncheckedCreateWithoutPoLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutPoLinesInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    upsert?: PurchaseOrderUpsertWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutLinesInput, PurchaseOrderUpdateWithoutLinesInput>, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutPoLinesNestedInput = {
    create?: XOR<ProductCreateWithoutPoLinesInput, ProductUncheckedCreateWithoutPoLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPoLinesInput
    upsert?: ProductUpsertWithoutPoLinesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPoLinesInput, ProductUpdateWithoutPoLinesInput>, ProductUncheckedUpdateWithoutPoLinesInput>
  }

  export type AnalyticAccountUpdateOneWithoutPoLinesNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutPoLinesInput, AnalyticAccountUncheckedCreateWithoutPoLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutPoLinesInput
    upsert?: AnalyticAccountUpsertWithoutPoLinesInput
    disconnect?: AnalyticAccountWhereInput | boolean
    delete?: AnalyticAccountWhereInput | boolean
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutPoLinesInput, AnalyticAccountUpdateWithoutPoLinesInput>, AnalyticAccountUncheckedUpdateWithoutPoLinesInput>
  }

  export type CompanyCreateNestedOneWithoutSalesOrdersInput = {
    create?: XOR<CompanyCreateWithoutSalesOrdersInput, CompanyUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSalesOrdersInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutCustomerSalesOrdersInput = {
    create?: XOR<ContactCreateWithoutCustomerSalesOrdersInput, ContactUncheckedCreateWithoutCustomerSalesOrdersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCustomerSalesOrdersInput
    connect?: ContactWhereUniqueInput
  }

  export type SalesOrderLineCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type CustomerInvoiceCreateNestedManyWithoutSoInput = {
    create?: XOR<CustomerInvoiceCreateWithoutSoInput, CustomerInvoiceUncheckedCreateWithoutSoInput> | CustomerInvoiceCreateWithoutSoInput[] | CustomerInvoiceUncheckedCreateWithoutSoInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutSoInput | CustomerInvoiceCreateOrConnectWithoutSoInput[]
    createMany?: CustomerInvoiceCreateManySoInputEnvelope
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type CustomerInvoiceUncheckedCreateNestedManyWithoutSoInput = {
    create?: XOR<CustomerInvoiceCreateWithoutSoInput, CustomerInvoiceUncheckedCreateWithoutSoInput> | CustomerInvoiceCreateWithoutSoInput[] | CustomerInvoiceUncheckedCreateWithoutSoInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutSoInput | CustomerInvoiceCreateOrConnectWithoutSoInput[]
    createMany?: CustomerInvoiceCreateManySoInputEnvelope
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutSalesOrdersNestedInput = {
    create?: XOR<CompanyCreateWithoutSalesOrdersInput, CompanyUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSalesOrdersInput
    upsert?: CompanyUpsertWithoutSalesOrdersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSalesOrdersInput, CompanyUpdateWithoutSalesOrdersInput>, CompanyUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type ContactUpdateOneRequiredWithoutCustomerSalesOrdersNestedInput = {
    create?: XOR<ContactCreateWithoutCustomerSalesOrdersInput, ContactUncheckedCreateWithoutCustomerSalesOrdersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCustomerSalesOrdersInput
    upsert?: ContactUpsertWithoutCustomerSalesOrdersInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutCustomerSalesOrdersInput, ContactUpdateWithoutCustomerSalesOrdersInput>, ContactUncheckedUpdateWithoutCustomerSalesOrdersInput>
  }

  export type SalesOrderLineUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput | SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type CustomerInvoiceUpdateManyWithoutSoNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutSoInput, CustomerInvoiceUncheckedCreateWithoutSoInput> | CustomerInvoiceCreateWithoutSoInput[] | CustomerInvoiceUncheckedCreateWithoutSoInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutSoInput | CustomerInvoiceCreateOrConnectWithoutSoInput[]
    upsert?: CustomerInvoiceUpsertWithWhereUniqueWithoutSoInput | CustomerInvoiceUpsertWithWhereUniqueWithoutSoInput[]
    createMany?: CustomerInvoiceCreateManySoInputEnvelope
    set?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    disconnect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    delete?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    update?: CustomerInvoiceUpdateWithWhereUniqueWithoutSoInput | CustomerInvoiceUpdateWithWhereUniqueWithoutSoInput[]
    updateMany?: CustomerInvoiceUpdateManyWithWhereWithoutSoInput | CustomerInvoiceUpdateManyWithWhereWithoutSoInput[]
    deleteMany?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput | SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type CustomerInvoiceUncheckedUpdateManyWithoutSoNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutSoInput, CustomerInvoiceUncheckedCreateWithoutSoInput> | CustomerInvoiceCreateWithoutSoInput[] | CustomerInvoiceUncheckedCreateWithoutSoInput[]
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutSoInput | CustomerInvoiceCreateOrConnectWithoutSoInput[]
    upsert?: CustomerInvoiceUpsertWithWhereUniqueWithoutSoInput | CustomerInvoiceUpsertWithWhereUniqueWithoutSoInput[]
    createMany?: CustomerInvoiceCreateManySoInputEnvelope
    set?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    disconnect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    delete?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    connect?: CustomerInvoiceWhereUniqueInput | CustomerInvoiceWhereUniqueInput[]
    update?: CustomerInvoiceUpdateWithWhereUniqueWithoutSoInput | CustomerInvoiceUpdateWithWhereUniqueWithoutSoInput[]
    updateMany?: CustomerInvoiceUpdateManyWithWhereWithoutSoInput | CustomerInvoiceUpdateManyWithWhereWithoutSoInput[]
    deleteMany?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
  }

  export type SalesOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLinesInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSoLinesInput = {
    create?: XOR<ProductCreateWithoutSoLinesInput, ProductUncheckedCreateWithoutSoLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSoLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutSoLinesInput = {
    create?: XOR<AnalyticAccountCreateWithoutSoLinesInput, AnalyticAccountUncheckedCreateWithoutSoLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutSoLinesInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type SalesOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLinesInput
    upsert?: SalesOrderUpsertWithoutLinesInput
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutLinesInput, SalesOrderUpdateWithoutLinesInput>, SalesOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutSoLinesNestedInput = {
    create?: XOR<ProductCreateWithoutSoLinesInput, ProductUncheckedCreateWithoutSoLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSoLinesInput
    upsert?: ProductUpsertWithoutSoLinesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSoLinesInput, ProductUpdateWithoutSoLinesInput>, ProductUncheckedUpdateWithoutSoLinesInput>
  }

  export type AnalyticAccountUpdateOneWithoutSoLinesNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutSoLinesInput, AnalyticAccountUncheckedCreateWithoutSoLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutSoLinesInput
    upsert?: AnalyticAccountUpsertWithoutSoLinesInput
    disconnect?: AnalyticAccountWhereInput | boolean
    delete?: AnalyticAccountWhereInput | boolean
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutSoLinesInput, AnalyticAccountUpdateWithoutSoLinesInput>, AnalyticAccountUncheckedUpdateWithoutSoLinesInput>
  }

  export type CompanyCreateNestedOneWithoutVendorBillsInput = {
    create?: XOR<CompanyCreateWithoutVendorBillsInput, CompanyUncheckedCreateWithoutVendorBillsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorBillsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutVendorBillsInput = {
    create?: XOR<ContactCreateWithoutVendorBillsInput, ContactUncheckedCreateWithoutVendorBillsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutVendorBillsInput
    connect?: ContactWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutBillsInput = {
    create?: XOR<PurchaseOrderCreateWithoutBillsInput, PurchaseOrderUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutBillsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type VendorBillLineCreateNestedManyWithoutBillInput = {
    create?: XOR<VendorBillLineCreateWithoutBillInput, VendorBillLineUncheckedCreateWithoutBillInput> | VendorBillLineCreateWithoutBillInput[] | VendorBillLineUncheckedCreateWithoutBillInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutBillInput | VendorBillLineCreateOrConnectWithoutBillInput[]
    createMany?: VendorBillLineCreateManyBillInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type VendorBillLineUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<VendorBillLineCreateWithoutBillInput, VendorBillLineUncheckedCreateWithoutBillInput> | VendorBillLineCreateWithoutBillInput[] | VendorBillLineUncheckedCreateWithoutBillInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutBillInput | VendorBillLineCreateOrConnectWithoutBillInput[]
    createMany?: VendorBillLineCreateManyBillInputEnvelope
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
  }

  export type EnumDocStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocStatus
  }

  export type CompanyUpdateOneRequiredWithoutVendorBillsNestedInput = {
    create?: XOR<CompanyCreateWithoutVendorBillsInput, CompanyUncheckedCreateWithoutVendorBillsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorBillsInput
    upsert?: CompanyUpsertWithoutVendorBillsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVendorBillsInput, CompanyUpdateWithoutVendorBillsInput>, CompanyUncheckedUpdateWithoutVendorBillsInput>
  }

  export type ContactUpdateOneRequiredWithoutVendorBillsNestedInput = {
    create?: XOR<ContactCreateWithoutVendorBillsInput, ContactUncheckedCreateWithoutVendorBillsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutVendorBillsInput
    upsert?: ContactUpsertWithoutVendorBillsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutVendorBillsInput, ContactUpdateWithoutVendorBillsInput>, ContactUncheckedUpdateWithoutVendorBillsInput>
  }

  export type PurchaseOrderUpdateOneWithoutBillsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutBillsInput, PurchaseOrderUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutBillsInput
    upsert?: PurchaseOrderUpsertWithoutBillsInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutBillsInput, PurchaseOrderUpdateWithoutBillsInput>, PurchaseOrderUncheckedUpdateWithoutBillsInput>
  }

  export type VendorBillLineUpdateManyWithoutBillNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutBillInput, VendorBillLineUncheckedCreateWithoutBillInput> | VendorBillLineCreateWithoutBillInput[] | VendorBillLineUncheckedCreateWithoutBillInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutBillInput | VendorBillLineCreateOrConnectWithoutBillInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutBillInput | VendorBillLineUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: VendorBillLineCreateManyBillInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutBillInput | VendorBillLineUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutBillInput | VendorBillLineUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type VendorBillLineUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<VendorBillLineCreateWithoutBillInput, VendorBillLineUncheckedCreateWithoutBillInput> | VendorBillLineCreateWithoutBillInput[] | VendorBillLineUncheckedCreateWithoutBillInput[]
    connectOrCreate?: VendorBillLineCreateOrConnectWithoutBillInput | VendorBillLineCreateOrConnectWithoutBillInput[]
    upsert?: VendorBillLineUpsertWithWhereUniqueWithoutBillInput | VendorBillLineUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: VendorBillLineCreateManyBillInputEnvelope
    set?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    disconnect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    delete?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    connect?: VendorBillLineWhereUniqueInput | VendorBillLineWhereUniqueInput[]
    update?: VendorBillLineUpdateWithWhereUniqueWithoutBillInput | VendorBillLineUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: VendorBillLineUpdateManyWithWhereWithoutBillInput | VendorBillLineUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
  }

  export type VendorBillCreateNestedOneWithoutLinesInput = {
    create?: XOR<VendorBillCreateWithoutLinesInput, VendorBillUncheckedCreateWithoutLinesInput>
    connectOrCreate?: VendorBillCreateOrConnectWithoutLinesInput
    connect?: VendorBillWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutBillLinesInput = {
    create?: XOR<ProductCreateWithoutBillLinesInput, ProductUncheckedCreateWithoutBillLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBillLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutBillLinesInput = {
    create?: XOR<AnalyticAccountCreateWithoutBillLinesInput, AnalyticAccountUncheckedCreateWithoutBillLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutBillLinesInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type GLAccountCreateNestedOneWithoutBillLinesInput = {
    create?: XOR<GLAccountCreateWithoutBillLinesInput, GLAccountUncheckedCreateWithoutBillLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutBillLinesInput
    connect?: GLAccountWhereUniqueInput
  }

  export type VendorBillUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<VendorBillCreateWithoutLinesInput, VendorBillUncheckedCreateWithoutLinesInput>
    connectOrCreate?: VendorBillCreateOrConnectWithoutLinesInput
    upsert?: VendorBillUpsertWithoutLinesInput
    connect?: VendorBillWhereUniqueInput
    update?: XOR<XOR<VendorBillUpdateToOneWithWhereWithoutLinesInput, VendorBillUpdateWithoutLinesInput>, VendorBillUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneWithoutBillLinesNestedInput = {
    create?: XOR<ProductCreateWithoutBillLinesInput, ProductUncheckedCreateWithoutBillLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBillLinesInput
    upsert?: ProductUpsertWithoutBillLinesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBillLinesInput, ProductUpdateWithoutBillLinesInput>, ProductUncheckedUpdateWithoutBillLinesInput>
  }

  export type AnalyticAccountUpdateOneWithoutBillLinesNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutBillLinesInput, AnalyticAccountUncheckedCreateWithoutBillLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutBillLinesInput
    upsert?: AnalyticAccountUpsertWithoutBillLinesInput
    disconnect?: AnalyticAccountWhereInput | boolean
    delete?: AnalyticAccountWhereInput | boolean
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutBillLinesInput, AnalyticAccountUpdateWithoutBillLinesInput>, AnalyticAccountUncheckedUpdateWithoutBillLinesInput>
  }

  export type GLAccountUpdateOneWithoutBillLinesNestedInput = {
    create?: XOR<GLAccountCreateWithoutBillLinesInput, GLAccountUncheckedCreateWithoutBillLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutBillLinesInput
    upsert?: GLAccountUpsertWithoutBillLinesInput
    disconnect?: GLAccountWhereInput | boolean
    delete?: GLAccountWhereInput | boolean
    connect?: GLAccountWhereUniqueInput
    update?: XOR<XOR<GLAccountUpdateToOneWithWhereWithoutBillLinesInput, GLAccountUpdateWithoutBillLinesInput>, GLAccountUncheckedUpdateWithoutBillLinesInput>
  }

  export type CompanyCreateNestedOneWithoutCustomerInvoicesInput = {
    create?: XOR<CompanyCreateWithoutCustomerInvoicesInput, CompanyUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCustomerInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutCustomerInvoicesInput = {
    create?: XOR<ContactCreateWithoutCustomerInvoicesInput, ContactUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCustomerInvoicesInput
    connect?: ContactWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoicesInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type CustomerInvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutInvoiceInput, CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceLineCreateWithoutInvoiceInput[] | CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput | CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: CustomerInvoiceLineCreateManyInvoiceInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type CustomerInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutInvoiceInput, CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceLineCreateWithoutInvoiceInput[] | CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput | CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: CustomerInvoiceLineCreateManyInvoiceInputEnvelope
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutCustomerInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutCustomerInvoicesInput, CompanyUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCustomerInvoicesInput
    upsert?: CompanyUpsertWithoutCustomerInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCustomerInvoicesInput, CompanyUpdateWithoutCustomerInvoicesInput>, CompanyUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type ContactUpdateOneRequiredWithoutCustomerInvoicesNestedInput = {
    create?: XOR<ContactCreateWithoutCustomerInvoicesInput, ContactUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCustomerInvoicesInput
    upsert?: ContactUpsertWithoutCustomerInvoicesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutCustomerInvoicesInput, ContactUpdateWithoutCustomerInvoicesInput>, ContactUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type SalesOrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoicesInput
    upsert?: SalesOrderUpsertWithoutInvoicesInput
    disconnect?: SalesOrderWhereInput | boolean
    delete?: SalesOrderWhereInput | boolean
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutInvoicesInput, SalesOrderUpdateWithoutInvoicesInput>, SalesOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerInvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutInvoiceInput, CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceLineCreateWithoutInvoiceInput[] | CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput | CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CustomerInvoiceLineCreateManyInvoiceInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutInvoiceInput | CustomerInvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CustomerInvoiceLineCreateWithoutInvoiceInput, CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceLineCreateWithoutInvoiceInput[] | CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput | CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: CustomerInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CustomerInvoiceLineCreateManyInvoiceInputEnvelope
    set?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    disconnect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    delete?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    connect?: CustomerInvoiceLineWhereUniqueInput | CustomerInvoiceLineWhereUniqueInput[]
    update?: CustomerInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CustomerInvoiceLineUpdateManyWithWhereWithoutInvoiceInput | CustomerInvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
  }

  export type CustomerInvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<CustomerInvoiceCreateWithoutLinesInput, CustomerInvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutLinesInput
    connect?: CustomerInvoiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInvLinesInput = {
    create?: XOR<ProductCreateWithoutInvLinesInput, ProductUncheckedCreateWithoutInvLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type AnalyticAccountCreateNestedOneWithoutInvLinesInput = {
    create?: XOR<AnalyticAccountCreateWithoutInvLinesInput, AnalyticAccountUncheckedCreateWithoutInvLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutInvLinesInput
    connect?: AnalyticAccountWhereUniqueInput
  }

  export type GLAccountCreateNestedOneWithoutInvLinesInput = {
    create?: XOR<GLAccountCreateWithoutInvLinesInput, GLAccountUncheckedCreateWithoutInvLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutInvLinesInput
    connect?: GLAccountWhereUniqueInput
  }

  export type CustomerInvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutLinesInput, CustomerInvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutLinesInput
    upsert?: CustomerInvoiceUpsertWithoutLinesInput
    connect?: CustomerInvoiceWhereUniqueInput
    update?: XOR<XOR<CustomerInvoiceUpdateToOneWithWhereWithoutLinesInput, CustomerInvoiceUpdateWithoutLinesInput>, CustomerInvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneWithoutInvLinesNestedInput = {
    create?: XOR<ProductCreateWithoutInvLinesInput, ProductUncheckedCreateWithoutInvLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvLinesInput
    upsert?: ProductUpsertWithoutInvLinesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInvLinesInput, ProductUpdateWithoutInvLinesInput>, ProductUncheckedUpdateWithoutInvLinesInput>
  }

  export type AnalyticAccountUpdateOneWithoutInvLinesNestedInput = {
    create?: XOR<AnalyticAccountCreateWithoutInvLinesInput, AnalyticAccountUncheckedCreateWithoutInvLinesInput>
    connectOrCreate?: AnalyticAccountCreateOrConnectWithoutInvLinesInput
    upsert?: AnalyticAccountUpsertWithoutInvLinesInput
    disconnect?: AnalyticAccountWhereInput | boolean
    delete?: AnalyticAccountWhereInput | boolean
    connect?: AnalyticAccountWhereUniqueInput
    update?: XOR<XOR<AnalyticAccountUpdateToOneWithWhereWithoutInvLinesInput, AnalyticAccountUpdateWithoutInvLinesInput>, AnalyticAccountUncheckedUpdateWithoutInvLinesInput>
  }

  export type GLAccountUpdateOneWithoutInvLinesNestedInput = {
    create?: XOR<GLAccountCreateWithoutInvLinesInput, GLAccountUncheckedCreateWithoutInvLinesInput>
    connectOrCreate?: GLAccountCreateOrConnectWithoutInvLinesInput
    upsert?: GLAccountUpsertWithoutInvLinesInput
    disconnect?: GLAccountWhereInput | boolean
    delete?: GLAccountWhereInput | boolean
    connect?: GLAccountWhereUniqueInput
    update?: XOR<XOR<GLAccountUpdateToOneWithWhereWithoutInvLinesInput, GLAccountUpdateWithoutInvLinesInput>, GLAccountUncheckedUpdateWithoutInvLinesInput>
  }

  export type CompanyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ContactCreateWithoutPaymentsInput, ContactUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPaymentsInput
    connect?: ContactWhereUniqueInput
  }

  export type PaymentAllocationCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
  }

  export type PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
  }

  export type EnumPaymentDirectionFieldUpdateOperationsInput = {
    set?: $Enums.PaymentDirection
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type CompanyUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentsInput
    upsert?: CompanyUpsertWithoutPaymentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPaymentsInput, CompanyUpdateWithoutPaymentsInput>, CompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type ContactUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ContactCreateWithoutPaymentsInput, ContactUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPaymentsInput
    upsert?: ContactUpsertWithoutPaymentsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPaymentsInput, ContactUpdateWithoutPaymentsInput>, ContactUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentAllocationUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    set?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    disconnect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    delete?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    update?: PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentAllocationUpdateManyWithWhereWithoutPaymentInput | PaymentAllocationUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
  }

  export type PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    set?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    disconnect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    delete?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    update?: PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentAllocationUpdateManyWithWhereWithoutPaymentInput | PaymentAllocationUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutAllocationsInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumAllocationTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.AllocationTargetType
  }

  export type PaymentUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutAllocationsInput
    upsert?: PaymentUpsertWithoutAllocationsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutAllocationsInput, PaymentUpdateWithoutAllocationsInput>, PaymentUncheckedUpdateWithoutAllocationsInput>
  }

  export type CompanyCreateNestedOneWithoutDocumentFilesInput = {
    create?: XOR<CompanyCreateWithoutDocumentFilesInput, CompanyUncheckedCreateWithoutDocumentFilesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentFilesInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumDocOwnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocOwnerType
  }

  export type CompanyUpdateOneRequiredWithoutDocumentFilesNestedInput = {
    create?: XOR<CompanyCreateWithoutDocumentFilesInput, CompanyUncheckedCreateWithoutDocumentFilesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentFilesInput
    upsert?: CompanyUpsertWithoutDocumentFilesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDocumentFilesInput, CompanyUpdateWithoutDocumentFilesInput>, CompanyUncheckedUpdateWithoutDocumentFilesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumJournalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusFilter<$PrismaModel> | $Enums.JournalStatus
  }

  export type NestedEnumJournalSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalSourceType | EnumJournalSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalSourceTypeFilter<$PrismaModel> | $Enums.JournalSourceType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumJournalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusWithAggregatesFilter<$PrismaModel> | $Enums.JournalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalStatusFilter<$PrismaModel>
    _max?: NestedEnumJournalStatusFilter<$PrismaModel>
  }

  export type NestedEnumJournalSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalSourceType | EnumJournalSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalSourceType[] | ListEnumJournalSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.JournalSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumJournalSourceTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBudgetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusFilter<$PrismaModel> | $Enums.BudgetStatus
  }

  export type NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel> | $Enums.BudgetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetStatusFilter<$PrismaModel>
    _max?: NestedEnumBudgetStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAutoDocTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoDocType | EnumAutoDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoDocTypeFilter<$PrismaModel> | $Enums.AutoDocType
  }

  export type NestedEnumAutoDocTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoDocType | EnumAutoDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoDocType[] | ListEnumAutoDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoDocTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutoDocType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutoDocTypeFilter<$PrismaModel>
    _max?: NestedEnumAutoDocTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusFilter<$PrismaModel> | $Enums.DocStatus
  }

  export type NestedEnumDocStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocStatusFilter<$PrismaModel>
    _max?: NestedEnumDocStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentDirection | EnumPaymentDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentDirectionFilter<$PrismaModel> | $Enums.PaymentDirection
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentDirection | EnumPaymentDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentDirection[] | ListEnumPaymentDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentDirectionWithAggregatesFilter<$PrismaModel> | $Enums.PaymentDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentDirectionFilter<$PrismaModel>
    _max?: NestedEnumPaymentDirectionFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAllocationTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationTargetType | EnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationTargetTypeFilter<$PrismaModel> | $Enums.AllocationTargetType
  }

  export type NestedEnumAllocationTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationTargetType | EnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationTargetType[] | ListEnumAllocationTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AllocationTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllocationTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumAllocationTargetTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocOwnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocOwnerType | EnumDocOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocOwnerTypeFilter<$PrismaModel> | $Enums.DocOwnerType
  }

  export type NestedEnumDocOwnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocOwnerType | EnumDocOwnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocOwnerType[] | ListEnumDocOwnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocOwnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocOwnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocOwnerTypeFilter<$PrismaModel>
    _max?: NestedEnumDocOwnerTypeFilter<$PrismaModel>
  }

  export type ContactCreateWithoutCompanyInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCompanyInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactCreateManyCompanyInputEnvelope = {
    data: ContactCreateManyCompanyInput | ContactCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutCompanyInput = {
    id?: string
    name: string
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    parentId?: string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutCompanyInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ProductCategoryCreateManyCompanyInputEnvelope = {
    data: ProductCategoryCreateManyCompanyInput | ProductCategoryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCompanyInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCompanyInput = {
    id?: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput>
  }

  export type ProductCreateManyCompanyInputEnvelope = {
    data: ProductCreateManyCompanyInput | ProductCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticAccountCreateWithoutCompanyInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutCompanyInput = {
    id?: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutCompanyInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutCompanyInput, AnalyticAccountUncheckedCreateWithoutCompanyInput>
  }

  export type AnalyticAccountCreateManyCompanyInputEnvelope = {
    data: AnalyticAccountCreateManyCompanyInput | AnalyticAccountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type GLAccountCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    journalLines?: JournalLineCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutGlInput
  }

  export type GLAccountUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutGlInput
  }

  export type GLAccountCreateOrConnectWithoutCompanyInput = {
    where: GLAccountWhereUniqueInput
    create: XOR<GLAccountCreateWithoutCompanyInput, GLAccountUncheckedCreateWithoutCompanyInput>
  }

  export type GLAccountCreateManyCompanyInputEnvelope = {
    data: GLAccountCreateManyCompanyInput | GLAccountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JournalEntryCreateWithoutCompanyInput = {
    id?: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
    lines?: JournalLineCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutCompanyInput = {
    id?: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
    lines?: JournalLineUncheckedCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput>
  }

  export type JournalEntryCreateManyCompanyInputEnvelope = {
    data: JournalEntryCreateManyCompanyInput | JournalEntryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCreateWithoutCompanyInput = {
    id?: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    revisions?: BudgetRevisionCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    revisions?: BudgetRevisionUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutCompanyInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutCompanyInput, BudgetUncheckedCreateWithoutCompanyInput>
  }

  export type BudgetCreateManyCompanyInputEnvelope = {
    data: BudgetCreateManyCompanyInput | BudgetCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AutoAnalyticModelCreateWithoutCompanyInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    rules?: AutoAnalyticRuleCreateNestedManyWithoutModelInput
  }

  export type AutoAnalyticModelUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    rules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutModelInput
  }

  export type AutoAnalyticModelCreateOrConnectWithoutCompanyInput = {
    where: AutoAnalyticModelWhereUniqueInput
    create: XOR<AutoAnalyticModelCreateWithoutCompanyInput, AutoAnalyticModelUncheckedCreateWithoutCompanyInput>
  }

  export type AutoAnalyticModelCreateManyCompanyInputEnvelope = {
    data: AutoAnalyticModelCreateManyCompanyInput | AutoAnalyticModelCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutCompanyInput = {
    id?: string
    poNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    vendor: ContactCreateNestedOneWithoutVendorPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    bills?: VendorBillCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCompanyInput = {
    id?: string
    poNo: string
    vendorId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
    bills?: VendorBillUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderCreateManyCompanyInputEnvelope = {
    data: PurchaseOrderCreateManyCompanyInput | PurchaseOrderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderCreateWithoutCompanyInput = {
    id?: string
    soNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    customer: ContactCreateNestedOneWithoutCustomerSalesOrdersInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    invoices?: CustomerInvoiceCreateNestedManyWithoutSoInput
  }

  export type SalesOrderUncheckedCreateWithoutCompanyInput = {
    id?: string
    soNo: string
    customerId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
    invoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutSoInput
  }

  export type SalesOrderCreateOrConnectWithoutCompanyInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutCompanyInput, SalesOrderUncheckedCreateWithoutCompanyInput>
  }

  export type SalesOrderCreateManyCompanyInputEnvelope = {
    data: SalesOrderCreateManyCompanyInput | SalesOrderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillCreateWithoutCompanyInput = {
    id?: string
    billNo: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    vendor: ContactCreateNestedOneWithoutVendorBillsInput
    po?: PurchaseOrderCreateNestedOneWithoutBillsInput
    lines?: VendorBillLineCreateNestedManyWithoutBillInput
  }

  export type VendorBillUncheckedCreateWithoutCompanyInput = {
    id?: string
    billNo: string
    vendorId: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    poId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    lines?: VendorBillLineUncheckedCreateNestedManyWithoutBillInput
  }

  export type VendorBillCreateOrConnectWithoutCompanyInput = {
    where: VendorBillWhereUniqueInput
    create: XOR<VendorBillCreateWithoutCompanyInput, VendorBillUncheckedCreateWithoutCompanyInput>
  }

  export type VendorBillCreateManyCompanyInputEnvelope = {
    data: VendorBillCreateManyCompanyInput | VendorBillCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CustomerInvoiceCreateWithoutCompanyInput = {
    id?: string
    invoiceNo: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    customer: ContactCreateNestedOneWithoutCustomerInvoicesInput
    so?: SalesOrderCreateNestedOneWithoutInvoicesInput
    lines?: CustomerInvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceUncheckedCreateWithoutCompanyInput = {
    id?: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    soId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    lines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceCreateOrConnectWithoutCompanyInput = {
    where: CustomerInvoiceWhereUniqueInput
    create: XOR<CustomerInvoiceCreateWithoutCompanyInput, CustomerInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type CustomerInvoiceCreateManyCompanyInputEnvelope = {
    data: CustomerInvoiceCreateManyCompanyInput | CustomerInvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCompanyInput = {
    id?: string
    direction: $Enums.PaymentDirection
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    contact: ContactCreateNestedOneWithoutPaymentsInput
    allocations?: PaymentAllocationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCompanyInput = {
    id?: string
    direction: $Enums.PaymentDirection
    contactId: string
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    allocations?: PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentCreateManyCompanyInputEnvelope = {
    data: PaymentCreateManyCompanyInput | PaymentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentFileCreateWithoutCompanyInput = {
    id?: string
    ownerType: $Enums.DocOwnerType
    ownerId: string
    fileName: string
    mimeType: string
    storageUrl: string
    createdAt?: Date | string
  }

  export type DocumentFileUncheckedCreateWithoutCompanyInput = {
    id?: string
    ownerType: $Enums.DocOwnerType
    ownerId: string
    fileName: string
    mimeType: string
    storageUrl: string
    createdAt?: Date | string
  }

  export type DocumentFileCreateOrConnectWithoutCompanyInput = {
    where: DocumentFileWhereUniqueInput
    create: XOR<DocumentFileCreateWithoutCompanyInput, DocumentFileUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentFileCreateManyCompanyInputEnvelope = {
    data: DocumentFileCreateManyCompanyInput | DocumentFileCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: UuidFilter<"Contact"> | string
    companyId?: UuidFilter<"Contact"> | string
    contactType?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    displayName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    gstin?: StringNullableFilter<"Contact"> | string | null
    billingAddress?: JsonNullableFilter<"Contact">
    shippingAddress?: JsonNullableFilter<"Contact">
    isPortalUser?: BoolFilter<"Contact"> | boolean
    portalUserExternalId?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutCompanyInput, ProductCategoryUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProductCategoryCreateWithoutCompanyInput, ProductCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutCompanyInput, ProductCategoryUncheckedUpdateWithoutCompanyInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutCompanyInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: UuidFilter<"ProductCategory"> | string
    companyId?: UuidFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    parentId?: UuidNullableFilter<"ProductCategory"> | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCompanyInput, ProductUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProductCreateWithoutCompanyInput, ProductUncheckedCreateWithoutCompanyInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCompanyInput, ProductUncheckedUpdateWithoutCompanyInput>
  }

  export type ProductUpdateManyWithWhereWithoutCompanyInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: UuidFilter<"Product"> | string
    companyId?: UuidFilter<"Product"> | string
    sku?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    categoryId?: UuidNullableFilter<"Product"> | string | null
    uom?: StringFilter<"Product"> | string
    salePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type AnalyticAccountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AnalyticAccountWhereUniqueInput
    update: XOR<AnalyticAccountUpdateWithoutCompanyInput, AnalyticAccountUncheckedUpdateWithoutCompanyInput>
    create: XOR<AnalyticAccountCreateWithoutCompanyInput, AnalyticAccountUncheckedCreateWithoutCompanyInput>
  }

  export type AnalyticAccountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AnalyticAccountWhereUniqueInput
    data: XOR<AnalyticAccountUpdateWithoutCompanyInput, AnalyticAccountUncheckedUpdateWithoutCompanyInput>
  }

  export type AnalyticAccountUpdateManyWithWhereWithoutCompanyInput = {
    where: AnalyticAccountScalarWhereInput
    data: XOR<AnalyticAccountUpdateManyMutationInput, AnalyticAccountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AnalyticAccountScalarWhereInput = {
    AND?: AnalyticAccountScalarWhereInput | AnalyticAccountScalarWhereInput[]
    OR?: AnalyticAccountScalarWhereInput[]
    NOT?: AnalyticAccountScalarWhereInput | AnalyticAccountScalarWhereInput[]
    id?: UuidFilter<"AnalyticAccount"> | string
    companyId?: UuidFilter<"AnalyticAccount"> | string
    code?: StringNullableFilter<"AnalyticAccount"> | string | null
    name?: StringFilter<"AnalyticAccount"> | string
    parentId?: UuidNullableFilter<"AnalyticAccount"> | string | null
    isActive?: BoolFilter<"AnalyticAccount"> | boolean
    createdAt?: DateTimeFilter<"AnalyticAccount"> | Date | string
  }

  export type GLAccountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: GLAccountWhereUniqueInput
    update: XOR<GLAccountUpdateWithoutCompanyInput, GLAccountUncheckedUpdateWithoutCompanyInput>
    create: XOR<GLAccountCreateWithoutCompanyInput, GLAccountUncheckedCreateWithoutCompanyInput>
  }

  export type GLAccountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: GLAccountWhereUniqueInput
    data: XOR<GLAccountUpdateWithoutCompanyInput, GLAccountUncheckedUpdateWithoutCompanyInput>
  }

  export type GLAccountUpdateManyWithWhereWithoutCompanyInput = {
    where: GLAccountScalarWhereInput
    data: XOR<GLAccountUpdateManyMutationInput, GLAccountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type GLAccountScalarWhereInput = {
    AND?: GLAccountScalarWhereInput | GLAccountScalarWhereInput[]
    OR?: GLAccountScalarWhereInput[]
    NOT?: GLAccountScalarWhereInput | GLAccountScalarWhereInput[]
    id?: UuidFilter<"GLAccount"> | string
    companyId?: UuidFilter<"GLAccount"> | string
    code?: StringFilter<"GLAccount"> | string
    name?: StringFilter<"GLAccount"> | string
    accountType?: EnumAccountTypeFilter<"GLAccount"> | $Enums.AccountType
    isActive?: BoolFilter<"GLAccount"> | boolean
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutCompanyInput, JournalEntryUncheckedUpdateWithoutCompanyInput>
    create: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutCompanyInput, JournalEntryUncheckedUpdateWithoutCompanyInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutCompanyInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    OR?: JournalEntryScalarWhereInput[]
    NOT?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    id?: UuidFilter<"JournalEntry"> | string
    companyId?: UuidFilter<"JournalEntry"> | string
    entryDate?: DateTimeFilter<"JournalEntry"> | Date | string
    status?: EnumJournalStatusFilter<"JournalEntry"> | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFilter<"JournalEntry"> | $Enums.JournalSourceType
    sourceId?: UuidNullableFilter<"JournalEntry"> | string | null
    memo?: StringNullableFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    postedAt?: DateTimeNullableFilter<"JournalEntry"> | Date | string | null
  }

  export type BudgetUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutCompanyInput, BudgetUncheckedUpdateWithoutCompanyInput>
    create: XOR<BudgetCreateWithoutCompanyInput, BudgetUncheckedCreateWithoutCompanyInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutCompanyInput, BudgetUncheckedUpdateWithoutCompanyInput>
  }

  export type BudgetUpdateManyWithWhereWithoutCompanyInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: UuidFilter<"Budget"> | string
    companyId?: UuidFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    periodStart?: DateTimeFilter<"Budget"> | Date | string
    periodEnd?: DateTimeFilter<"Budget"> | Date | string
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    createdBy?: UuidNullableFilter<"Budget"> | string | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Budget"> | Date | string | null
  }

  export type AutoAnalyticModelUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AutoAnalyticModelWhereUniqueInput
    update: XOR<AutoAnalyticModelUpdateWithoutCompanyInput, AutoAnalyticModelUncheckedUpdateWithoutCompanyInput>
    create: XOR<AutoAnalyticModelCreateWithoutCompanyInput, AutoAnalyticModelUncheckedCreateWithoutCompanyInput>
  }

  export type AutoAnalyticModelUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AutoAnalyticModelWhereUniqueInput
    data: XOR<AutoAnalyticModelUpdateWithoutCompanyInput, AutoAnalyticModelUncheckedUpdateWithoutCompanyInput>
  }

  export type AutoAnalyticModelUpdateManyWithWhereWithoutCompanyInput = {
    where: AutoAnalyticModelScalarWhereInput
    data: XOR<AutoAnalyticModelUpdateManyMutationInput, AutoAnalyticModelUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AutoAnalyticModelScalarWhereInput = {
    AND?: AutoAnalyticModelScalarWhereInput | AutoAnalyticModelScalarWhereInput[]
    OR?: AutoAnalyticModelScalarWhereInput[]
    NOT?: AutoAnalyticModelScalarWhereInput | AutoAnalyticModelScalarWhereInput[]
    id?: UuidFilter<"AutoAnalyticModel"> | string
    companyId?: UuidFilter<"AutoAnalyticModel"> | string
    name?: StringFilter<"AutoAnalyticModel"> | string
    priority?: IntFilter<"AutoAnalyticModel"> | number
    isActive?: BoolFilter<"AutoAnalyticModel"> | boolean
    createdAt?: DateTimeFilter<"AutoAnalyticModel"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCompanyInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: UuidFilter<"PurchaseOrder"> | string
    companyId?: UuidFilter<"PurchaseOrder"> | string
    poNo?: StringFilter<"PurchaseOrder"> | string
    vendorId?: UuidFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: EnumOrderStatusFilter<"PurchaseOrder"> | $Enums.OrderStatus
    currency?: StringFilter<"PurchaseOrder"> | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutCompanyInput, SalesOrderUncheckedUpdateWithoutCompanyInput>
    create: XOR<SalesOrderCreateWithoutCompanyInput, SalesOrderUncheckedCreateWithoutCompanyInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutCompanyInput, SalesOrderUncheckedUpdateWithoutCompanyInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutCompanyInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SalesOrderScalarWhereInput = {
    AND?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    OR?: SalesOrderScalarWhereInput[]
    NOT?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    id?: UuidFilter<"SalesOrder"> | string
    companyId?: UuidFilter<"SalesOrder"> | string
    soNo?: StringFilter<"SalesOrder"> | string
    customerId?: UuidFilter<"SalesOrder"> | string
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    status?: EnumOrderStatusFilter<"SalesOrder"> | $Enums.OrderStatus
    currency?: StringFilter<"SalesOrder"> | string
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
  }

  export type VendorBillUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VendorBillWhereUniqueInput
    update: XOR<VendorBillUpdateWithoutCompanyInput, VendorBillUncheckedUpdateWithoutCompanyInput>
    create: XOR<VendorBillCreateWithoutCompanyInput, VendorBillUncheckedCreateWithoutCompanyInput>
  }

  export type VendorBillUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VendorBillWhereUniqueInput
    data: XOR<VendorBillUpdateWithoutCompanyInput, VendorBillUncheckedUpdateWithoutCompanyInput>
  }

  export type VendorBillUpdateManyWithWhereWithoutCompanyInput = {
    where: VendorBillScalarWhereInput
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VendorBillScalarWhereInput = {
    AND?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
    OR?: VendorBillScalarWhereInput[]
    NOT?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
    id?: UuidFilter<"VendorBill"> | string
    companyId?: UuidFilter<"VendorBill"> | string
    billNo?: StringFilter<"VendorBill"> | string
    vendorId?: UuidFilter<"VendorBill"> | string
    billDate?: DateTimeFilter<"VendorBill"> | Date | string
    dueDate?: DateTimeNullableFilter<"VendorBill"> | Date | string | null
    status?: EnumDocStatusFilter<"VendorBill"> | $Enums.DocStatus
    currency?: StringFilter<"VendorBill"> | string
    poId?: UuidNullableFilter<"VendorBill"> | string | null
    totalAmount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringFilter<"VendorBill"> | string
    createdAt?: DateTimeFilter<"VendorBill"> | Date | string
  }

  export type CustomerInvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CustomerInvoiceWhereUniqueInput
    update: XOR<CustomerInvoiceUpdateWithoutCompanyInput, CustomerInvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<CustomerInvoiceCreateWithoutCompanyInput, CustomerInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type CustomerInvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CustomerInvoiceWhereUniqueInput
    data: XOR<CustomerInvoiceUpdateWithoutCompanyInput, CustomerInvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type CustomerInvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: CustomerInvoiceScalarWhereInput
    data: XOR<CustomerInvoiceUpdateManyMutationInput, CustomerInvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CustomerInvoiceScalarWhereInput = {
    AND?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
    OR?: CustomerInvoiceScalarWhereInput[]
    NOT?: CustomerInvoiceScalarWhereInput | CustomerInvoiceScalarWhereInput[]
    id?: UuidFilter<"CustomerInvoice"> | string
    companyId?: UuidFilter<"CustomerInvoice"> | string
    invoiceNo?: StringFilter<"CustomerInvoice"> | string
    customerId?: UuidFilter<"CustomerInvoice"> | string
    invoiceDate?: DateTimeFilter<"CustomerInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"CustomerInvoice"> | Date | string | null
    status?: EnumDocStatusFilter<"CustomerInvoice"> | $Enums.DocStatus
    currency?: StringFilter<"CustomerInvoice"> | string
    soId?: UuidNullableFilter<"CustomerInvoice"> | string | null
    totalAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    paymentState?: StringFilter<"CustomerInvoice"> | string
    portalVisible?: BoolFilter<"CustomerInvoice"> | boolean
    createdAt?: DateTimeFilter<"CustomerInvoice"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCompanyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    companyId?: UuidFilter<"Payment"> | string
    direction?: EnumPaymentDirectionFilter<"Payment"> | $Enums.PaymentDirection
    contactId?: UuidFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type DocumentFileUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DocumentFileWhereUniqueInput
    update: XOR<DocumentFileUpdateWithoutCompanyInput, DocumentFileUncheckedUpdateWithoutCompanyInput>
    create: XOR<DocumentFileCreateWithoutCompanyInput, DocumentFileUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentFileUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DocumentFileWhereUniqueInput
    data: XOR<DocumentFileUpdateWithoutCompanyInput, DocumentFileUncheckedUpdateWithoutCompanyInput>
  }

  export type DocumentFileUpdateManyWithWhereWithoutCompanyInput = {
    where: DocumentFileScalarWhereInput
    data: XOR<DocumentFileUpdateManyMutationInput, DocumentFileUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DocumentFileScalarWhereInput = {
    AND?: DocumentFileScalarWhereInput | DocumentFileScalarWhereInput[]
    OR?: DocumentFileScalarWhereInput[]
    NOT?: DocumentFileScalarWhereInput | DocumentFileScalarWhereInput[]
    id?: UuidFilter<"DocumentFile"> | string
    companyId?: UuidFilter<"DocumentFile"> | string
    ownerType?: EnumDocOwnerTypeFilter<"DocumentFile"> | $Enums.DocOwnerType
    ownerId?: UuidFilter<"DocumentFile"> | string
    fileName?: StringFilter<"DocumentFile"> | string
    mimeType?: StringFilter<"DocumentFile"> | string
    storageUrl?: StringFilter<"DocumentFile"> | string
    createdAt?: DateTimeFilter<"DocumentFile"> | Date | string
  }

  export type CompanyCreateWithoutContactsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutContactsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
  }

  export type PurchaseOrderCreateWithoutVendorInput = {
    id?: string
    poNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    bills?: VendorBillCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutVendorInput = {
    id?: string
    companyId: string
    poNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
    bills?: VendorBillUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderCreateManyVendorInputEnvelope = {
    data: PurchaseOrderCreateManyVendorInput | PurchaseOrderCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderCreateWithoutCustomerInput = {
    id?: string
    soNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutSalesOrdersInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    invoices?: CustomerInvoiceCreateNestedManyWithoutSoInput
  }

  export type SalesOrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    companyId: string
    soNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
    invoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutSoInput
  }

  export type SalesOrderCreateOrConnectWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderCreateManyCustomerInputEnvelope = {
    data: SalesOrderCreateManyCustomerInput | SalesOrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillCreateWithoutVendorInput = {
    id?: string
    billNo: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutVendorBillsInput
    po?: PurchaseOrderCreateNestedOneWithoutBillsInput
    lines?: VendorBillLineCreateNestedManyWithoutBillInput
  }

  export type VendorBillUncheckedCreateWithoutVendorInput = {
    id?: string
    companyId: string
    billNo: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    poId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    lines?: VendorBillLineUncheckedCreateNestedManyWithoutBillInput
  }

  export type VendorBillCreateOrConnectWithoutVendorInput = {
    where: VendorBillWhereUniqueInput
    create: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput>
  }

  export type VendorBillCreateManyVendorInputEnvelope = {
    data: VendorBillCreateManyVendorInput | VendorBillCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type CustomerInvoiceCreateWithoutCustomerInput = {
    id?: string
    invoiceNo: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCustomerInvoicesInput
    so?: SalesOrderCreateNestedOneWithoutInvoicesInput
    lines?: CustomerInvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    companyId: string
    invoiceNo: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    soId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    lines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceCreateOrConnectWithoutCustomerInput = {
    where: CustomerInvoiceWhereUniqueInput
    create: XOR<CustomerInvoiceCreateWithoutCustomerInput, CustomerInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerInvoiceCreateManyCustomerInputEnvelope = {
    data: CustomerInvoiceCreateManyCustomerInput | CustomerInvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutContactInput = {
    id?: string
    direction: $Enums.PaymentDirection
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPaymentsInput
    allocations?: PaymentAllocationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutContactInput = {
    id?: string
    companyId: string
    direction: $Enums.PaymentDirection
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    allocations?: PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutContactInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutContactInput, PaymentUncheckedCreateWithoutContactInput>
  }

  export type PaymentCreateManyContactInputEnvelope = {
    data: PaymentCreateManyContactInput | PaymentCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type JournalLineCreateWithoutContactInput = {
    id?: string
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    entry: JournalEntryCreateNestedOneWithoutLinesInput
    gl: GLAccountCreateNestedOneWithoutJournalLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutJournalLinesInput
    product?: ProductCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutContactInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    analyticAccountId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateOrConnectWithoutContactInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutContactInput, JournalLineUncheckedCreateWithoutContactInput>
  }

  export type JournalLineCreateManyContactInputEnvelope = {
    data: JournalLineCreateManyContactInput | JournalLineCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type AutoAnalyticRuleCreateWithoutContactInput = {
    id?: string
    docType: $Enums.AutoDocType
    rulePriority?: number
    isActive?: boolean
    model: AutoAnalyticModelCreateNestedOneWithoutRulesInput
    product?: ProductCreateNestedOneWithoutAutoAnalyticRulesInput
    category?: ProductCategoryCreateNestedOneWithoutAutoAnalyticRulesInput
    assignAnalytic: AnalyticAccountCreateNestedOneWithoutAutoAnalyticRulesInput
  }

  export type AutoAnalyticRuleUncheckedCreateWithoutContactInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleCreateOrConnectWithoutContactInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    create: XOR<AutoAnalyticRuleCreateWithoutContactInput, AutoAnalyticRuleUncheckedCreateWithoutContactInput>
  }

  export type AutoAnalyticRuleCreateManyContactInputEnvelope = {
    data: AutoAnalyticRuleCreateManyContactInput | AutoAnalyticRuleCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutContactsInput = {
    update: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutContactsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type CompanyUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutVendorInput>
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type VendorBillUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorBillWhereUniqueInput
    update: XOR<VendorBillUpdateWithoutVendorInput, VendorBillUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput>
  }

  export type VendorBillUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorBillWhereUniqueInput
    data: XOR<VendorBillUpdateWithoutVendorInput, VendorBillUncheckedUpdateWithoutVendorInput>
  }

  export type VendorBillUpdateManyWithWhereWithoutVendorInput = {
    where: VendorBillScalarWhereInput
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyWithoutVendorInput>
  }

  export type CustomerInvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerInvoiceWhereUniqueInput
    update: XOR<CustomerInvoiceUpdateWithoutCustomerInput, CustomerInvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerInvoiceCreateWithoutCustomerInput, CustomerInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerInvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerInvoiceWhereUniqueInput
    data: XOR<CustomerInvoiceUpdateWithoutCustomerInput, CustomerInvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerInvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerInvoiceScalarWhereInput
    data: XOR<CustomerInvoiceUpdateManyMutationInput, CustomerInvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutContactInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutContactInput, PaymentUncheckedUpdateWithoutContactInput>
    create: XOR<PaymentCreateWithoutContactInput, PaymentUncheckedCreateWithoutContactInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutContactInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutContactInput, PaymentUncheckedUpdateWithoutContactInput>
  }

  export type PaymentUpdateManyWithWhereWithoutContactInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutContactInput>
  }

  export type JournalLineUpsertWithWhereUniqueWithoutContactInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutContactInput, JournalLineUncheckedUpdateWithoutContactInput>
    create: XOR<JournalLineCreateWithoutContactInput, JournalLineUncheckedCreateWithoutContactInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutContactInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutContactInput, JournalLineUncheckedUpdateWithoutContactInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutContactInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutContactInput>
  }

  export type JournalLineScalarWhereInput = {
    AND?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    OR?: JournalLineScalarWhereInput[]
    NOT?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    id?: UuidFilter<"JournalLine"> | string
    journalEntryId?: UuidFilter<"JournalLine"> | string
    glAccountId?: UuidFilter<"JournalLine"> | string
    analyticAccountId?: UuidNullableFilter<"JournalLine"> | string | null
    contactId?: UuidNullableFilter<"JournalLine"> | string | null
    productId?: UuidNullableFilter<"JournalLine"> | string | null
    description?: StringNullableFilter<"JournalLine"> | string | null
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleUpsertWithWhereUniqueWithoutContactInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    update: XOR<AutoAnalyticRuleUpdateWithoutContactInput, AutoAnalyticRuleUncheckedUpdateWithoutContactInput>
    create: XOR<AutoAnalyticRuleCreateWithoutContactInput, AutoAnalyticRuleUncheckedCreateWithoutContactInput>
  }

  export type AutoAnalyticRuleUpdateWithWhereUniqueWithoutContactInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    data: XOR<AutoAnalyticRuleUpdateWithoutContactInput, AutoAnalyticRuleUncheckedUpdateWithoutContactInput>
  }

  export type AutoAnalyticRuleUpdateManyWithWhereWithoutContactInput = {
    where: AutoAnalyticRuleScalarWhereInput
    data: XOR<AutoAnalyticRuleUpdateManyMutationInput, AutoAnalyticRuleUncheckedUpdateManyWithoutContactInput>
  }

  export type AutoAnalyticRuleScalarWhereInput = {
    AND?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
    OR?: AutoAnalyticRuleScalarWhereInput[]
    NOT?: AutoAnalyticRuleScalarWhereInput | AutoAnalyticRuleScalarWhereInput[]
    id?: UuidFilter<"AutoAnalyticRule"> | string
    modelId?: UuidFilter<"AutoAnalyticRule"> | string
    docType?: EnumAutoDocTypeFilter<"AutoAnalyticRule"> | $Enums.AutoDocType
    matchProductId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    matchCategoryId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    matchContactId?: UuidNullableFilter<"AutoAnalyticRule"> | string | null
    assignAnalyticAccountId?: UuidFilter<"AutoAnalyticRule"> | string
    rulePriority?: IntFilter<"AutoAnalyticRule"> | number
    isActive?: BoolFilter<"AutoAnalyticRule"> | boolean
  }

  export type CompanyCreateWithoutProductCategoriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProductCategoriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProductCategoriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
  }

  export type ProductCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    company: CompanyCreateNestedOneWithoutProductCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    companyId: string
    name: string
    parentId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutChildrenInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type ProductCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    company: CompanyCreateNestedOneWithoutProductCategoriesInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    companyId: string
    name: string
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryCreateManyParentInputEnvelope = {
    data: ProductCategoryCreateManyParentInput | ProductCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type AutoAnalyticRuleCreateWithoutCategoryInput = {
    id?: string
    docType: $Enums.AutoDocType
    rulePriority?: number
    isActive?: boolean
    model: AutoAnalyticModelCreateNestedOneWithoutRulesInput
    product?: ProductCreateNestedOneWithoutAutoAnalyticRulesInput
    contact?: ContactCreateNestedOneWithoutAutoAnalyticRulesInput
    assignAnalytic: AnalyticAccountCreateNestedOneWithoutAutoAnalyticRulesInput
  }

  export type AutoAnalyticRuleUncheckedCreateWithoutCategoryInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleCreateOrConnectWithoutCategoryInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    create: XOR<AutoAnalyticRuleCreateWithoutCategoryInput, AutoAnalyticRuleUncheckedCreateWithoutCategoryInput>
  }

  export type AutoAnalyticRuleCreateManyCategoryInputEnvelope = {
    data: AutoAnalyticRuleCreateManyCategoryInput | AutoAnalyticRuleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutProductCategoriesInput = {
    update: XOR<CompanyUpdateWithoutProductCategoriesInput, CompanyUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<CompanyCreateWithoutProductCategoriesInput, CompanyUncheckedCreateWithoutProductCategoriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProductCategoriesInput, CompanyUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type CompanyUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProductCategoryUpsertWithoutChildrenInput = {
    update: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutParentInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type AutoAnalyticRuleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    update: XOR<AutoAnalyticRuleUpdateWithoutCategoryInput, AutoAnalyticRuleUncheckedUpdateWithoutCategoryInput>
    create: XOR<AutoAnalyticRuleCreateWithoutCategoryInput, AutoAnalyticRuleUncheckedCreateWithoutCategoryInput>
  }

  export type AutoAnalyticRuleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    data: XOR<AutoAnalyticRuleUpdateWithoutCategoryInput, AutoAnalyticRuleUncheckedUpdateWithoutCategoryInput>
  }

  export type AutoAnalyticRuleUpdateManyWithWhereWithoutCategoryInput = {
    where: AutoAnalyticRuleScalarWhereInput
    data: XOR<AutoAnalyticRuleUpdateManyMutationInput, AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CompanyCreateWithoutProductsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProductsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    company: CompanyCreateNestedOneWithoutProductCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    companyId: string
    name: string
    parentId?: string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type PurchaseOrderLineCreateWithoutProductInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutPoLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseOrderId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineCreateOrConnectWithoutProductInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutProductInput, PurchaseOrderLineUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderLineCreateManyProductInputEnvelope = {
    data: PurchaseOrderLineCreateManyProductInput | PurchaseOrderLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderLineCreateWithoutProductInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    salesOrder: SalesOrderCreateNestedOneWithoutLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutSoLinesInput
  }

  export type SalesOrderLineUncheckedCreateWithoutProductInput = {
    id?: string
    salesOrderId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutProductInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutProductInput, SalesOrderLineUncheckedCreateWithoutProductInput>
  }

  export type SalesOrderLineCreateManyProductInputEnvelope = {
    data: SalesOrderLineCreateManyProductInput | SalesOrderLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillLineCreateWithoutProductInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    bill: VendorBillCreateNestedOneWithoutLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutBillLinesInput
    gl?: GLAccountCreateNestedOneWithoutBillLinesInput
  }

  export type VendorBillLineUncheckedCreateWithoutProductInput = {
    id?: string
    vendorBillId: string
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateOrConnectWithoutProductInput = {
    where: VendorBillLineWhereUniqueInput
    create: XOR<VendorBillLineCreateWithoutProductInput, VendorBillLineUncheckedCreateWithoutProductInput>
  }

  export type VendorBillLineCreateManyProductInputEnvelope = {
    data: VendorBillLineCreateManyProductInput | VendorBillLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CustomerInvoiceLineCreateWithoutProductInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: CustomerInvoiceCreateNestedOneWithoutLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutInvLinesInput
    gl?: GLAccountCreateNestedOneWithoutInvLinesInput
  }

  export type CustomerInvoiceLineUncheckedCreateWithoutProductInput = {
    id?: string
    customerInvoiceId: string
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateOrConnectWithoutProductInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    create: XOR<CustomerInvoiceLineCreateWithoutProductInput, CustomerInvoiceLineUncheckedCreateWithoutProductInput>
  }

  export type CustomerInvoiceLineCreateManyProductInputEnvelope = {
    data: CustomerInvoiceLineCreateManyProductInput | CustomerInvoiceLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type JournalLineCreateWithoutProductInput = {
    id?: string
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    entry: JournalEntryCreateNestedOneWithoutLinesInput
    gl: GLAccountCreateNestedOneWithoutJournalLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutJournalLinesInput
    contact?: ContactCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutProductInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    analyticAccountId?: string | null
    contactId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateOrConnectWithoutProductInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutProductInput, JournalLineUncheckedCreateWithoutProductInput>
  }

  export type JournalLineCreateManyProductInputEnvelope = {
    data: JournalLineCreateManyProductInput | JournalLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AutoAnalyticRuleCreateWithoutProductInput = {
    id?: string
    docType: $Enums.AutoDocType
    rulePriority?: number
    isActive?: boolean
    model: AutoAnalyticModelCreateNestedOneWithoutRulesInput
    category?: ProductCategoryCreateNestedOneWithoutAutoAnalyticRulesInput
    contact?: ContactCreateNestedOneWithoutAutoAnalyticRulesInput
    assignAnalytic: AnalyticAccountCreateNestedOneWithoutAutoAnalyticRulesInput
  }

  export type AutoAnalyticRuleUncheckedCreateWithoutProductInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchCategoryId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleCreateOrConnectWithoutProductInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    create: XOR<AutoAnalyticRuleCreateWithoutProductInput, AutoAnalyticRuleUncheckedCreateWithoutProductInput>
  }

  export type AutoAnalyticRuleCreateManyProductInputEnvelope = {
    data: AutoAnalyticRuleCreateManyProductInput | AutoAnalyticRuleCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutProductsInput = {
    update: XOR<CompanyUpdateWithoutProductsInput, CompanyUncheckedUpdateWithoutProductsInput>
    create: XOR<CompanyCreateWithoutProductsInput, CompanyUncheckedCreateWithoutProductsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProductsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProductsInput, CompanyUncheckedUpdateWithoutProductsInput>
  }

  export type CompanyUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutProductInput, PurchaseOrderLineUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseOrderLineCreateWithoutProductInput, PurchaseOrderLineUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutProductInput, PurchaseOrderLineUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseOrderLineScalarWhereInput = {
    AND?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    OR?: PurchaseOrderLineScalarWhereInput[]
    NOT?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    id?: UuidFilter<"PurchaseOrderLine"> | string
    purchaseOrderId?: UuidFilter<"PurchaseOrderLine"> | string
    productId?: UuidFilter<"PurchaseOrderLine"> | string
    analyticAccountId?: UuidNullableFilter<"PurchaseOrderLine"> | string | null
    description?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutProductInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutProductInput, SalesOrderLineUncheckedUpdateWithoutProductInput>
    create: XOR<SalesOrderLineCreateWithoutProductInput, SalesOrderLineUncheckedCreateWithoutProductInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutProductInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutProductInput, SalesOrderLineUncheckedUpdateWithoutProductInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutProductInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutProductInput>
  }

  export type SalesOrderLineScalarWhereInput = {
    AND?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
    OR?: SalesOrderLineScalarWhereInput[]
    NOT?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
    id?: UuidFilter<"SalesOrderLine"> | string
    salesOrderId?: UuidFilter<"SalesOrderLine"> | string
    productId?: UuidFilter<"SalesOrderLine"> | string
    analyticAccountId?: UuidNullableFilter<"SalesOrderLine"> | string | null
    description?: StringNullableFilter<"SalesOrderLine"> | string | null
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUpsertWithWhereUniqueWithoutProductInput = {
    where: VendorBillLineWhereUniqueInput
    update: XOR<VendorBillLineUpdateWithoutProductInput, VendorBillLineUncheckedUpdateWithoutProductInput>
    create: XOR<VendorBillLineCreateWithoutProductInput, VendorBillLineUncheckedCreateWithoutProductInput>
  }

  export type VendorBillLineUpdateWithWhereUniqueWithoutProductInput = {
    where: VendorBillLineWhereUniqueInput
    data: XOR<VendorBillLineUpdateWithoutProductInput, VendorBillLineUncheckedUpdateWithoutProductInput>
  }

  export type VendorBillLineUpdateManyWithWhereWithoutProductInput = {
    where: VendorBillLineScalarWhereInput
    data: XOR<VendorBillLineUpdateManyMutationInput, VendorBillLineUncheckedUpdateManyWithoutProductInput>
  }

  export type VendorBillLineScalarWhereInput = {
    AND?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
    OR?: VendorBillLineScalarWhereInput[]
    NOT?: VendorBillLineScalarWhereInput | VendorBillLineScalarWhereInput[]
    id?: UuidFilter<"VendorBillLine"> | string
    vendorBillId?: UuidFilter<"VendorBillLine"> | string
    productId?: UuidNullableFilter<"VendorBillLine"> | string | null
    analyticAccountId?: UuidNullableFilter<"VendorBillLine"> | string | null
    glAccountId?: UuidNullableFilter<"VendorBillLine"> | string | null
    description?: StringNullableFilter<"VendorBillLine"> | string | null
    qty?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"VendorBillLine"> | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUpsertWithWhereUniqueWithoutProductInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    update: XOR<CustomerInvoiceLineUpdateWithoutProductInput, CustomerInvoiceLineUncheckedUpdateWithoutProductInput>
    create: XOR<CustomerInvoiceLineCreateWithoutProductInput, CustomerInvoiceLineUncheckedCreateWithoutProductInput>
  }

  export type CustomerInvoiceLineUpdateWithWhereUniqueWithoutProductInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    data: XOR<CustomerInvoiceLineUpdateWithoutProductInput, CustomerInvoiceLineUncheckedUpdateWithoutProductInput>
  }

  export type CustomerInvoiceLineUpdateManyWithWhereWithoutProductInput = {
    where: CustomerInvoiceLineScalarWhereInput
    data: XOR<CustomerInvoiceLineUpdateManyMutationInput, CustomerInvoiceLineUncheckedUpdateManyWithoutProductInput>
  }

  export type CustomerInvoiceLineScalarWhereInput = {
    AND?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
    OR?: CustomerInvoiceLineScalarWhereInput[]
    NOT?: CustomerInvoiceLineScalarWhereInput | CustomerInvoiceLineScalarWhereInput[]
    id?: UuidFilter<"CustomerInvoiceLine"> | string
    customerInvoiceId?: UuidFilter<"CustomerInvoiceLine"> | string
    productId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    analyticAccountId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    glAccountId?: UuidNullableFilter<"CustomerInvoiceLine"> | string | null
    description?: StringNullableFilter<"CustomerInvoiceLine"> | string | null
    qty?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"CustomerInvoiceLine"> | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpsertWithWhereUniqueWithoutProductInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutProductInput, JournalLineUncheckedUpdateWithoutProductInput>
    create: XOR<JournalLineCreateWithoutProductInput, JournalLineUncheckedCreateWithoutProductInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutProductInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutProductInput, JournalLineUncheckedUpdateWithoutProductInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutProductInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutProductInput>
  }

  export type AutoAnalyticRuleUpsertWithWhereUniqueWithoutProductInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    update: XOR<AutoAnalyticRuleUpdateWithoutProductInput, AutoAnalyticRuleUncheckedUpdateWithoutProductInput>
    create: XOR<AutoAnalyticRuleCreateWithoutProductInput, AutoAnalyticRuleUncheckedCreateWithoutProductInput>
  }

  export type AutoAnalyticRuleUpdateWithWhereUniqueWithoutProductInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    data: XOR<AutoAnalyticRuleUpdateWithoutProductInput, AutoAnalyticRuleUncheckedUpdateWithoutProductInput>
  }

  export type AutoAnalyticRuleUpdateManyWithWhereWithoutProductInput = {
    where: AutoAnalyticRuleScalarWhereInput
    data: XOR<AutoAnalyticRuleUpdateManyMutationInput, AutoAnalyticRuleUncheckedUpdateManyWithoutProductInput>
  }

  export type CompanyCreateWithoutAnalyticAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAnalyticAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAnalyticAccountsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAnalyticAccountsInput, CompanyUncheckedCreateWithoutAnalyticAccountsInput>
  }

  export type AnalyticAccountCreateWithoutChildrenInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutChildrenInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutChildrenInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutChildrenInput, AnalyticAccountUncheckedCreateWithoutChildrenInput>
  }

  export type AnalyticAccountCreateWithoutParentInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutParentInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutParentInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutParentInput, AnalyticAccountUncheckedCreateWithoutParentInput>
  }

  export type AnalyticAccountCreateManyParentInputEnvelope = {
    data: AnalyticAccountCreateManyParentInput | AnalyticAccountCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BudgetLineCreateWithoutAnalyticInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    revision: BudgetRevisionCreateNestedOneWithoutLinesInput
    gl?: GLAccountCreateNestedOneWithoutBudgetLinesInput
  }

  export type BudgetLineUncheckedCreateWithoutAnalyticInput = {
    id?: string
    budgetRevisionId: string
    glAccountId?: string | null
    amount: Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineCreateOrConnectWithoutAnalyticInput = {
    where: BudgetLineWhereUniqueInput
    create: XOR<BudgetLineCreateWithoutAnalyticInput, BudgetLineUncheckedCreateWithoutAnalyticInput>
  }

  export type BudgetLineCreateManyAnalyticInputEnvelope = {
    data: BudgetLineCreateManyAnalyticInput | BudgetLineCreateManyAnalyticInput[]
    skipDuplicates?: boolean
  }

  export type JournalLineCreateWithoutAnalyticInput = {
    id?: string
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    entry: JournalEntryCreateNestedOneWithoutLinesInput
    gl: GLAccountCreateNestedOneWithoutJournalLinesInput
    contact?: ContactCreateNestedOneWithoutJournalLinesInput
    product?: ProductCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutAnalyticInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateOrConnectWithoutAnalyticInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutAnalyticInput, JournalLineUncheckedCreateWithoutAnalyticInput>
  }

  export type JournalLineCreateManyAnalyticInputEnvelope = {
    data: JournalLineCreateManyAnalyticInput | JournalLineCreateManyAnalyticInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderLineCreateWithoutAnalyticInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutPoLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutAnalyticInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineCreateOrConnectWithoutAnalyticInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutAnalyticInput, PurchaseOrderLineUncheckedCreateWithoutAnalyticInput>
  }

  export type PurchaseOrderLineCreateManyAnalyticInputEnvelope = {
    data: PurchaseOrderLineCreateManyAnalyticInput | PurchaseOrderLineCreateManyAnalyticInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderLineCreateWithoutAnalyticInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    salesOrder: SalesOrderCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutSoLinesInput
  }

  export type SalesOrderLineUncheckedCreateWithoutAnalyticInput = {
    id?: string
    salesOrderId: string
    productId: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutAnalyticInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutAnalyticInput, SalesOrderLineUncheckedCreateWithoutAnalyticInput>
  }

  export type SalesOrderLineCreateManyAnalyticInputEnvelope = {
    data: SalesOrderLineCreateManyAnalyticInput | SalesOrderLineCreateManyAnalyticInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillLineCreateWithoutAnalyticInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    bill: VendorBillCreateNestedOneWithoutLinesInput
    product?: ProductCreateNestedOneWithoutBillLinesInput
    gl?: GLAccountCreateNestedOneWithoutBillLinesInput
  }

  export type VendorBillLineUncheckedCreateWithoutAnalyticInput = {
    id?: string
    vendorBillId: string
    productId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateOrConnectWithoutAnalyticInput = {
    where: VendorBillLineWhereUniqueInput
    create: XOR<VendorBillLineCreateWithoutAnalyticInput, VendorBillLineUncheckedCreateWithoutAnalyticInput>
  }

  export type VendorBillLineCreateManyAnalyticInputEnvelope = {
    data: VendorBillLineCreateManyAnalyticInput | VendorBillLineCreateManyAnalyticInput[]
    skipDuplicates?: boolean
  }

  export type CustomerInvoiceLineCreateWithoutAnalyticInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: CustomerInvoiceCreateNestedOneWithoutLinesInput
    product?: ProductCreateNestedOneWithoutInvLinesInput
    gl?: GLAccountCreateNestedOneWithoutInvLinesInput
  }

  export type CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput = {
    id?: string
    customerInvoiceId: string
    productId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateOrConnectWithoutAnalyticInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    create: XOR<CustomerInvoiceLineCreateWithoutAnalyticInput, CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput>
  }

  export type CustomerInvoiceLineCreateManyAnalyticInputEnvelope = {
    data: CustomerInvoiceLineCreateManyAnalyticInput | CustomerInvoiceLineCreateManyAnalyticInput[]
    skipDuplicates?: boolean
  }

  export type AutoAnalyticRuleCreateWithoutAssignAnalyticInput = {
    id?: string
    docType: $Enums.AutoDocType
    rulePriority?: number
    isActive?: boolean
    model: AutoAnalyticModelCreateNestedOneWithoutRulesInput
    product?: ProductCreateNestedOneWithoutAutoAnalyticRulesInput
    category?: ProductCategoryCreateNestedOneWithoutAutoAnalyticRulesInput
    contact?: ContactCreateNestedOneWithoutAutoAnalyticRulesInput
  }

  export type AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    matchContactId?: string | null
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleCreateOrConnectWithoutAssignAnalyticInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    create: XOR<AutoAnalyticRuleCreateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput>
  }

  export type AutoAnalyticRuleCreateManyAssignAnalyticInputEnvelope = {
    data: AutoAnalyticRuleCreateManyAssignAnalyticInput | AutoAnalyticRuleCreateManyAssignAnalyticInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutAnalyticAccountsInput = {
    update: XOR<CompanyUpdateWithoutAnalyticAccountsInput, CompanyUncheckedUpdateWithoutAnalyticAccountsInput>
    create: XOR<CompanyCreateWithoutAnalyticAccountsInput, CompanyUncheckedCreateWithoutAnalyticAccountsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAnalyticAccountsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAnalyticAccountsInput, CompanyUncheckedUpdateWithoutAnalyticAccountsInput>
  }

  export type CompanyUpdateWithoutAnalyticAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAnalyticAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AnalyticAccountUpsertWithoutChildrenInput = {
    update: XOR<AnalyticAccountUpdateWithoutChildrenInput, AnalyticAccountUncheckedUpdateWithoutChildrenInput>
    create: XOR<AnalyticAccountCreateWithoutChildrenInput, AnalyticAccountUncheckedCreateWithoutChildrenInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutChildrenInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutChildrenInput, AnalyticAccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AnalyticAccountUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUpsertWithWhereUniqueWithoutParentInput = {
    where: AnalyticAccountWhereUniqueInput
    update: XOR<AnalyticAccountUpdateWithoutParentInput, AnalyticAccountUncheckedUpdateWithoutParentInput>
    create: XOR<AnalyticAccountCreateWithoutParentInput, AnalyticAccountUncheckedCreateWithoutParentInput>
  }

  export type AnalyticAccountUpdateWithWhereUniqueWithoutParentInput = {
    where: AnalyticAccountWhereUniqueInput
    data: XOR<AnalyticAccountUpdateWithoutParentInput, AnalyticAccountUncheckedUpdateWithoutParentInput>
  }

  export type AnalyticAccountUpdateManyWithWhereWithoutParentInput = {
    where: AnalyticAccountScalarWhereInput
    data: XOR<AnalyticAccountUpdateManyMutationInput, AnalyticAccountUncheckedUpdateManyWithoutParentInput>
  }

  export type BudgetLineUpsertWithWhereUniqueWithoutAnalyticInput = {
    where: BudgetLineWhereUniqueInput
    update: XOR<BudgetLineUpdateWithoutAnalyticInput, BudgetLineUncheckedUpdateWithoutAnalyticInput>
    create: XOR<BudgetLineCreateWithoutAnalyticInput, BudgetLineUncheckedCreateWithoutAnalyticInput>
  }

  export type BudgetLineUpdateWithWhereUniqueWithoutAnalyticInput = {
    where: BudgetLineWhereUniqueInput
    data: XOR<BudgetLineUpdateWithoutAnalyticInput, BudgetLineUncheckedUpdateWithoutAnalyticInput>
  }

  export type BudgetLineUpdateManyWithWhereWithoutAnalyticInput = {
    where: BudgetLineScalarWhereInput
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyWithoutAnalyticInput>
  }

  export type BudgetLineScalarWhereInput = {
    AND?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
    OR?: BudgetLineScalarWhereInput[]
    NOT?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
    id?: UuidFilter<"BudgetLine"> | string
    budgetRevisionId?: UuidFilter<"BudgetLine"> | string
    analyticAccountId?: UuidFilter<"BudgetLine"> | string
    glAccountId?: UuidNullableFilter<"BudgetLine"> | string | null
    amount?: DecimalFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpsertWithWhereUniqueWithoutAnalyticInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutAnalyticInput, JournalLineUncheckedUpdateWithoutAnalyticInput>
    create: XOR<JournalLineCreateWithoutAnalyticInput, JournalLineUncheckedCreateWithoutAnalyticInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutAnalyticInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutAnalyticInput, JournalLineUncheckedUpdateWithoutAnalyticInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutAnalyticInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutAnalyticInput>
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutAnalyticInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutAnalyticInput, PurchaseOrderLineUncheckedUpdateWithoutAnalyticInput>
    create: XOR<PurchaseOrderLineCreateWithoutAnalyticInput, PurchaseOrderLineUncheckedCreateWithoutAnalyticInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutAnalyticInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutAnalyticInput, PurchaseOrderLineUncheckedUpdateWithoutAnalyticInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutAnalyticInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticInput>
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutAnalyticInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutAnalyticInput, SalesOrderLineUncheckedUpdateWithoutAnalyticInput>
    create: XOR<SalesOrderLineCreateWithoutAnalyticInput, SalesOrderLineUncheckedCreateWithoutAnalyticInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutAnalyticInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutAnalyticInput, SalesOrderLineUncheckedUpdateWithoutAnalyticInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutAnalyticInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutAnalyticInput>
  }

  export type VendorBillLineUpsertWithWhereUniqueWithoutAnalyticInput = {
    where: VendorBillLineWhereUniqueInput
    update: XOR<VendorBillLineUpdateWithoutAnalyticInput, VendorBillLineUncheckedUpdateWithoutAnalyticInput>
    create: XOR<VendorBillLineCreateWithoutAnalyticInput, VendorBillLineUncheckedCreateWithoutAnalyticInput>
  }

  export type VendorBillLineUpdateWithWhereUniqueWithoutAnalyticInput = {
    where: VendorBillLineWhereUniqueInput
    data: XOR<VendorBillLineUpdateWithoutAnalyticInput, VendorBillLineUncheckedUpdateWithoutAnalyticInput>
  }

  export type VendorBillLineUpdateManyWithWhereWithoutAnalyticInput = {
    where: VendorBillLineScalarWhereInput
    data: XOR<VendorBillLineUpdateManyMutationInput, VendorBillLineUncheckedUpdateManyWithoutAnalyticInput>
  }

  export type CustomerInvoiceLineUpsertWithWhereUniqueWithoutAnalyticInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    update: XOR<CustomerInvoiceLineUpdateWithoutAnalyticInput, CustomerInvoiceLineUncheckedUpdateWithoutAnalyticInput>
    create: XOR<CustomerInvoiceLineCreateWithoutAnalyticInput, CustomerInvoiceLineUncheckedCreateWithoutAnalyticInput>
  }

  export type CustomerInvoiceLineUpdateWithWhereUniqueWithoutAnalyticInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    data: XOR<CustomerInvoiceLineUpdateWithoutAnalyticInput, CustomerInvoiceLineUncheckedUpdateWithoutAnalyticInput>
  }

  export type CustomerInvoiceLineUpdateManyWithWhereWithoutAnalyticInput = {
    where: CustomerInvoiceLineScalarWhereInput
    data: XOR<CustomerInvoiceLineUpdateManyMutationInput, CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticInput>
  }

  export type AutoAnalyticRuleUpsertWithWhereUniqueWithoutAssignAnalyticInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    update: XOR<AutoAnalyticRuleUpdateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedUpdateWithoutAssignAnalyticInput>
    create: XOR<AutoAnalyticRuleCreateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedCreateWithoutAssignAnalyticInput>
  }

  export type AutoAnalyticRuleUpdateWithWhereUniqueWithoutAssignAnalyticInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    data: XOR<AutoAnalyticRuleUpdateWithoutAssignAnalyticInput, AutoAnalyticRuleUncheckedUpdateWithoutAssignAnalyticInput>
  }

  export type AutoAnalyticRuleUpdateManyWithWhereWithoutAssignAnalyticInput = {
    where: AutoAnalyticRuleScalarWhereInput
    data: XOR<AutoAnalyticRuleUpdateManyMutationInput, AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticInput>
  }

  export type CompanyCreateWithoutGlAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutGlAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutGlAccountsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutGlAccountsInput, CompanyUncheckedCreateWithoutGlAccountsInput>
  }

  export type JournalLineCreateWithoutGlInput = {
    id?: string
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    entry: JournalEntryCreateNestedOneWithoutLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutJournalLinesInput
    contact?: ContactCreateNestedOneWithoutJournalLinesInput
    product?: ProductCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutGlInput = {
    id?: string
    journalEntryId: string
    analyticAccountId?: string | null
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateOrConnectWithoutGlInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutGlInput, JournalLineUncheckedCreateWithoutGlInput>
  }

  export type JournalLineCreateManyGlInputEnvelope = {
    data: JournalLineCreateManyGlInput | JournalLineCreateManyGlInput[]
    skipDuplicates?: boolean
  }

  export type BudgetLineCreateWithoutGlInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    revision: BudgetRevisionCreateNestedOneWithoutLinesInput
    analytic: AnalyticAccountCreateNestedOneWithoutBudgetLinesInput
  }

  export type BudgetLineUncheckedCreateWithoutGlInput = {
    id?: string
    budgetRevisionId: string
    analyticAccountId: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineCreateOrConnectWithoutGlInput = {
    where: BudgetLineWhereUniqueInput
    create: XOR<BudgetLineCreateWithoutGlInput, BudgetLineUncheckedCreateWithoutGlInput>
  }

  export type BudgetLineCreateManyGlInputEnvelope = {
    data: BudgetLineCreateManyGlInput | BudgetLineCreateManyGlInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillLineCreateWithoutGlInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    bill: VendorBillCreateNestedOneWithoutLinesInput
    product?: ProductCreateNestedOneWithoutBillLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutBillLinesInput
  }

  export type VendorBillLineUncheckedCreateWithoutGlInput = {
    id?: string
    vendorBillId: string
    productId?: string | null
    analyticAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateOrConnectWithoutGlInput = {
    where: VendorBillLineWhereUniqueInput
    create: XOR<VendorBillLineCreateWithoutGlInput, VendorBillLineUncheckedCreateWithoutGlInput>
  }

  export type VendorBillLineCreateManyGlInputEnvelope = {
    data: VendorBillLineCreateManyGlInput | VendorBillLineCreateManyGlInput[]
    skipDuplicates?: boolean
  }

  export type CustomerInvoiceLineCreateWithoutGlInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: CustomerInvoiceCreateNestedOneWithoutLinesInput
    product?: ProductCreateNestedOneWithoutInvLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutInvLinesInput
  }

  export type CustomerInvoiceLineUncheckedCreateWithoutGlInput = {
    id?: string
    customerInvoiceId: string
    productId?: string | null
    analyticAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateOrConnectWithoutGlInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    create: XOR<CustomerInvoiceLineCreateWithoutGlInput, CustomerInvoiceLineUncheckedCreateWithoutGlInput>
  }

  export type CustomerInvoiceLineCreateManyGlInputEnvelope = {
    data: CustomerInvoiceLineCreateManyGlInput | CustomerInvoiceLineCreateManyGlInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutGlAccountsInput = {
    update: XOR<CompanyUpdateWithoutGlAccountsInput, CompanyUncheckedUpdateWithoutGlAccountsInput>
    create: XOR<CompanyCreateWithoutGlAccountsInput, CompanyUncheckedCreateWithoutGlAccountsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutGlAccountsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutGlAccountsInput, CompanyUncheckedUpdateWithoutGlAccountsInput>
  }

  export type CompanyUpdateWithoutGlAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutGlAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type JournalLineUpsertWithWhereUniqueWithoutGlInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutGlInput, JournalLineUncheckedUpdateWithoutGlInput>
    create: XOR<JournalLineCreateWithoutGlInput, JournalLineUncheckedCreateWithoutGlInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutGlInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutGlInput, JournalLineUncheckedUpdateWithoutGlInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutGlInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutGlInput>
  }

  export type BudgetLineUpsertWithWhereUniqueWithoutGlInput = {
    where: BudgetLineWhereUniqueInput
    update: XOR<BudgetLineUpdateWithoutGlInput, BudgetLineUncheckedUpdateWithoutGlInput>
    create: XOR<BudgetLineCreateWithoutGlInput, BudgetLineUncheckedCreateWithoutGlInput>
  }

  export type BudgetLineUpdateWithWhereUniqueWithoutGlInput = {
    where: BudgetLineWhereUniqueInput
    data: XOR<BudgetLineUpdateWithoutGlInput, BudgetLineUncheckedUpdateWithoutGlInput>
  }

  export type BudgetLineUpdateManyWithWhereWithoutGlInput = {
    where: BudgetLineScalarWhereInput
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyWithoutGlInput>
  }

  export type VendorBillLineUpsertWithWhereUniqueWithoutGlInput = {
    where: VendorBillLineWhereUniqueInput
    update: XOR<VendorBillLineUpdateWithoutGlInput, VendorBillLineUncheckedUpdateWithoutGlInput>
    create: XOR<VendorBillLineCreateWithoutGlInput, VendorBillLineUncheckedCreateWithoutGlInput>
  }

  export type VendorBillLineUpdateWithWhereUniqueWithoutGlInput = {
    where: VendorBillLineWhereUniqueInput
    data: XOR<VendorBillLineUpdateWithoutGlInput, VendorBillLineUncheckedUpdateWithoutGlInput>
  }

  export type VendorBillLineUpdateManyWithWhereWithoutGlInput = {
    where: VendorBillLineScalarWhereInput
    data: XOR<VendorBillLineUpdateManyMutationInput, VendorBillLineUncheckedUpdateManyWithoutGlInput>
  }

  export type CustomerInvoiceLineUpsertWithWhereUniqueWithoutGlInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    update: XOR<CustomerInvoiceLineUpdateWithoutGlInput, CustomerInvoiceLineUncheckedUpdateWithoutGlInput>
    create: XOR<CustomerInvoiceLineCreateWithoutGlInput, CustomerInvoiceLineUncheckedCreateWithoutGlInput>
  }

  export type CustomerInvoiceLineUpdateWithWhereUniqueWithoutGlInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    data: XOR<CustomerInvoiceLineUpdateWithoutGlInput, CustomerInvoiceLineUncheckedUpdateWithoutGlInput>
  }

  export type CustomerInvoiceLineUpdateManyWithWhereWithoutGlInput = {
    where: CustomerInvoiceLineScalarWhereInput
    data: XOR<CustomerInvoiceLineUpdateManyMutationInput, CustomerInvoiceLineUncheckedUpdateManyWithoutGlInput>
  }

  export type CompanyCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutJournalEntriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
  }

  export type JournalLineCreateWithoutEntryInput = {
    id?: string
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    gl: GLAccountCreateNestedOneWithoutJournalLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutJournalLinesInput
    contact?: ContactCreateNestedOneWithoutJournalLinesInput
    product?: ProductCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutEntryInput = {
    id?: string
    glAccountId: string
    analyticAccountId?: string | null
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateOrConnectWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput>
  }

  export type JournalLineCreateManyEntryInputEnvelope = {
    data: JournalLineCreateManyEntryInput | JournalLineCreateManyEntryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutJournalEntriesInput = {
    update: XOR<CompanyUpdateWithoutJournalEntriesInput, CompanyUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutJournalEntriesInput, CompanyUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type CompanyUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type JournalLineUpsertWithWhereUniqueWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutEntryInput, JournalLineUncheckedUpdateWithoutEntryInput>
    create: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutEntryInput, JournalLineUncheckedUpdateWithoutEntryInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutEntryInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutEntryInput>
  }

  export type JournalEntryCreateWithoutLinesInput = {
    id?: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateWithoutLinesInput = {
    id?: string
    companyId: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
  }

  export type JournalEntryCreateOrConnectWithoutLinesInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
  }

  export type GLAccountCreateWithoutJournalLinesInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    company: CompanyCreateNestedOneWithoutGlAccountsInput
    budgetLines?: BudgetLineCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutGlInput
  }

  export type GLAccountUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    companyId: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutGlInput
  }

  export type GLAccountCreateOrConnectWithoutJournalLinesInput = {
    where: GLAccountWhereUniqueInput
    create: XOR<GLAccountCreateWithoutJournalLinesInput, GLAccountUncheckedCreateWithoutJournalLinesInput>
  }

  export type AnalyticAccountCreateWithoutJournalLinesInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutJournalLinesInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutJournalLinesInput, AnalyticAccountUncheckedCreateWithoutJournalLinesInput>
  }

  export type ContactCreateWithoutJournalLinesInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutJournalLinesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutJournalLinesInput, ContactUncheckedCreateWithoutJournalLinesInput>
  }

  export type ProductCreateWithoutJournalLinesInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutJournalLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutJournalLinesInput, ProductUncheckedCreateWithoutJournalLinesInput>
  }

  export type JournalEntryUpsertWithoutLinesInput = {
    update: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    where?: JournalEntryWhereInput
  }

  export type JournalEntryUpdateToOneWithWhereWithoutLinesInput = {
    where?: JournalEntryWhereInput
    data: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type JournalEntryUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GLAccountUpsertWithoutJournalLinesInput = {
    update: XOR<GLAccountUpdateWithoutJournalLinesInput, GLAccountUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<GLAccountCreateWithoutJournalLinesInput, GLAccountUncheckedCreateWithoutJournalLinesInput>
    where?: GLAccountWhereInput
  }

  export type GLAccountUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: GLAccountWhereInput
    data: XOR<GLAccountUpdateWithoutJournalLinesInput, GLAccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type GLAccountUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneRequiredWithoutGlAccountsNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutGlNestedInput
  }

  export type GLAccountUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutGlNestedInput
  }

  export type AnalyticAccountUpsertWithoutJournalLinesInput = {
    update: XOR<AnalyticAccountUpdateWithoutJournalLinesInput, AnalyticAccountUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<AnalyticAccountCreateWithoutJournalLinesInput, AnalyticAccountUncheckedCreateWithoutJournalLinesInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutJournalLinesInput, AnalyticAccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type AnalyticAccountUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type ContactUpsertWithoutJournalLinesInput = {
    update: XOR<ContactUpdateWithoutJournalLinesInput, ContactUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<ContactCreateWithoutJournalLinesInput, ContactUncheckedCreateWithoutJournalLinesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutJournalLinesInput, ContactUncheckedUpdateWithoutJournalLinesInput>
  }

  export type ContactUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ProductUpsertWithoutJournalLinesInput = {
    update: XOR<ProductUpdateWithoutJournalLinesInput, ProductUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<ProductCreateWithoutJournalLinesInput, ProductUncheckedCreateWithoutJournalLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutJournalLinesInput, ProductUncheckedUpdateWithoutJournalLinesInput>
  }

  export type ProductUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CompanyCreateWithoutBudgetsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBudgetsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBudgetsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBudgetsInput, CompanyUncheckedCreateWithoutBudgetsInput>
  }

  export type BudgetRevisionCreateWithoutBudgetInput = {
    id?: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    lines?: BudgetLineCreateNestedManyWithoutRevisionInput
  }

  export type BudgetRevisionUncheckedCreateWithoutBudgetInput = {
    id?: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    lines?: BudgetLineUncheckedCreateNestedManyWithoutRevisionInput
  }

  export type BudgetRevisionCreateOrConnectWithoutBudgetInput = {
    where: BudgetRevisionWhereUniqueInput
    create: XOR<BudgetRevisionCreateWithoutBudgetInput, BudgetRevisionUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetRevisionCreateManyBudgetInputEnvelope = {
    data: BudgetRevisionCreateManyBudgetInput | BudgetRevisionCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBudgetsInput = {
    update: XOR<CompanyUpdateWithoutBudgetsInput, CompanyUncheckedUpdateWithoutBudgetsInput>
    create: XOR<CompanyCreateWithoutBudgetsInput, CompanyUncheckedCreateWithoutBudgetsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBudgetsInput, CompanyUncheckedUpdateWithoutBudgetsInput>
  }

  export type CompanyUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type BudgetRevisionUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetRevisionWhereUniqueInput
    update: XOR<BudgetRevisionUpdateWithoutBudgetInput, BudgetRevisionUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetRevisionCreateWithoutBudgetInput, BudgetRevisionUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetRevisionUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetRevisionWhereUniqueInput
    data: XOR<BudgetRevisionUpdateWithoutBudgetInput, BudgetRevisionUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetRevisionUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetRevisionScalarWhereInput
    data: XOR<BudgetRevisionUpdateManyMutationInput, BudgetRevisionUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetRevisionScalarWhereInput = {
    AND?: BudgetRevisionScalarWhereInput | BudgetRevisionScalarWhereInput[]
    OR?: BudgetRevisionScalarWhereInput[]
    NOT?: BudgetRevisionScalarWhereInput | BudgetRevisionScalarWhereInput[]
    id?: UuidFilter<"BudgetRevision"> | string
    budgetId?: UuidFilter<"BudgetRevision"> | string
    revisionNo?: IntFilter<"BudgetRevision"> | number
    revisionReason?: StringNullableFilter<"BudgetRevision"> | string | null
    createdAt?: DateTimeFilter<"BudgetRevision"> | Date | string
    createdBy?: UuidNullableFilter<"BudgetRevision"> | string | null
  }

  export type BudgetCreateWithoutRevisionsInput = {
    id?: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutRevisionsInput = {
    id?: string
    companyId: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type BudgetCreateOrConnectWithoutRevisionsInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutRevisionsInput, BudgetUncheckedCreateWithoutRevisionsInput>
  }

  export type BudgetLineCreateWithoutRevisionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    analytic: AnalyticAccountCreateNestedOneWithoutBudgetLinesInput
    gl?: GLAccountCreateNestedOneWithoutBudgetLinesInput
  }

  export type BudgetLineUncheckedCreateWithoutRevisionInput = {
    id?: string
    analyticAccountId: string
    glAccountId?: string | null
    amount: Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineCreateOrConnectWithoutRevisionInput = {
    where: BudgetLineWhereUniqueInput
    create: XOR<BudgetLineCreateWithoutRevisionInput, BudgetLineUncheckedCreateWithoutRevisionInput>
  }

  export type BudgetLineCreateManyRevisionInputEnvelope = {
    data: BudgetLineCreateManyRevisionInput | BudgetLineCreateManyRevisionInput[]
    skipDuplicates?: boolean
  }

  export type BudgetUpsertWithoutRevisionsInput = {
    update: XOR<BudgetUpdateWithoutRevisionsInput, BudgetUncheckedUpdateWithoutRevisionsInput>
    create: XOR<BudgetCreateWithoutRevisionsInput, BudgetUncheckedCreateWithoutRevisionsInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutRevisionsInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutRevisionsInput, BudgetUncheckedUpdateWithoutRevisionsInput>
  }

  export type BudgetUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BudgetLineUpsertWithWhereUniqueWithoutRevisionInput = {
    where: BudgetLineWhereUniqueInput
    update: XOR<BudgetLineUpdateWithoutRevisionInput, BudgetLineUncheckedUpdateWithoutRevisionInput>
    create: XOR<BudgetLineCreateWithoutRevisionInput, BudgetLineUncheckedCreateWithoutRevisionInput>
  }

  export type BudgetLineUpdateWithWhereUniqueWithoutRevisionInput = {
    where: BudgetLineWhereUniqueInput
    data: XOR<BudgetLineUpdateWithoutRevisionInput, BudgetLineUncheckedUpdateWithoutRevisionInput>
  }

  export type BudgetLineUpdateManyWithWhereWithoutRevisionInput = {
    where: BudgetLineScalarWhereInput
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyWithoutRevisionInput>
  }

  export type BudgetRevisionCreateWithoutLinesInput = {
    id?: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    budget: BudgetCreateNestedOneWithoutRevisionsInput
  }

  export type BudgetRevisionUncheckedCreateWithoutLinesInput = {
    id?: string
    budgetId: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type BudgetRevisionCreateOrConnectWithoutLinesInput = {
    where: BudgetRevisionWhereUniqueInput
    create: XOR<BudgetRevisionCreateWithoutLinesInput, BudgetRevisionUncheckedCreateWithoutLinesInput>
  }

  export type AnalyticAccountCreateWithoutBudgetLinesInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutBudgetLinesInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutBudgetLinesInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutBudgetLinesInput, AnalyticAccountUncheckedCreateWithoutBudgetLinesInput>
  }

  export type GLAccountCreateWithoutBudgetLinesInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    company: CompanyCreateNestedOneWithoutGlAccountsInput
    journalLines?: JournalLineCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutGlInput
  }

  export type GLAccountUncheckedCreateWithoutBudgetLinesInput = {
    id?: string
    companyId: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutGlInput
  }

  export type GLAccountCreateOrConnectWithoutBudgetLinesInput = {
    where: GLAccountWhereUniqueInput
    create: XOR<GLAccountCreateWithoutBudgetLinesInput, GLAccountUncheckedCreateWithoutBudgetLinesInput>
  }

  export type BudgetRevisionUpsertWithoutLinesInput = {
    update: XOR<BudgetRevisionUpdateWithoutLinesInput, BudgetRevisionUncheckedUpdateWithoutLinesInput>
    create: XOR<BudgetRevisionCreateWithoutLinesInput, BudgetRevisionUncheckedCreateWithoutLinesInput>
    where?: BudgetRevisionWhereInput
  }

  export type BudgetRevisionUpdateToOneWithWhereWithoutLinesInput = {
    where?: BudgetRevisionWhereInput
    data: XOR<BudgetRevisionUpdateWithoutLinesInput, BudgetRevisionUncheckedUpdateWithoutLinesInput>
  }

  export type BudgetRevisionUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: BudgetUpdateOneRequiredWithoutRevisionsNestedInput
  }

  export type BudgetRevisionUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticAccountUpsertWithoutBudgetLinesInput = {
    update: XOR<AnalyticAccountUpdateWithoutBudgetLinesInput, AnalyticAccountUncheckedUpdateWithoutBudgetLinesInput>
    create: XOR<AnalyticAccountCreateWithoutBudgetLinesInput, AnalyticAccountUncheckedCreateWithoutBudgetLinesInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutBudgetLinesInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutBudgetLinesInput, AnalyticAccountUncheckedUpdateWithoutBudgetLinesInput>
  }

  export type AnalyticAccountUpdateWithoutBudgetLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutBudgetLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type GLAccountUpsertWithoutBudgetLinesInput = {
    update: XOR<GLAccountUpdateWithoutBudgetLinesInput, GLAccountUncheckedUpdateWithoutBudgetLinesInput>
    create: XOR<GLAccountCreateWithoutBudgetLinesInput, GLAccountUncheckedCreateWithoutBudgetLinesInput>
    where?: GLAccountWhereInput
  }

  export type GLAccountUpdateToOneWithWhereWithoutBudgetLinesInput = {
    where?: GLAccountWhereInput
    data: XOR<GLAccountUpdateWithoutBudgetLinesInput, GLAccountUncheckedUpdateWithoutBudgetLinesInput>
  }

  export type GLAccountUpdateWithoutBudgetLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneRequiredWithoutGlAccountsNestedInput
    journalLines?: JournalLineUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutGlNestedInput
  }

  export type GLAccountUncheckedUpdateWithoutBudgetLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUncheckedUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutGlNestedInput
  }

  export type CompanyCreateWithoutAutoAnalyticModelsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAutoAnalyticModelsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAutoAnalyticModelsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAutoAnalyticModelsInput, CompanyUncheckedCreateWithoutAutoAnalyticModelsInput>
  }

  export type AutoAnalyticRuleCreateWithoutModelInput = {
    id?: string
    docType: $Enums.AutoDocType
    rulePriority?: number
    isActive?: boolean
    product?: ProductCreateNestedOneWithoutAutoAnalyticRulesInput
    category?: ProductCategoryCreateNestedOneWithoutAutoAnalyticRulesInput
    contact?: ContactCreateNestedOneWithoutAutoAnalyticRulesInput
    assignAnalytic: AnalyticAccountCreateNestedOneWithoutAutoAnalyticRulesInput
  }

  export type AutoAnalyticRuleUncheckedCreateWithoutModelInput = {
    id?: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleCreateOrConnectWithoutModelInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    create: XOR<AutoAnalyticRuleCreateWithoutModelInput, AutoAnalyticRuleUncheckedCreateWithoutModelInput>
  }

  export type AutoAnalyticRuleCreateManyModelInputEnvelope = {
    data: AutoAnalyticRuleCreateManyModelInput | AutoAnalyticRuleCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutAutoAnalyticModelsInput = {
    update: XOR<CompanyUpdateWithoutAutoAnalyticModelsInput, CompanyUncheckedUpdateWithoutAutoAnalyticModelsInput>
    create: XOR<CompanyCreateWithoutAutoAnalyticModelsInput, CompanyUncheckedCreateWithoutAutoAnalyticModelsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAutoAnalyticModelsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAutoAnalyticModelsInput, CompanyUncheckedUpdateWithoutAutoAnalyticModelsInput>
  }

  export type CompanyUpdateWithoutAutoAnalyticModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAutoAnalyticModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AutoAnalyticRuleUpsertWithWhereUniqueWithoutModelInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    update: XOR<AutoAnalyticRuleUpdateWithoutModelInput, AutoAnalyticRuleUncheckedUpdateWithoutModelInput>
    create: XOR<AutoAnalyticRuleCreateWithoutModelInput, AutoAnalyticRuleUncheckedCreateWithoutModelInput>
  }

  export type AutoAnalyticRuleUpdateWithWhereUniqueWithoutModelInput = {
    where: AutoAnalyticRuleWhereUniqueInput
    data: XOR<AutoAnalyticRuleUpdateWithoutModelInput, AutoAnalyticRuleUncheckedUpdateWithoutModelInput>
  }

  export type AutoAnalyticRuleUpdateManyWithWhereWithoutModelInput = {
    where: AutoAnalyticRuleScalarWhereInput
    data: XOR<AutoAnalyticRuleUpdateManyMutationInput, AutoAnalyticRuleUncheckedUpdateManyWithoutModelInput>
  }

  export type AutoAnalyticModelCreateWithoutRulesInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAutoAnalyticModelsInput
  }

  export type AutoAnalyticModelUncheckedCreateWithoutRulesInput = {
    id?: string
    companyId: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AutoAnalyticModelCreateOrConnectWithoutRulesInput = {
    where: AutoAnalyticModelWhereUniqueInput
    create: XOR<AutoAnalyticModelCreateWithoutRulesInput, AutoAnalyticModelUncheckedCreateWithoutRulesInput>
  }

  export type ProductCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAutoAnalyticRulesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAutoAnalyticRulesInput, ProductUncheckedCreateWithoutAutoAnalyticRulesInput>
  }

  export type ProductCategoryCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    name: string
    company: CompanyCreateNestedOneWithoutProductCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    companyId: string
    name: string
    parentId?: string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutAutoAnalyticRulesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutAutoAnalyticRulesInput, ProductCategoryUncheckedCreateWithoutAutoAnalyticRulesInput>
  }

  export type ContactCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutAutoAnalyticRulesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutAutoAnalyticRulesInput, ContactUncheckedCreateWithoutAutoAnalyticRulesInput>
  }

  export type AnalyticAccountCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutAutoAnalyticRulesInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutAutoAnalyticRulesInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutAutoAnalyticRulesInput, AnalyticAccountUncheckedCreateWithoutAutoAnalyticRulesInput>
  }

  export type AutoAnalyticModelUpsertWithoutRulesInput = {
    update: XOR<AutoAnalyticModelUpdateWithoutRulesInput, AutoAnalyticModelUncheckedUpdateWithoutRulesInput>
    create: XOR<AutoAnalyticModelCreateWithoutRulesInput, AutoAnalyticModelUncheckedCreateWithoutRulesInput>
    where?: AutoAnalyticModelWhereInput
  }

  export type AutoAnalyticModelUpdateToOneWithWhereWithoutRulesInput = {
    where?: AutoAnalyticModelWhereInput
    data: XOR<AutoAnalyticModelUpdateWithoutRulesInput, AutoAnalyticModelUncheckedUpdateWithoutRulesInput>
  }

  export type AutoAnalyticModelUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAutoAnalyticModelsNestedInput
  }

  export type AutoAnalyticModelUncheckedUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutAutoAnalyticRulesInput = {
    update: XOR<ProductUpdateWithoutAutoAnalyticRulesInput, ProductUncheckedUpdateWithoutAutoAnalyticRulesInput>
    create: XOR<ProductCreateWithoutAutoAnalyticRulesInput, ProductUncheckedCreateWithoutAutoAnalyticRulesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAutoAnalyticRulesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAutoAnalyticRulesInput, ProductUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type ProductUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCategoryUpsertWithoutAutoAnalyticRulesInput = {
    update: XOR<ProductCategoryUpdateWithoutAutoAnalyticRulesInput, ProductCategoryUncheckedUpdateWithoutAutoAnalyticRulesInput>
    create: XOR<ProductCategoryCreateWithoutAutoAnalyticRulesInput, ProductCategoryUncheckedCreateWithoutAutoAnalyticRulesInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutAutoAnalyticRulesInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutAutoAnalyticRulesInput, ProductCategoryUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type ProductCategoryUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ContactUpsertWithoutAutoAnalyticRulesInput = {
    update: XOR<ContactUpdateWithoutAutoAnalyticRulesInput, ContactUncheckedUpdateWithoutAutoAnalyticRulesInput>
    create: XOR<ContactCreateWithoutAutoAnalyticRulesInput, ContactUncheckedCreateWithoutAutoAnalyticRulesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutAutoAnalyticRulesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutAutoAnalyticRulesInput, ContactUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type ContactUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
  }

  export type AnalyticAccountUpsertWithoutAutoAnalyticRulesInput = {
    update: XOR<AnalyticAccountUpdateWithoutAutoAnalyticRulesInput, AnalyticAccountUncheckedUpdateWithoutAutoAnalyticRulesInput>
    create: XOR<AnalyticAccountCreateWithoutAutoAnalyticRulesInput, AnalyticAccountUncheckedCreateWithoutAutoAnalyticRulesInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutAutoAnalyticRulesInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutAutoAnalyticRulesInput, AnalyticAccountUncheckedUpdateWithoutAutoAnalyticRulesInput>
  }

  export type AnalyticAccountUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutAutoAnalyticRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
  }

  export type CompanyCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPurchaseOrdersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type ContactCreateWithoutVendorPurchaseOrdersInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutVendorPurchaseOrdersInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutVendorPurchaseOrdersInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutVendorPurchaseOrdersInput, ContactUncheckedCreateWithoutVendorPurchaseOrdersInput>
  }

  export type PurchaseOrderLineCreateWithoutPurchaseOrderInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    product: ProductCreateNestedOneWithoutPoLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutPoLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderLineCreateManyPurchaseOrderInput | PurchaseOrderLineCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillCreateWithoutPoInput = {
    id?: string
    billNo: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutVendorBillsInput
    vendor: ContactCreateNestedOneWithoutVendorBillsInput
    lines?: VendorBillLineCreateNestedManyWithoutBillInput
  }

  export type VendorBillUncheckedCreateWithoutPoInput = {
    id?: string
    companyId: string
    billNo: string
    vendorId: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    lines?: VendorBillLineUncheckedCreateNestedManyWithoutBillInput
  }

  export type VendorBillCreateOrConnectWithoutPoInput = {
    where: VendorBillWhereUniqueInput
    create: XOR<VendorBillCreateWithoutPoInput, VendorBillUncheckedCreateWithoutPoInput>
  }

  export type VendorBillCreateManyPoInputEnvelope = {
    data: VendorBillCreateManyPoInput | VendorBillCreateManyPoInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPurchaseOrdersInput = {
    update: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type CompanyUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactUpsertWithoutVendorPurchaseOrdersInput = {
    update: XOR<ContactUpdateWithoutVendorPurchaseOrdersInput, ContactUncheckedUpdateWithoutVendorPurchaseOrdersInput>
    create: XOR<ContactCreateWithoutVendorPurchaseOrdersInput, ContactUncheckedCreateWithoutVendorPurchaseOrdersInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutVendorPurchaseOrdersInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutVendorPurchaseOrdersInput, ContactUncheckedUpdateWithoutVendorPurchaseOrdersInput>
  }

  export type ContactUpdateWithoutVendorPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutVendorPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type VendorBillUpsertWithWhereUniqueWithoutPoInput = {
    where: VendorBillWhereUniqueInput
    update: XOR<VendorBillUpdateWithoutPoInput, VendorBillUncheckedUpdateWithoutPoInput>
    create: XOR<VendorBillCreateWithoutPoInput, VendorBillUncheckedCreateWithoutPoInput>
  }

  export type VendorBillUpdateWithWhereUniqueWithoutPoInput = {
    where: VendorBillWhereUniqueInput
    data: XOR<VendorBillUpdateWithoutPoInput, VendorBillUncheckedUpdateWithoutPoInput>
  }

  export type VendorBillUpdateManyWithWhereWithoutPoInput = {
    where: VendorBillScalarWhereInput
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyWithoutPoInput>
  }

  export type PurchaseOrderCreateWithoutLinesInput = {
    id?: string
    poNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    vendor: ContactCreateNestedOneWithoutVendorPurchaseOrdersInput
    bills?: VendorBillCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutLinesInput = {
    id?: string
    companyId: string
    poNo: string
    vendorId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    bills?: VendorBillUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutLinesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutPoLinesInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPoLinesInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPoLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPoLinesInput, ProductUncheckedCreateWithoutPoLinesInput>
  }

  export type AnalyticAccountCreateWithoutPoLinesInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutPoLinesInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutPoLinesInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutPoLinesInput, AnalyticAccountUncheckedCreateWithoutPoLinesInput>
  }

  export type PurchaseOrderUpsertWithoutLinesInput = {
    update: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type PurchaseOrderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    vendor?: ContactUpdateOneRequiredWithoutVendorPurchaseOrdersNestedInput
    bills?: VendorBillUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: VendorBillUncheckedUpdateManyWithoutPoNestedInput
  }

  export type ProductUpsertWithoutPoLinesInput = {
    update: XOR<ProductUpdateWithoutPoLinesInput, ProductUncheckedUpdateWithoutPoLinesInput>
    create: XOR<ProductCreateWithoutPoLinesInput, ProductUncheckedCreateWithoutPoLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPoLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPoLinesInput, ProductUncheckedUpdateWithoutPoLinesInput>
  }

  export type ProductUpdateWithoutPoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AnalyticAccountUpsertWithoutPoLinesInput = {
    update: XOR<AnalyticAccountUpdateWithoutPoLinesInput, AnalyticAccountUncheckedUpdateWithoutPoLinesInput>
    create: XOR<AnalyticAccountCreateWithoutPoLinesInput, AnalyticAccountUncheckedCreateWithoutPoLinesInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutPoLinesInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutPoLinesInput, AnalyticAccountUncheckedUpdateWithoutPoLinesInput>
  }

  export type AnalyticAccountUpdateWithoutPoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutPoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type CompanyCreateWithoutSalesOrdersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSalesOrdersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSalesOrdersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSalesOrdersInput, CompanyUncheckedCreateWithoutSalesOrdersInput>
  }

  export type ContactCreateWithoutCustomerSalesOrdersInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCustomerSalesOrdersInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCustomerSalesOrdersInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCustomerSalesOrdersInput, ContactUncheckedCreateWithoutCustomerSalesOrdersInput>
  }

  export type SalesOrderLineCreateWithoutSalesOrderInput = {
    id?: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    product: ProductCreateNestedOneWithoutSoLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutSoLinesInput
  }

  export type SalesOrderLineUncheckedCreateWithoutSalesOrderInput = {
    id?: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutSalesOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesOrderLineCreateManySalesOrderInputEnvelope = {
    data: SalesOrderLineCreateManySalesOrderInput | SalesOrderLineCreateManySalesOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerInvoiceCreateWithoutSoInput = {
    id?: string
    invoiceNo: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCustomerInvoicesInput
    customer: ContactCreateNestedOneWithoutCustomerInvoicesInput
    lines?: CustomerInvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceUncheckedCreateWithoutSoInput = {
    id?: string
    companyId: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    lines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceCreateOrConnectWithoutSoInput = {
    where: CustomerInvoiceWhereUniqueInput
    create: XOR<CustomerInvoiceCreateWithoutSoInput, CustomerInvoiceUncheckedCreateWithoutSoInput>
  }

  export type CustomerInvoiceCreateManySoInputEnvelope = {
    data: CustomerInvoiceCreateManySoInput | CustomerInvoiceCreateManySoInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutSalesOrdersInput = {
    update: XOR<CompanyUpdateWithoutSalesOrdersInput, CompanyUncheckedUpdateWithoutSalesOrdersInput>
    create: XOR<CompanyCreateWithoutSalesOrdersInput, CompanyUncheckedCreateWithoutSalesOrdersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSalesOrdersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSalesOrdersInput, CompanyUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type CompanyUpdateWithoutSalesOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSalesOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactUpsertWithoutCustomerSalesOrdersInput = {
    update: XOR<ContactUpdateWithoutCustomerSalesOrdersInput, ContactUncheckedUpdateWithoutCustomerSalesOrdersInput>
    create: XOR<ContactCreateWithoutCustomerSalesOrdersInput, ContactUncheckedCreateWithoutCustomerSalesOrdersInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutCustomerSalesOrdersInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutCustomerSalesOrdersInput, ContactUncheckedUpdateWithoutCustomerSalesOrdersInput>
  }

  export type ContactUpdateWithoutCustomerSalesOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCustomerSalesOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutSalesOrderInput, SalesOrderLineUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutSalesOrderInput, SalesOrderLineUncheckedUpdateWithoutSalesOrderInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type CustomerInvoiceUpsertWithWhereUniqueWithoutSoInput = {
    where: CustomerInvoiceWhereUniqueInput
    update: XOR<CustomerInvoiceUpdateWithoutSoInput, CustomerInvoiceUncheckedUpdateWithoutSoInput>
    create: XOR<CustomerInvoiceCreateWithoutSoInput, CustomerInvoiceUncheckedCreateWithoutSoInput>
  }

  export type CustomerInvoiceUpdateWithWhereUniqueWithoutSoInput = {
    where: CustomerInvoiceWhereUniqueInput
    data: XOR<CustomerInvoiceUpdateWithoutSoInput, CustomerInvoiceUncheckedUpdateWithoutSoInput>
  }

  export type CustomerInvoiceUpdateManyWithWhereWithoutSoInput = {
    where: CustomerInvoiceScalarWhereInput
    data: XOR<CustomerInvoiceUpdateManyMutationInput, CustomerInvoiceUncheckedUpdateManyWithoutSoInput>
  }

  export type SalesOrderCreateWithoutLinesInput = {
    id?: string
    soNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutSalesOrdersInput
    customer: ContactCreateNestedOneWithoutCustomerSalesOrdersInput
    invoices?: CustomerInvoiceCreateNestedManyWithoutSoInput
  }

  export type SalesOrderUncheckedCreateWithoutLinesInput = {
    id?: string
    companyId: string
    soNo: string
    customerId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    invoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutSoInput
  }

  export type SalesOrderCreateOrConnectWithoutLinesInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutSoLinesInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSoLinesInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSoLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSoLinesInput, ProductUncheckedCreateWithoutSoLinesInput>
  }

  export type AnalyticAccountCreateWithoutSoLinesInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutSoLinesInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutSoLinesInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutSoLinesInput, AnalyticAccountUncheckedCreateWithoutSoLinesInput>
  }

  export type SalesOrderUpsertWithoutLinesInput = {
    update: XOR<SalesOrderUpdateWithoutLinesInput, SalesOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutLinesInput, SalesOrderUncheckedUpdateWithoutLinesInput>
  }

  export type SalesOrderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSalesOrdersNestedInput
    customer?: ContactUpdateOneRequiredWithoutCustomerSalesOrdersNestedInput
    invoices?: CustomerInvoiceUpdateManyWithoutSoNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: CustomerInvoiceUncheckedUpdateManyWithoutSoNestedInput
  }

  export type ProductUpsertWithoutSoLinesInput = {
    update: XOR<ProductUpdateWithoutSoLinesInput, ProductUncheckedUpdateWithoutSoLinesInput>
    create: XOR<ProductCreateWithoutSoLinesInput, ProductUncheckedCreateWithoutSoLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSoLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSoLinesInput, ProductUncheckedUpdateWithoutSoLinesInput>
  }

  export type ProductUpdateWithoutSoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AnalyticAccountUpsertWithoutSoLinesInput = {
    update: XOR<AnalyticAccountUpdateWithoutSoLinesInput, AnalyticAccountUncheckedUpdateWithoutSoLinesInput>
    create: XOR<AnalyticAccountCreateWithoutSoLinesInput, AnalyticAccountUncheckedCreateWithoutSoLinesInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutSoLinesInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutSoLinesInput, AnalyticAccountUncheckedUpdateWithoutSoLinesInput>
  }

  export type AnalyticAccountUpdateWithoutSoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutSoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type CompanyCreateWithoutVendorBillsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVendorBillsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVendorBillsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVendorBillsInput, CompanyUncheckedCreateWithoutVendorBillsInput>
  }

  export type ContactCreateWithoutVendorBillsInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutVendorBillsInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutVendorBillsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutVendorBillsInput, ContactUncheckedCreateWithoutVendorBillsInput>
  }

  export type PurchaseOrderCreateWithoutBillsInput = {
    id?: string
    poNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    vendor: ContactCreateNestedOneWithoutVendorPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutBillsInput = {
    id?: string
    companyId: string
    poNo: string
    vendorId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutBillsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutBillsInput, PurchaseOrderUncheckedCreateWithoutBillsInput>
  }

  export type VendorBillLineCreateWithoutBillInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    product?: ProductCreateNestedOneWithoutBillLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutBillLinesInput
    gl?: GLAccountCreateNestedOneWithoutBillLinesInput
  }

  export type VendorBillLineUncheckedCreateWithoutBillInput = {
    id?: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateOrConnectWithoutBillInput = {
    where: VendorBillLineWhereUniqueInput
    create: XOR<VendorBillLineCreateWithoutBillInput, VendorBillLineUncheckedCreateWithoutBillInput>
  }

  export type VendorBillLineCreateManyBillInputEnvelope = {
    data: VendorBillLineCreateManyBillInput | VendorBillLineCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutVendorBillsInput = {
    update: XOR<CompanyUpdateWithoutVendorBillsInput, CompanyUncheckedUpdateWithoutVendorBillsInput>
    create: XOR<CompanyCreateWithoutVendorBillsInput, CompanyUncheckedCreateWithoutVendorBillsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVendorBillsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVendorBillsInput, CompanyUncheckedUpdateWithoutVendorBillsInput>
  }

  export type CompanyUpdateWithoutVendorBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVendorBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactUpsertWithoutVendorBillsInput = {
    update: XOR<ContactUpdateWithoutVendorBillsInput, ContactUncheckedUpdateWithoutVendorBillsInput>
    create: XOR<ContactCreateWithoutVendorBillsInput, ContactUncheckedCreateWithoutVendorBillsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutVendorBillsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutVendorBillsInput, ContactUncheckedUpdateWithoutVendorBillsInput>
  }

  export type ContactUpdateWithoutVendorBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutVendorBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type PurchaseOrderUpsertWithoutBillsInput = {
    update: XOR<PurchaseOrderUpdateWithoutBillsInput, PurchaseOrderUncheckedUpdateWithoutBillsInput>
    create: XOR<PurchaseOrderCreateWithoutBillsInput, PurchaseOrderUncheckedCreateWithoutBillsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutBillsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutBillsInput, PurchaseOrderUncheckedUpdateWithoutBillsInput>
  }

  export type PurchaseOrderUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    vendor?: ContactUpdateOneRequiredWithoutVendorPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type VendorBillLineUpsertWithWhereUniqueWithoutBillInput = {
    where: VendorBillLineWhereUniqueInput
    update: XOR<VendorBillLineUpdateWithoutBillInput, VendorBillLineUncheckedUpdateWithoutBillInput>
    create: XOR<VendorBillLineCreateWithoutBillInput, VendorBillLineUncheckedCreateWithoutBillInput>
  }

  export type VendorBillLineUpdateWithWhereUniqueWithoutBillInput = {
    where: VendorBillLineWhereUniqueInput
    data: XOR<VendorBillLineUpdateWithoutBillInput, VendorBillLineUncheckedUpdateWithoutBillInput>
  }

  export type VendorBillLineUpdateManyWithWhereWithoutBillInput = {
    where: VendorBillLineScalarWhereInput
    data: XOR<VendorBillLineUpdateManyMutationInput, VendorBillLineUncheckedUpdateManyWithoutBillInput>
  }

  export type VendorBillCreateWithoutLinesInput = {
    id?: string
    billNo: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutVendorBillsInput
    vendor: ContactCreateNestedOneWithoutVendorBillsInput
    po?: PurchaseOrderCreateNestedOneWithoutBillsInput
  }

  export type VendorBillUncheckedCreateWithoutLinesInput = {
    id?: string
    companyId: string
    billNo: string
    vendorId: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    poId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
  }

  export type VendorBillCreateOrConnectWithoutLinesInput = {
    where: VendorBillWhereUniqueInput
    create: XOR<VendorBillCreateWithoutLinesInput, VendorBillUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutBillLinesInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBillLinesInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBillLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBillLinesInput, ProductUncheckedCreateWithoutBillLinesInput>
  }

  export type AnalyticAccountCreateWithoutBillLinesInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutBillLinesInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutBillLinesInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutBillLinesInput, AnalyticAccountUncheckedCreateWithoutBillLinesInput>
  }

  export type GLAccountCreateWithoutBillLinesInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    company: CompanyCreateNestedOneWithoutGlAccountsInput
    journalLines?: JournalLineCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineCreateNestedManyWithoutGlInput
  }

  export type GLAccountUncheckedCreateWithoutBillLinesInput = {
    id?: string
    companyId: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutGlInput
    invLines?: CustomerInvoiceLineUncheckedCreateNestedManyWithoutGlInput
  }

  export type GLAccountCreateOrConnectWithoutBillLinesInput = {
    where: GLAccountWhereUniqueInput
    create: XOR<GLAccountCreateWithoutBillLinesInput, GLAccountUncheckedCreateWithoutBillLinesInput>
  }

  export type VendorBillUpsertWithoutLinesInput = {
    update: XOR<VendorBillUpdateWithoutLinesInput, VendorBillUncheckedUpdateWithoutLinesInput>
    create: XOR<VendorBillCreateWithoutLinesInput, VendorBillUncheckedCreateWithoutLinesInput>
    where?: VendorBillWhereInput
  }

  export type VendorBillUpdateToOneWithWhereWithoutLinesInput = {
    where?: VendorBillWhereInput
    data: XOR<VendorBillUpdateWithoutLinesInput, VendorBillUncheckedUpdateWithoutLinesInput>
  }

  export type VendorBillUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVendorBillsNestedInput
    vendor?: ContactUpdateOneRequiredWithoutVendorBillsNestedInput
    po?: PurchaseOrderUpdateOneWithoutBillsNestedInput
  }

  export type VendorBillUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutBillLinesInput = {
    update: XOR<ProductUpdateWithoutBillLinesInput, ProductUncheckedUpdateWithoutBillLinesInput>
    create: XOR<ProductCreateWithoutBillLinesInput, ProductUncheckedCreateWithoutBillLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBillLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBillLinesInput, ProductUncheckedUpdateWithoutBillLinesInput>
  }

  export type ProductUpdateWithoutBillLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBillLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AnalyticAccountUpsertWithoutBillLinesInput = {
    update: XOR<AnalyticAccountUpdateWithoutBillLinesInput, AnalyticAccountUncheckedUpdateWithoutBillLinesInput>
    create: XOR<AnalyticAccountCreateWithoutBillLinesInput, AnalyticAccountUncheckedCreateWithoutBillLinesInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutBillLinesInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutBillLinesInput, AnalyticAccountUncheckedUpdateWithoutBillLinesInput>
  }

  export type AnalyticAccountUpdateWithoutBillLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutBillLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type GLAccountUpsertWithoutBillLinesInput = {
    update: XOR<GLAccountUpdateWithoutBillLinesInput, GLAccountUncheckedUpdateWithoutBillLinesInput>
    create: XOR<GLAccountCreateWithoutBillLinesInput, GLAccountUncheckedCreateWithoutBillLinesInput>
    where?: GLAccountWhereInput
  }

  export type GLAccountUpdateToOneWithWhereWithoutBillLinesInput = {
    where?: GLAccountWhereInput
    data: XOR<GLAccountUpdateWithoutBillLinesInput, GLAccountUncheckedUpdateWithoutBillLinesInput>
  }

  export type GLAccountUpdateWithoutBillLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneRequiredWithoutGlAccountsNestedInput
    journalLines?: JournalLineUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutGlNestedInput
  }

  export type GLAccountUncheckedUpdateWithoutBillLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUncheckedUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutGlNestedInput
  }

  export type CompanyCreateWithoutCustomerInvoicesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCustomerInvoicesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCustomerInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCustomerInvoicesInput, CompanyUncheckedCreateWithoutCustomerInvoicesInput>
  }

  export type ContactCreateWithoutCustomerInvoicesInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    payments?: PaymentCreateNestedManyWithoutContactInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCustomerInvoicesInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContactInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCustomerInvoicesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCustomerInvoicesInput, ContactUncheckedCreateWithoutCustomerInvoicesInput>
  }

  export type SalesOrderCreateWithoutInvoicesInput = {
    id?: string
    soNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutSalesOrdersInput
    customer: ContactCreateNestedOneWithoutCustomerSalesOrdersInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutInvoicesInput = {
    id?: string
    companyId: string
    soNo: string
    customerId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutInvoicesInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
  }

  export type CustomerInvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    product?: ProductCreateNestedOneWithoutInvLinesInput
    analytic?: AnalyticAccountCreateNestedOneWithoutInvLinesInput
    gl?: GLAccountCreateNestedOneWithoutInvLinesInput
  }

  export type CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    create: XOR<CustomerInvoiceLineCreateWithoutInvoiceInput, CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerInvoiceLineCreateManyInvoiceInputEnvelope = {
    data: CustomerInvoiceLineCreateManyInvoiceInput | CustomerInvoiceLineCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutCustomerInvoicesInput = {
    update: XOR<CompanyUpdateWithoutCustomerInvoicesInput, CompanyUncheckedUpdateWithoutCustomerInvoicesInput>
    create: XOR<CompanyCreateWithoutCustomerInvoicesInput, CompanyUncheckedCreateWithoutCustomerInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCustomerInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCustomerInvoicesInput, CompanyUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type CompanyUpdateWithoutCustomerInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCustomerInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactUpsertWithoutCustomerInvoicesInput = {
    update: XOR<ContactUpdateWithoutCustomerInvoicesInput, ContactUncheckedUpdateWithoutCustomerInvoicesInput>
    create: XOR<ContactCreateWithoutCustomerInvoicesInput, ContactUncheckedCreateWithoutCustomerInvoicesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutCustomerInvoicesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutCustomerInvoicesInput, ContactUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type ContactUpdateWithoutCustomerInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCustomerInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type SalesOrderUpsertWithoutInvoicesInput = {
    update: XOR<SalesOrderUpdateWithoutInvoicesInput, SalesOrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutInvoicesInput, SalesOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type SalesOrderUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSalesOrdersNestedInput
    customer?: ContactUpdateOneRequiredWithoutCustomerSalesOrdersNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type CustomerInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    update: XOR<CustomerInvoiceLineUpdateWithoutInvoiceInput, CustomerInvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<CustomerInvoiceLineCreateWithoutInvoiceInput, CustomerInvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: CustomerInvoiceLineWhereUniqueInput
    data: XOR<CustomerInvoiceLineUpdateWithoutInvoiceInput, CustomerInvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type CustomerInvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: CustomerInvoiceLineScalarWhereInput
    data: XOR<CustomerInvoiceLineUpdateManyMutationInput, CustomerInvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type CustomerInvoiceCreateWithoutLinesInput = {
    id?: string
    invoiceNo: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCustomerInvoicesInput
    customer: ContactCreateNestedOneWithoutCustomerInvoicesInput
    so?: SalesOrderCreateNestedOneWithoutInvoicesInput
  }

  export type CustomerInvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    companyId: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    soId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
  }

  export type CustomerInvoiceCreateOrConnectWithoutLinesInput = {
    where: CustomerInvoiceWhereUniqueInput
    create: XOR<CustomerInvoiceCreateWithoutLinesInput, CustomerInvoiceUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutInvLinesInput = {
    id?: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineCreateNestedManyWithoutProductInput
    journalLines?: JournalLineCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInvLinesInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutProductInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutProductInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutProductInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInvLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInvLinesInput, ProductUncheckedCreateWithoutInvLinesInput>
  }

  export type AnalyticAccountCreateWithoutInvLinesInput = {
    id?: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnalyticAccountsInput
    parent?: AnalyticAccountCreateNestedOneWithoutChildrenInput
    children?: AnalyticAccountCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountUncheckedCreateWithoutInvLinesInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: AnalyticAccountUncheckedCreateNestedManyWithoutParentInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutAnalyticInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAnalyticInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutAnalyticInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutAnalyticInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutAssignAnalyticInput
  }

  export type AnalyticAccountCreateOrConnectWithoutInvLinesInput = {
    where: AnalyticAccountWhereUniqueInput
    create: XOR<AnalyticAccountCreateWithoutInvLinesInput, AnalyticAccountUncheckedCreateWithoutInvLinesInput>
  }

  export type GLAccountCreateWithoutInvLinesInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    company: CompanyCreateNestedOneWithoutGlAccountsInput
    journalLines?: JournalLineCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineCreateNestedManyWithoutGlInput
  }

  export type GLAccountUncheckedCreateWithoutInvLinesInput = {
    id?: string
    companyId: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutGlInput
    budgetLines?: BudgetLineUncheckedCreateNestedManyWithoutGlInput
    billLines?: VendorBillLineUncheckedCreateNestedManyWithoutGlInput
  }

  export type GLAccountCreateOrConnectWithoutInvLinesInput = {
    where: GLAccountWhereUniqueInput
    create: XOR<GLAccountCreateWithoutInvLinesInput, GLAccountUncheckedCreateWithoutInvLinesInput>
  }

  export type CustomerInvoiceUpsertWithoutLinesInput = {
    update: XOR<CustomerInvoiceUpdateWithoutLinesInput, CustomerInvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<CustomerInvoiceCreateWithoutLinesInput, CustomerInvoiceUncheckedCreateWithoutLinesInput>
    where?: CustomerInvoiceWhereInput
  }

  export type CustomerInvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: CustomerInvoiceWhereInput
    data: XOR<CustomerInvoiceUpdateWithoutLinesInput, CustomerInvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type CustomerInvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    customer?: ContactUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    so?: SalesOrderUpdateOneWithoutInvoicesNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    soId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutInvLinesInput = {
    update: XOR<ProductUpdateWithoutInvLinesInput, ProductUncheckedUpdateWithoutInvLinesInput>
    create: XOR<ProductCreateWithoutInvLinesInput, ProductUncheckedCreateWithoutInvLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInvLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInvLinesInput, ProductUncheckedUpdateWithoutInvLinesInput>
  }

  export type ProductUpdateWithoutInvLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInvLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AnalyticAccountUpsertWithoutInvLinesInput = {
    update: XOR<AnalyticAccountUpdateWithoutInvLinesInput, AnalyticAccountUncheckedUpdateWithoutInvLinesInput>
    create: XOR<AnalyticAccountCreateWithoutInvLinesInput, AnalyticAccountUncheckedCreateWithoutInvLinesInput>
    where?: AnalyticAccountWhereInput
  }

  export type AnalyticAccountUpdateToOneWithWhereWithoutInvLinesInput = {
    where?: AnalyticAccountWhereInput
    data: XOR<AnalyticAccountUpdateWithoutInvLinesInput, AnalyticAccountUncheckedUpdateWithoutInvLinesInput>
  }

  export type AnalyticAccountUpdateWithoutInvLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutInvLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type GLAccountUpsertWithoutInvLinesInput = {
    update: XOR<GLAccountUpdateWithoutInvLinesInput, GLAccountUncheckedUpdateWithoutInvLinesInput>
    create: XOR<GLAccountCreateWithoutInvLinesInput, GLAccountUncheckedCreateWithoutInvLinesInput>
    where?: GLAccountWhereInput
  }

  export type GLAccountUpdateToOneWithWhereWithoutInvLinesInput = {
    where?: GLAccountWhereInput
    data: XOR<GLAccountUpdateWithoutInvLinesInput, GLAccountUncheckedUpdateWithoutInvLinesInput>
  }

  export type GLAccountUpdateWithoutInvLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneRequiredWithoutGlAccountsNestedInput
    journalLines?: JournalLineUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUpdateManyWithoutGlNestedInput
  }

  export type GLAccountUncheckedUpdateWithoutInvLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUncheckedUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutGlNestedInput
  }

  export type CompanyCreateWithoutPaymentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documentFiles?: DocumentFileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPaymentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
  }

  export type ContactCreateWithoutPaymentsInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    vendorPurchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCustomerInput
    journalLines?: JournalLineCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutPaymentsInput = {
    id?: string
    companyId: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    customerSalesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutContactInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutPaymentsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutPaymentsInput, ContactUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentAllocationCreateWithoutPaymentInput = {
    id?: string
    targetType: $Enums.AllocationTargetType
    targetId: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationUncheckedCreateWithoutPaymentInput = {
    id?: string
    targetType: $Enums.AllocationTargetType
    targetId: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationCreateOrConnectWithoutPaymentInput = {
    where: PaymentAllocationWhereUniqueInput
    create: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentAllocationCreateManyPaymentInputEnvelope = {
    data: PaymentAllocationCreateManyPaymentInput | PaymentAllocationCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPaymentsInput = {
    update: XOR<CompanyUpdateWithoutPaymentsInput, CompanyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPaymentsInput, CompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type CompanyUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documentFiles?: DocumentFileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactUpsertWithoutPaymentsInput = {
    update: XOR<ContactUpdateWithoutPaymentsInput, ContactUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ContactCreateWithoutPaymentsInput, ContactUncheckedCreateWithoutPaymentsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutPaymentsInput, ContactUncheckedUpdateWithoutPaymentsInput>
  }

  export type ContactUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PaymentAllocationWhereUniqueInput
    update: XOR<PaymentAllocationUpdateWithoutPaymentInput, PaymentAllocationUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PaymentAllocationWhereUniqueInput
    data: XOR<PaymentAllocationUpdateWithoutPaymentInput, PaymentAllocationUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentAllocationUpdateManyWithWhereWithoutPaymentInput = {
    where: PaymentAllocationScalarWhereInput
    data: XOR<PaymentAllocationUpdateManyMutationInput, PaymentAllocationUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentAllocationScalarWhereInput = {
    AND?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
    OR?: PaymentAllocationScalarWhereInput[]
    NOT?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
    id?: UuidFilter<"PaymentAllocation"> | string
    paymentId?: UuidFilter<"PaymentAllocation"> | string
    targetType?: EnumAllocationTargetTypeFilter<"PaymentAllocation"> | $Enums.AllocationTargetType
    targetId?: UuidFilter<"PaymentAllocation"> | string
    amount?: DecimalFilter<"PaymentAllocation"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateWithoutAllocationsInput = {
    id?: string
    direction: $Enums.PaymentDirection
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPaymentsInput
    contact: ContactCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutAllocationsInput = {
    id?: string
    companyId: string
    direction: $Enums.PaymentDirection
    contactId: string
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutAllocationsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
  }

  export type PaymentUpsertWithoutAllocationsInput = {
    update: XOR<PaymentUpdateWithoutAllocationsInput, PaymentUncheckedUpdateWithoutAllocationsInput>
    create: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutAllocationsInput, PaymentUncheckedUpdateWithoutAllocationsInput>
  }

  export type PaymentUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPaymentsNestedInput
    contact?: ContactUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    contactId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutDocumentFilesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryCreateNestedManyWithoutCompanyInput
    products?: ProductCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    budgets?: BudgetCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDocumentFilesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutCompanyInput
    products?: ProductUncheckedCreateNestedManyWithoutCompanyInput
    analyticAccounts?: AnalyticAccountUncheckedCreateNestedManyWithoutCompanyInput
    glAccounts?: GLAccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCompanyInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCompanyInput
    vendorBills?: VendorBillUncheckedCreateNestedManyWithoutCompanyInput
    customerInvoices?: CustomerInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDocumentFilesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDocumentFilesInput, CompanyUncheckedCreateWithoutDocumentFilesInput>
  }

  export type CompanyUpsertWithoutDocumentFilesInput = {
    update: XOR<CompanyUpdateWithoutDocumentFilesInput, CompanyUncheckedUpdateWithoutDocumentFilesInput>
    create: XOR<CompanyCreateWithoutDocumentFilesInput, CompanyUncheckedCreateWithoutDocumentFilesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDocumentFilesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDocumentFilesInput, CompanyUncheckedUpdateWithoutDocumentFilesInput>
  }

  export type CompanyUpdateWithoutDocumentFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutCompanyNestedInput
    products?: ProductUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDocumentFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    products?: ProductUncheckedUpdateManyWithoutCompanyNestedInput
    analyticAccounts?: AnalyticAccountUncheckedUpdateManyWithoutCompanyNestedInput
    glAccounts?: GLAccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCompanyNestedInput
    autoAnalyticModels?: AutoAnalyticModelUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCompanyNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutCompanyNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactCreateManyCompanyInput = {
    id?: string
    contactType: $Enums.ContactType
    displayName: string
    email?: string | null
    phone?: string | null
    gstin?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: boolean
    portalUserExternalId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateManyCompanyInput = {
    id?: string
    name: string
    parentId?: string | null
  }

  export type ProductCreateManyCompanyInput = {
    id?: string
    sku?: string | null
    name: string
    categoryId?: string | null
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticAccountCreateManyCompanyInput = {
    id?: string
    code?: string | null
    name: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GLAccountCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    accountType: $Enums.AccountType
    isActive?: boolean
  }

  export type JournalEntryCreateManyCompanyInput = {
    id?: string
    entryDate: Date | string
    status: $Enums.JournalStatus
    sourceType: $Enums.JournalSourceType
    sourceId?: string | null
    memo?: string | null
    createdAt?: Date | string
    postedAt?: Date | string | null
  }

  export type BudgetCreateManyCompanyInput = {
    id?: string
    name: string
    periodStart: Date | string
    periodEnd: Date | string
    status: $Enums.BudgetStatus
    createdBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type AutoAnalyticModelCreateManyCompanyInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PurchaseOrderCreateManyCompanyInput = {
    id?: string
    poNo: string
    vendorId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type SalesOrderCreateManyCompanyInput = {
    id?: string
    soNo: string
    customerId: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type VendorBillCreateManyCompanyInput = {
    id?: string
    billNo: string
    vendorId: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    poId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
  }

  export type CustomerInvoiceCreateManyCompanyInput = {
    id?: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    soId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
  }

  export type PaymentCreateManyCompanyInput = {
    id?: string
    direction: $Enums.PaymentDirection
    contactId: string
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type DocumentFileCreateManyCompanyInput = {
    id?: string
    ownerType: $Enums.DocOwnerType
    ownerId: string
    fileName: string
    mimeType: string
    storageUrl: string
    createdAt?: Date | string
  }

  export type ContactUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorPurchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    customerSalesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorBills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
    customerInvoices?: CustomerInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContactNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutContactNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    displayName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    isPortalUser?: BoolFieldUpdateOperationsInput | boolean
    portalUserExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticAccountUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: AnalyticAccountUpdateOneWithoutChildrenNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GLAccountUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutGlNestedInput
  }

  export type GLAccountUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUncheckedUpdateManyWithoutGlNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutGlNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutGlNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutGlNestedInput
  }

  export type GLAccountUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JournalEntryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: JournalLineUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: JournalLineUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    sourceType?: EnumJournalSourceTypeFieldUpdateOperationsInput | $Enums.JournalSourceType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BudgetUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: BudgetRevisionUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: BudgetRevisionUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoAnalyticModelUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutoAnalyticRuleUpdateManyWithoutModelNestedInput
  }

  export type AutoAnalyticModelUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutoAnalyticRuleUncheckedUpdateManyWithoutModelNestedInput
  }

  export type AutoAnalyticModelUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: ContactUpdateOneRequiredWithoutVendorPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    bills?: VendorBillUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    bills?: VendorBillUncheckedUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: ContactUpdateOneRequiredWithoutCustomerSalesOrdersNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    invoices?: CustomerInvoiceUpdateManyWithoutSoNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
    invoices?: CustomerInvoiceUncheckedUpdateManyWithoutSoNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: ContactUpdateOneRequiredWithoutVendorBillsNestedInput
    po?: PurchaseOrderUpdateOneWithoutBillsNestedInput
    lines?: VendorBillLineUpdateManyWithoutBillNestedInput
  }

  export type VendorBillUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: VendorBillLineUncheckedUpdateManyWithoutBillNestedInput
  }

  export type VendorBillUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: ContactUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    so?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    lines?: CustomerInvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    soId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: CustomerInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    soId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutPaymentsNestedInput
    allocations?: PaymentAllocationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    contactId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    contactId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentFileUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumDocOwnerTypeFieldUpdateOperationsInput | $Enums.DocOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    storageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentFileUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumDocOwnerTypeFieldUpdateOperationsInput | $Enums.DocOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    storageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentFileUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerType?: EnumDocOwnerTypeFieldUpdateOperationsInput | $Enums.DocOwnerType
    ownerId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    storageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManyVendorInput = {
    id?: string
    companyId: string
    poNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type SalesOrderCreateManyCustomerInput = {
    id?: string
    companyId: string
    soNo: string
    orderDate: Date | string
    status: $Enums.OrderStatus
    currency?: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type VendorBillCreateManyVendorInput = {
    id?: string
    companyId: string
    billNo: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    poId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
  }

  export type CustomerInvoiceCreateManyCustomerInput = {
    id?: string
    companyId: string
    invoiceNo: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    soId?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
  }

  export type PaymentCreateManyContactInput = {
    id?: string
    companyId: string
    direction: $Enums.PaymentDirection
    paymentDate: Date | string
    method: $Enums.PaymentMethod
    reference?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type JournalLineCreateManyContactInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    analyticAccountId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleCreateManyContactInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type PurchaseOrderUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    bills?: VendorBillUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    bills?: VendorBillUncheckedUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    poNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSalesOrdersNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    invoices?: CustomerInvoiceUpdateManyWithoutSoNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
    invoices?: CustomerInvoiceUncheckedUpdateManyWithoutSoNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    soNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVendorBillsNestedInput
    po?: PurchaseOrderUpdateOneWithoutBillsNestedInput
    lines?: VendorBillLineUpdateManyWithoutBillNestedInput
  }

  export type VendorBillUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: VendorBillLineUncheckedUpdateManyWithoutBillNestedInput
  }

  export type VendorBillUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    so?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    lines?: CustomerInvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    soId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: CustomerInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    soId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPaymentsNestedInput
    allocations?: PaymentAllocationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    direction?: EnumPaymentDirectionFieldUpdateOperationsInput | $Enums.PaymentDirection
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
    gl?: GLAccountUpdateOneRequiredWithoutJournalLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutJournalLinesNestedInput
    product?: ProductUpdateOneWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    model?: AutoAnalyticModelUpdateOneRequiredWithoutRulesNestedInput
    product?: ProductUpdateOneWithoutAutoAnalyticRulesNestedInput
    category?: ProductCategoryUpdateOneWithoutAutoAnalyticRulesNestedInput
    assignAnalytic?: AnalyticAccountUpdateOneRequiredWithoutAutoAnalyticRulesNestedInput
  }

  export type AutoAnalyticRuleUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCategoryCreateManyParentInput = {
    id?: string
    companyId: string
    name: string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    companyId: string
    sku?: string | null
    name: string
    uom?: string
    salePrice?: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoAnalyticRuleCreateManyCategoryInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type ProductCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutProductCategoriesNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProductsNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutProductNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutProductNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutProductNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutProductNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoAnalyticRuleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    model?: AutoAnalyticModelUpdateOneRequiredWithoutRulesNestedInput
    product?: ProductUpdateOneWithoutAutoAnalyticRulesNestedInput
    contact?: ContactUpdateOneWithoutAutoAnalyticRulesNestedInput
    assignAnalytic?: AnalyticAccountUpdateOneRequiredWithoutAutoAnalyticRulesNestedInput
  }

  export type AutoAnalyticRuleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseOrderLineCreateManyProductInput = {
    id?: string
    purchaseOrderId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateManyProductInput = {
    id?: string
    salesOrderId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateManyProductInput = {
    id?: string
    vendorBillId: string
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateManyProductInput = {
    id?: string
    customerInvoiceId: string
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateManyProductInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    analyticAccountId?: string | null
    contactId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleCreateManyProductInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchCategoryId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type PurchaseOrderLineUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutPoLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesOrder?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutSoLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesOrderId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesOrderId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bill?: VendorBillUpdateOneRequiredWithoutLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutBillLinesNestedInput
    gl?: GLAccountUpdateOneWithoutBillLinesNestedInput
  }

  export type VendorBillLineUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: CustomerInvoiceUpdateOneRequiredWithoutLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutInvLinesNestedInput
    gl?: GLAccountUpdateOneWithoutInvLinesNestedInput
  }

  export type CustomerInvoiceLineUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
    gl?: GLAccountUpdateOneRequiredWithoutJournalLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutJournalLinesNestedInput
    contact?: ContactUpdateOneWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    model?: AutoAnalyticModelUpdateOneRequiredWithoutRulesNestedInput
    category?: ProductCategoryUpdateOneWithoutAutoAnalyticRulesNestedInput
    contact?: ContactUpdateOneWithoutAutoAnalyticRulesNestedInput
    assignAnalytic?: AnalyticAccountUpdateOneRequiredWithoutAutoAnalyticRulesNestedInput
  }

  export type AutoAnalyticRuleUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnalyticAccountCreateManyParentInput = {
    id?: string
    companyId: string
    code?: string | null
    name: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BudgetLineCreateManyAnalyticInput = {
    id?: string
    budgetRevisionId: string
    glAccountId?: string | null
    amount: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateManyAnalyticInput = {
    id?: string
    journalEntryId: string
    glAccountId: string
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineCreateManyAnalyticInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateManyAnalyticInput = {
    id?: string
    salesOrderId: string
    productId: string
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateManyAnalyticInput = {
    id?: string
    vendorBillId: string
    productId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateManyAnalyticInput = {
    id?: string
    customerInvoiceId: string
    productId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleCreateManyAssignAnalyticInput = {
    id?: string
    modelId: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    matchContactId?: string | null
    rulePriority?: number
    isActive?: boolean
  }

  export type AnalyticAccountUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnalyticAccountsNestedInput
    children?: AnalyticAccountUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AnalyticAccountUncheckedUpdateManyWithoutParentNestedInput
    budgetLines?: BudgetLineUncheckedUpdateManyWithoutAnalyticNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAnalyticNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutAnalyticNestedInput
    billLines?: VendorBillLineUncheckedUpdateManyWithoutAnalyticNestedInput
    invLines?: CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticNestedInput
    autoAnalyticRules?: AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticNestedInput
  }

  export type AnalyticAccountUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetLineUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revision?: BudgetRevisionUpdateOneRequiredWithoutLinesNestedInput
    gl?: GLAccountUpdateOneWithoutBudgetLinesNestedInput
  }

  export type BudgetLineUncheckedUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetRevisionId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUncheckedUpdateManyWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetRevisionId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
    gl?: GLAccountUpdateOneRequiredWithoutJournalLinesNestedInput
    contact?: ContactUpdateOneWithoutJournalLinesNestedInput
    product?: ProductUpdateOneWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUncheckedUpdateManyWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutPoLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesOrder?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutSoLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bill?: VendorBillUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneWithoutBillLinesNestedInput
    gl?: GLAccountUpdateOneWithoutBillLinesNestedInput
  }

  export type VendorBillLineUncheckedUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUncheckedUpdateManyWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: CustomerInvoiceUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneWithoutInvLinesNestedInput
    gl?: GLAccountUpdateOneWithoutInvLinesNestedInput
  }

  export type CustomerInvoiceLineUncheckedUpdateWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleUpdateWithoutAssignAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    model?: AutoAnalyticModelUpdateOneRequiredWithoutRulesNestedInput
    product?: ProductUpdateOneWithoutAutoAnalyticRulesNestedInput
    category?: ProductCategoryUpdateOneWithoutAutoAnalyticRulesNestedInput
    contact?: ContactUpdateOneWithoutAutoAnalyticRulesNestedInput
  }

  export type AutoAnalyticRuleUncheckedUpdateWithoutAssignAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutAssignAnalyticInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JournalLineCreateManyGlInput = {
    id?: string
    journalEntryId: string
    analyticAccountId?: string | null
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineCreateManyGlInput = {
    id?: string
    budgetRevisionId: string
    analyticAccountId: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineCreateManyGlInput = {
    id?: string
    vendorBillId: string
    productId?: string | null
    analyticAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateManyGlInput = {
    id?: string
    customerInvoiceId: string
    productId?: string | null
    analyticAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutJournalLinesNestedInput
    contact?: ContactUpdateOneWithoutJournalLinesNestedInput
    product?: ProductUpdateOneWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUncheckedUpdateManyWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revision?: BudgetRevisionUpdateOneRequiredWithoutLinesNestedInput
    analytic?: AnalyticAccountUpdateOneRequiredWithoutBudgetLinesNestedInput
  }

  export type BudgetLineUncheckedUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetRevisionId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUncheckedUpdateManyWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetRevisionId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bill?: VendorBillUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneWithoutBillLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutBillLinesNestedInput
  }

  export type VendorBillLineUncheckedUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUncheckedUpdateManyWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorBillId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: CustomerInvoiceUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneWithoutInvLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutInvLinesNestedInput
  }

  export type CustomerInvoiceLineUncheckedUpdateWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutGlInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInvoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineCreateManyEntryInput = {
    id?: string
    glAccountId: string
    analyticAccountId?: string | null
    contactId?: string | null
    productId?: string | null
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gl?: GLAccountUpdateOneRequiredWithoutJournalLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutJournalLinesNestedInput
    contact?: ContactUpdateOneWithoutJournalLinesNestedInput
    product?: ProductUpdateOneWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JournalLineUncheckedUpdateManyWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    glAccountId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetRevisionCreateManyBudgetInput = {
    id?: string
    revisionNo: number
    revisionReason?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type BudgetRevisionUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: BudgetLineUpdateManyWithoutRevisionNestedInput
  }

  export type BudgetRevisionUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: BudgetLineUncheckedUpdateManyWithoutRevisionNestedInput
  }

  export type BudgetRevisionUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    revisionNo?: IntFieldUpdateOperationsInput | number
    revisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BudgetLineCreateManyRevisionInput = {
    id?: string
    analyticAccountId: string
    glAccountId?: string | null
    amount: Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUpdateWithoutRevisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    analytic?: AnalyticAccountUpdateOneRequiredWithoutBudgetLinesNestedInput
    gl?: GLAccountUpdateOneWithoutBudgetLinesNestedInput
  }

  export type BudgetLineUncheckedUpdateWithoutRevisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineUncheckedUpdateManyWithoutRevisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AutoAnalyticRuleCreateManyModelInput = {
    id?: string
    docType: $Enums.AutoDocType
    matchProductId?: string | null
    matchCategoryId?: string | null
    matchContactId?: string | null
    assignAnalyticAccountId: string
    rulePriority?: number
    isActive?: boolean
  }

  export type AutoAnalyticRuleUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneWithoutAutoAnalyticRulesNestedInput
    category?: ProductCategoryUpdateOneWithoutAutoAnalyticRulesNestedInput
    contact?: ContactUpdateOneWithoutAutoAnalyticRulesNestedInput
    assignAnalytic?: AnalyticAccountUpdateOneRequiredWithoutAutoAnalyticRulesNestedInput
  }

  export type AutoAnalyticRuleUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoAnalyticRuleUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: EnumAutoDocTypeFieldUpdateOperationsInput | $Enums.AutoDocType
    matchProductId?: NullableStringFieldUpdateOperationsInput | string | null
    matchCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    matchContactId?: NullableStringFieldUpdateOperationsInput | string | null
    assignAnalyticAccountId?: StringFieldUpdateOperationsInput | string
    rulePriority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseOrderLineCreateManyPurchaseOrderInput = {
    id?: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillCreateManyPoInput = {
    id?: string
    companyId: string
    billNo: string
    vendorId: string
    billDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    createdAt?: Date | string
  }

  export type PurchaseOrderLineUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneRequiredWithoutPoLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutPoLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVendorBillsNestedInput
    vendor?: ContactUpdateOneRequiredWithoutVendorBillsNestedInput
    lines?: VendorBillLineUpdateManyWithoutBillNestedInput
  }

  export type VendorBillUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: VendorBillLineUncheckedUpdateManyWithoutBillNestedInput
  }

  export type VendorBillUncheckedUpdateManyWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    billNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    billDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderLineCreateManySalesOrderInput = {
    id?: string
    productId: string
    analyticAccountId?: string | null
    description?: string | null
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceCreateManySoInput = {
    id?: string
    companyId: string
    invoiceNo: string
    customerId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: $Enums.DocStatus
    currency?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paymentState?: string
    portalVisible?: boolean
    createdAt?: Date | string
  }

  export type SalesOrderLineUpdateWithoutSalesOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneRequiredWithoutSoLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutSoLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutSalesOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutSalesOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceUpdateWithoutSoInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    customer?: ContactUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    lines?: CustomerInvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateWithoutSoInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: CustomerInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateManyWithoutSoInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    currency?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentState?: StringFieldUpdateOperationsInput | string
    portalVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillLineCreateManyBillInput = {
    id?: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneWithoutBillLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutBillLinesNestedInput
    gl?: GLAccountUpdateOneWithoutBillLinesNestedInput
  }

  export type VendorBillLineUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorBillLineUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineCreateManyInvoiceInput = {
    id?: string
    productId?: string | null
    analyticAccountId?: string | null
    glAccountId?: string | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneWithoutInvLinesNestedInput
    analytic?: AnalyticAccountUpdateOneWithoutInvLinesNestedInput
    gl?: GLAccountUpdateOneWithoutInvLinesNestedInput
  }

  export type CustomerInvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationCreateManyPaymentInput = {
    id?: string
    targetType: $Enums.AllocationTargetType
    targetId: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumAllocationTargetTypeFieldUpdateOperationsInput | $Enums.AllocationTargetType
    targetId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumAllocationTargetTypeFieldUpdateOperationsInput | $Enums.AllocationTargetType
    targetId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentAllocationUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumAllocationTargetTypeFieldUpdateOperationsInput | $Enums.AllocationTargetType
    targetId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}